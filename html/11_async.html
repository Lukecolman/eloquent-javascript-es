<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Programaci√≥n As√≠ncrona :: Eloquent JavaScript</title>
  <link rel=stylesheet href="css/ejs.css"><script>
      var page = {"type":"chapter","number":11,"load_files":["code/hangar2.js","code/chapter/11_async.js"]}</script></head>

<article>
<nav><a href="10_modules.html" title="previous chapter" aria-label="previous chapter">‚óÇ</a>¬†<a href="index.html" title="cover" aria-label="cover">‚óè</a>¬†<a href="12_language.html" title="next chapter" aria-label="next chapter">‚ñ∏</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>&nbsp;<button class="dark-mode-toggle">üåô</button>
</nav>

<h1>Programaci√≥n As√≠ncrona</h1>

<blockquote>

<p><a class="p_ident" id="p-50dHgvPbfK" href="#p-50dHgvPbfK" tabindex="-1" role="presentation"></a>¬øQui√©n puede esperar en silencio mientras el barro se asienta?<br>¬øQui√©n puede permanecer quieto hasta el momento de la acci√≥n?</p>

<footer>Laozi, <cite>Tao Te Ching</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_11.jpg" alt="Ilustraci√≥n que muestra dos cuervos en una rama de √°rbol"></figure>

<p><a class="p_ident" id="p-VOCX31yYLX" href="#p-VOCX31yYLX" tabindex="-1" role="presentation"></a>La parte central de una computadora, la parte que lleva a cabo los pasos individuales que componen nuestros programas, se llama el <em>procesador</em>. Los programas que hemos visto hasta ahora mantendr√°n ocupado al procesador hasta que hayan terminado su trabajo. La velocidad a la cual algo como un bucle que manipula n√∫meros puede ser ejecutado depende casi enteramente de la velocidad del procesador y la memoria de la computadora.</p>

<p><a class="p_ident" id="p-hbyVo1hWzb" href="#p-hbyVo1hWzb" tabindex="-1" role="presentation"></a>Pero muchos programas interact√∫an con cosas fuera del procesador. Por ejemplo, pueden comunicarse a trav√©s de una red de computadoras o solicitar datos desde el disco duro, lo cual es mucho m√°s lento que obtenerlo de la memoria.</p>

<p><a class="p_ident" id="p-sSdVomtbXO" href="#p-sSdVomtbXO" tabindex="-1" role="presentation"></a>Cuando esto est√° sucediendo, ser√≠a una l√°stima dejar el procesador inactivo, ya que podr√≠a haber otro trabajo que podr√≠a hacer en ese tiempo. En parte, esto es manejado por tu sistema operativo, el cual cambiar√° el procesador entre m√∫ltiples programas en ejecuci√≥n. Pero eso no ayuda cuando queremos que un <em>√∫nico</em> programa pueda avanzar mientras espera una solicitud de red.</p>

<h2><a class="h_ident" id="h-tfdiSubDV/" href="#h-tfdiSubDV/" tabindex="-1" role="presentation"></a>Asincron√≠a</h2>

<p><a class="p_ident" id="p-hOUZrWQWAe" href="#p-hOUZrWQWAe" tabindex="-1" role="presentation"></a>En un modelo de programaci√≥n <em>sincr√≥nico</em>, las cosas suceden una a la vez. Cuando llamas a una funci√≥n que realiza una acci√≥n de larga duraci√≥n, solo devuelve cuando la acci√≥n ha terminado y puede devolver el resultado. Esto detiene tu programa durante el tiempo que tome la acci√≥n.</p>

<p><a class="p_ident" id="p-AfqGZZISHU" href="#p-AfqGZZISHU" tabindex="-1" role="presentation"></a>Un modelo <em>asincr√≥nico</em> permite que m√∫ltiples cosas sucedan al mismo tiempo. Cuando inicias una acci√≥n, tu programa contin√∫a ejecut√°ndose. Cuando la acci√≥n termina, el programa es informado y obtiene acceso al resultado (por ejemplo, los datos le√≠dos desde el disco).</p>

<p><a class="p_ident" id="p-uV05EDkpgy" href="#p-uV05EDkpgy" tabindex="-1" role="presentation"></a>Podemos comparar la programaci√≥n sincr√≥nica y asincr√≥nica usando un peque√±o ejemplo: un programa que realiza dos solicitudes a trav√©s de la red y luego combina los resultados.</p>

<p><a class="p_ident" id="p-lPwjR+DoPb" href="#p-lPwjR+DoPb" tabindex="-1" role="presentation"></a>En un entorno sincr√≥nico, donde la funci√≥n de solicitud devuelve solo despu√©s de haber hecho su trabajo, la forma m√°s f√°cil de realizar esta tarea es hacer las solicitudes una despu√©s de la otra. Esto tiene la desventaja de que la segunda solicitud se iniciar√° solo cuando la primera haya terminado. El tiempo total tomado ser√° al menos la suma de los dos tiempos de respuesta.</p>

<p><a class="p_ident" id="p-CzT2t5gZTO" href="#p-CzT2t5gZTO" tabindex="-1" role="presentation"></a>La soluci√≥n a este problema, en un sistema sincr√≥nico, es iniciar hebras de control adicionales. Una <em>hebra</em> es otro programa en ejecuci√≥n cuya ejecuci√≥n puede ser intercalada con otros programas por el sistema operativo, ya que la mayor√≠a de las computadoras modernas contienen m√∫ltiples procesadores, m√∫ltiples hebras incluso podr√≠an ejecutarse al mismo tiempo, en diferentes procesadores. Una segunda hebra podr√≠a iniciar la segunda solicitud, y luego ambas hebras esperan que sus resultados regresen, despu√©s de lo cual se resincronizan para combinar sus resultados.</p>

<p><a class="p_ident" id="p-Wkrmfutpwr" href="#p-Wkrmfutpwr" tabindex="-1" role="presentation"></a>En el siguiente diagrama, las l√≠neas gruesas representan el tiempo que el programa pasa funcionando normalmente, y las l√≠neas delgadas representan el tiempo gastado esperando a la red. En el modelo s√≠ncrono, el tiempo tomado por la red es <em>parte</em> de la l√≠nea de tiempo para un hilo de control dado. En el modelo as√≠ncrono, iniciar una acci√≥n en la red permite que el programa contin√∫e ejecut√°ndose mientras la comunicaci√≥n en la red sucede junto a √©l, notificando al programa cuando haya terminado.</p><figure><img src="img/control-io.svg" alt="Diagrama que muestra el flujo de control en programas s√≠ncronos y as√≠ncronos. La primera parte muestra un programa s√≠ncrono, donde las fases activas y de espera del programa ocurren en una √∫nica l√≠nea secuencial. La segunda parte muestra un programa s√≠ncrono multi-hilo, con dos l√≠neas paralelas en las cuales las partes de espera suceden una al lado de la otra, haciendo que el programa termine m√°s r√°pido. La √∫ltima parte muestra un programa as√≠ncrono, donde las m√∫ltiples acciones as√≠ncronas se ramifican desde el programa principal, el cual se detiene en alg√∫n momento y luego contin√∫a cuando la primera cosa por la que estaba esperando finaliza."></figure>

<p><a class="p_ident" id="p-m0bMwsi7Hj" href="#p-m0bMwsi7Hj" tabindex="-1" role="presentation"></a>Otra forma de describir la diferencia es que esperar a que las acciones terminen es <em>impl√≠cito</em> en el modelo s√≠ncrono, mientras que es <em>expl√≠cito</em>, bajo nuestro control, en el modelo as√≠ncrono.</p>

<p><a class="p_ident" id="p-Gt0CDXTJDZ" href="#p-Gt0CDXTJDZ" tabindex="-1" role="presentation"></a>La asincron√≠a tiene sus pros y sus contras. Facilita la expresi√≥n de programas que no encajan en el modelo de control de l√≠nea recta, pero tambi√©n puede hacer que expresar programas que siguen una l√≠nea recta sea m√°s complicado. Veremos algunas formas de reducir esta dificultad m√°s adelante en el cap√≠tulo.</p>

<p><a class="p_ident" id="p-obm8VsybKv" href="#p-obm8VsybKv" tabindex="-1" role="presentation"></a>Tanto las plataformas de programaci√≥n de JavaScript prominentes ‚Äînavegadores como Node.js‚Äî hacen operaciones que podr√≠an tardar un tiempo de forma as√≠ncrona, en lugar de depender de hilos. Dado que programar con hilos es notoriamente dif√≠cil (entender lo que hace un programa es mucho m√°s dif√≠cil cuando est√° haciendo m√∫ltiples cosas a la vez), esto generalmente se considera algo bueno.</p>

<h2><a class="h_ident" id="h-r4RRRjuEnZ" href="#h-r4RRRjuEnZ" tabindex="-1" role="presentation"></a>Retrollamadas</h2>

<p><a class="p_ident" id="p-F908df1kGc" href="#p-F908df1kGc" tabindex="-1" role="presentation"></a>Un enfoque para la programaci√≥n as√≠ncrona es hacer que las funciones que necesitan esperar por algo tomen un argumento adicional, una <em>funci√≥n de devoluci√≥n de llamada</em>. La funci√≥n as√≠ncrona inicia alg√∫n proceso, configura las cosas para que se llame a la funci√≥n de devoluci√≥n de llamada cuando el proceso termine, y luego retorna.</p>

<p><a class="p_ident" id="p-D6ZI0eQstT" href="#p-D6ZI0eQstT" tabindex="-1" role="presentation"></a>Como ejemplo, la funci√≥n <code>setTimeout</code>, disponible tanto en Node.js como en los navegadores, espera un n√∫mero dado de milisegundos (un segundo equivale a mil milisegundos) y luego llama a una funci√≥n.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-RyFm7Uoiuv" href="#c-RyFm7Uoiuv" tabindex="-1" role="presentation"></a>setTimeout(() =&gt; console.log(<span class="tok-string">&quot;Tick&quot;</span>), <span class="tok-number">500</span>);</pre>

<p><a class="p_ident" id="p-hLrWLhn03U" href="#p-hLrWLhn03U" tabindex="-1" role="presentation"></a>Esperar no suele ser un tipo de trabajo muy importante, pero puede ser muy √∫til cuando necesitas organizar que algo suceda en un momento determinado o verificar si alguna otra acci√≥n est√° tomando m√°s tiempo del esperado.</p>

<p><a class="p_ident" id="p-IUCZ3FiQHh" href="#p-IUCZ3FiQHh" tabindex="-1" role="presentation"></a>Otro ejemplo de una operaci√≥n asincr√≥nica com√∫n es leer un archivo desde el almacenamiento de un dispositivo. Imagina que tienes una funci√≥n <code>readTextFile</code>, la cual lee el contenido de un archivo como una cadena y lo pasa a una funci√≥n de devoluci√≥n de llamada.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-W+pevJMeqq" href="#c-W+pevJMeqq" tabindex="-1" role="presentation"></a>readTextFile(<span class="tok-string">&quot;lista_de_compras.txt&quot;</span>, <span class="tok-definition">contenido</span> =&gt; {
  console.log(<span class="tok-string2">`Lista de Compras:\n</span>${contenido}<span class="tok-string2">`</span>);
});
<span class="tok-comment">// ‚Üí Lista de Compras:</span>
<span class="tok-comment">// ‚Üí Mantequilla de cacahuate</span>
<span class="tok-comment">// ‚Üí Pl√°tanos</span></pre>

<p><a class="p_ident" id="p-+9d/1JmuUd" href="#p-+9d/1JmuUd" tabindex="-1" role="presentation"></a>La funci√≥n <code>readTextFile</code> no es parte del est√°ndar de JavaScript. Veremos c√≥mo leer archivos en el navegador y en Node.js en cap√≠tulos posteriores.</p>

<p><a class="p_ident" id="p-YF9vn5sToC" href="#p-YF9vn5sToC" tabindex="-1" role="presentation"></a>Realizar m√∫ltiples acciones asincr√≥nicas en fila usando devoluciones de llamada significa que tienes que seguir pasando nuevas funciones para manejar la continuaci√≥n de la computaci√≥n despu√©s de las acciones. As√≠ es como podr√≠a verse una funci√≥n asincr√≥nica que compara dos archivos y produce un booleano que indica si su contenido es el mismo.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-NvOoAKarwY" href="#c-NvOoAKarwY" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">compararArchivos</span>(<span class="tok-definition">archivoA</span>, <span class="tok-definition">archivoB</span>, <span class="tok-definition">devolucionLlamada</span>) {
  readTextFile(archivoA, <span class="tok-definition">contenidoA</span> =&gt; {
    readTextFile(archivoB, <span class="tok-definition">contenidoB</span> =&gt; {
      devolucionLlamada(contenidoA == contenidoB);
    });
  });
}</pre>

<p><a class="p_ident" id="p-BF6VvMVpzu" href="#p-BF6VvMVpzu" tabindex="-1" role="presentation"></a>Este estilo de programaci√≥n es funcional, pero el nivel de indentaci√≥n aumenta con cada acci√≥n asincr√≥nica porque terminas en otra funci√≥n. Hacer cosas m√°s complicadas, como envolver acciones asincr√≥nicas en un bucle, puede ser inc√≥modo.</p>

<p><a class="p_ident" id="p-E60GIBKpBQ" href="#p-E60GIBKpBQ" tabindex="-1" role="presentation"></a>De alguna manera, la asincron√≠a es contagiosa. Cualquier funci√≥n que llame a una funci√≥n que trabaja de forma asincr√≥nica debe ser asincr√≥nica en s√≠ misma, utilizando una devoluci√≥n de llamada u otro mecanismo similar para entregar su resultado. Llamar a una devoluci√≥n de llamada es algo m√°s complicado y propenso a errores que simplemente devolver un valor, por lo que necesitar estructurar grandes partes de tu programa de esa manera no es ideal.</p>

<h2><a class="h_ident" id="h-O5NEmIaSuD" href="#h-O5NEmIaSuD" tabindex="-1" role="presentation"></a>Promesas</h2>

<p><a class="p_ident" id="p-ltS3in1H1E" href="#p-ltS3in1H1E" tabindex="-1" role="presentation"></a>Una forma ligeramente diferente de construir un programa asincr√≥nico es hacer que las funciones asincr√≥nicas devuelvan un objeto que represente su resultado (futuro) en lugar de pasar devoluciones de llamada por todas partes. De esta manera, tales funciones realmente devuelven algo significativo, y la estructura del programa se asemeja m√°s a la de los programas s√≠ncronos.</p>

<p><a class="p_ident" id="p-3ArPEeb3po" href="#p-3ArPEeb3po" tabindex="-1" role="presentation"></a>Para esto sirve la clase est√°ndar <code>Promise</code>. Una <em>promesa</em> es un recibo que representa un valor que a√∫n puede no estar disponible. Proporciona un m√©todo <code>then</code> que te permite registrar una funci√≥n que debe ser llamada cuando la acci√≥n por la que est√° esperando finalice. Cuando la promesa se <em>resuelve</em>, es decir, su valor se vuelve disponible, esas funciones (puede haber varias) son llamadas con el valor del resultado. Es posible llamar a <code>then</code> en una promesa que ya ha sido resuelta; tu funci√≥n seguir√° siendo llamada.</p>

<p><a class="p_ident" id="p-RGlDUtOJ93" href="#p-RGlDUtOJ93" tabindex="-1" role="presentation"></a>La forma m√°s sencilla de crear una promesa es llamando a <code>Promise.resolve</code>. Esta funci√≥n se asegura de que el valor que le proporcionas est√© envuelto en una promesa. Si ya es una promesa, simplemente se devuelve; de lo contrario, obtienes una nueva promesa que se resuelve de inmediato con tu valor como resultado.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-PQuvdLBL68" href="#c-PQuvdLBL68" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">quince</span> = Promise.resolve(<span class="tok-number">15</span>);
quince.then(<span class="tok-definition">valor</span> =&gt; console.log(<span class="tok-string2">`Obtenido </span>${valor}<span class="tok-string2">`</span>));
<span class="tok-comment">// ‚Üí Obtenido 15</span></pre>

<p><a class="p_ident" id="p-c4wtF3+bV/" href="#p-c4wtF3+bV/" tabindex="-1" role="presentation"></a>Para crear una promesa que no se resuelva inmediatamente, puedes utilizar <code>Promise</code> como constructor. Tiene una interfaz un tanto extra√±a: el constructor espera una funci√≥n como argumento, la cual llama inmediatamente, pas√°ndole una funci√≥n que puede utilizar para resolver la promesa.</p>

<p><a class="p_ident" id="p-C4xSB0FUME" href="#p-C4xSB0FUME" tabindex="-1" role="presentation"></a>As√≠ es como podr√≠as crear una interfaz basada en promesas para la funci√≥n <code>readTextFile</code>:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-2C6M2ihbOc" href="#c-2C6M2ihbOc" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">textFile</span>(<span class="tok-definition">nombreArchivo</span>) {
  <span class="tok-keyword">return</span> <span class="tok-keyword">new</span> Promise(<span class="tok-definition">resolve</span> =&gt; {
    readTextFile(nombreArchivo, <span class="tok-definition">texto</span> =&gt; resolve(texto));
  });
}

textFile(<span class="tok-string">&quot;planes.txt&quot;</span>).then(console.log);</pre>

<p><a class="p_ident" id="p-sr4id/GYVf" href="#p-sr4id/GYVf" tabindex="-1" role="presentation"></a>Observa c√≥mo esta funci√≥n as√≠ncrona devuelve un valor significativo: una promesa para proporcionarte el contenido del archivo en alg√∫n momento futuro.</p>

<p><a class="p_ident" id="p-JzjtMWC7B5" href="#p-JzjtMWC7B5" tabindex="-1" role="presentation"></a>Una caracter√≠stica √∫til del m√©todo <code>then</code> es que √©l mismo devuelve otra promesa que se resuelve al valor retornado por la funci√≥n de devoluci√≥n de llamada o, si esa funci√≥n devuelve una promesa, al valor al que esa promesa se resuelve. De esta forma, puedes ‚Äúencadenar‚Äù varias llamadas a <code>then</code> para configurar una secuencia de acciones as√≠ncronas.</p>

<p><a class="p_ident" id="p-kO8eylKtGY" href="#p-kO8eylKtGY" tabindex="-1" role="presentation"></a>Esta funci√≥n, la cual lee un archivo lleno de nombres de archivos y devuelve el contenido de un archivo aleatorio de esa lista, muestra este tipo de cadena as√≠ncrona de promesas.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Hb690LALZU" href="#c-Hb690LALZU" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">randomFile</span>(<span class="tok-definition">archivoLista</span>) {
  <span class="tok-keyword">return</span> textFile(archivoLista)
    .then(<span class="tok-definition">contenido</span> =&gt; contenido.trim().split(<span class="tok-string">&quot;</span><span class="tok-string2">\n</span><span class="tok-string">&quot;</span>))
    .then(<span class="tok-definition">ls</span> =&gt; ls[Math.floor(Math.random() * ls.length)])
    .then(<span class="tok-definition">nombreArchivo</span> =&gt; textFile(nombreArchivo));
}</pre>

<p><a class="p_ident" id="p-vwGbLsp+ut" href="#p-vwGbLsp+ut" tabindex="-1" role="presentation"></a>La funci√≥n devuelve el resultado de esta cadena de llamadas a <code>then</code>. La promesa inicial obtiene la lista de archivos como una cadena. La primera llamada a <code>then</code> transforma esa cadena en un array de l√≠neas, produciendo una nueva promesa. La segunda llamada a <code>then</code> elige una l√≠nea aleatoria de eso, produciendo una tercera promesa que arroja un √∫nico nombre de archivo. La llamada final a <code>then</code> lee este archivo, de modo que el resultado de la funci√≥n en su totalidad es una promesa que devuelve el contenido de un archivo aleatorio.</p>

<p><a class="p_ident" id="p-WSdli2Whfb" href="#p-WSdli2Whfb" tabindex="-1" role="presentation"></a>En este c√≥digo, las funciones utilizadas en las primeras dos llamadas a <code>then</code> devuelven un valor regular, que se pasar√° inmediatamente a la promesa devuelta por <code>then</code> cuando la funci√≥n regrese. La √∫ltima devuelve una promesa (<code>textFile(nombreArchivo)</code>), convirti√©ndola en un paso asincr√≥nico real.</p>

<p><a class="p_ident" id="p-z9ZsQuS8Cj" href="#p-z9ZsQuS8Cj" tabindex="-1" role="presentation"></a>Tambi√©n habr√≠a sido posible realizar todos estos pasos dentro de un solo callback de <code>then</code>, ya que solo el √∫ltimo paso es realmente as√≠ncrono. Pero los tipos de envolturas <code>then</code> que solo realizan alguna transformaci√≥n de datos s√≠ncrona son a menudo √∫tiles, por ejemplo, cuando deseas devolver una promesa que produzca una versi√≥n procesada de alg√∫n resultado as√≠ncrono.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Q3vBSBU3QB" href="#c-Q3vBSBU3QB" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">jsonFile</span>(<span class="tok-definition">nombreArchivo</span>) {
  <span class="tok-keyword">return</span> textFile(nombreArchivo).then(JSON.parse);
}

jsonFile(<span class="tok-string">&quot;package.json&quot;</span>).then(console.log);</pre>

<p><a class="p_ident" id="p-YrcahdlIgs" href="#p-YrcahdlIgs" tabindex="-1" role="presentation"></a>En general, es √∫til pensar en las promesas como un mecanismo que permite al c√≥digo ignorar la pregunta de cu√°ndo va a llegar un valor. Un valor normal tiene que existir realmente antes de que podamos hacer referencia a √©l. Un valor prometido es un valor que <em>puede</em> estar all√≠ o podr√≠a aparecer en alg√∫n momento en el futuro. Las operaciones definidas en t√©rminos de promesas, al conectarlas con llamadas <code>then</code>, se ejecutan de forma as√≠ncrona a medida que sus entradas est√°n disponibles.</p>

<h2><a class="h_ident" id="h-itgMGyRo24" href="#h-itgMGyRo24" tabindex="-1" role="presentation"></a>Falla</h2>

<p><a class="p_ident" id="p-+fxovQGwNA" href="#p-+fxovQGwNA" tabindex="-1" role="presentation"></a>Las computaciones regulares de JavaScript pueden fallar al lanzar una excepci√≥n. Las computaciones as√≠ncronas a menudo necesitan algo as√≠. Una solicitud de red puede fallar, un archivo puede no existir, o alg√∫n c√≥digo que forma parte de la computaci√≥n as√≠ncrona puede lanzar una excepci√≥n.</p>

<p><a class="p_ident" id="p-8XWhkwl0eo" href="#p-8XWhkwl0eo" tabindex="-1" role="presentation"></a>Uno de los problemas m√°s apremiantes con el estilo de programaci√≥n as√≠ncrona basado en devoluciones de llamada es que hace extremadamente dif√≠cil asegurarse de que las fallas se informen adecuadamente a las devoluciones de llamada.</p>

<p><a class="p_ident" id="p-r4LVn4wZ0P" href="#p-r4LVn4wZ0P" tabindex="-1" role="presentation"></a>Una convenci√≥n ampliamente utilizada es que el primer argumento de la devoluci√≥n de llamada se utiliza para indicar que la acci√≥n fall√≥, y el segundo contiene el valor producido por la acci√≥n cuando fue exitosa.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-/lUgiJQG9L" href="#c-/lUgiJQG9L" tabindex="-1" role="presentation"></a>unaFuncionAsincrona((<span class="tok-definition">error</span>, <span class="tok-definition">valor</span>) =&gt; {
  <span class="tok-keyword">if</span> (error) manejarError(error);
  <span class="tok-keyword">else</span> procesarValor(valor);
});</pre>

<p><a class="p_ident" id="p-WOsDKk7EQx" href="#p-WOsDKk7EQx" tabindex="-1" role="presentation"></a>Tales funciones de devoluci√≥n de llamada siempre deben verificar si recibieron una excepci√≥n y asegurarse de que cualquier problema que causen, incluidas las excepciones lanzadas por las funciones que llaman, se capturen y se den a la funci√≥n correcta.</p>

<p><a class="p_ident" id="p-4XJanqagJR" href="#p-4XJanqagJR" tabindex="-1" role="presentation"></a>Las promesas facilitan esto. Pueden ser o bien resueltas (la acci√≥n se complet√≥ con √©xito) o rechazadas (fall√≥). Los manejadores de resoluci√≥n (como se registran con <code>then</code>) se llaman solo cuando la acci√≥n es exitosa, y los rechazos se propagan a la nueva promesa que es devuelta por <code>then</code>. Cuando un manejador lanza una excepci√≥n, esto causa autom√°ticamente que la promesa producida por la llamada a su <code>then</code> sea rechazada. Entonces, si alg√∫n elemento en una cadena de acciones as√≠ncronas falla, el resultado de toda la cadena se marca como rechazado, y no se llaman manejadores de √©xito m√°s all√° del punto donde fall√≥.</p>

<p><a class="p_ident" id="p-JZgXPDvBUG" href="#p-JZgXPDvBUG" tabindex="-1" role="presentation"></a>Al igual que resolver una promesa proporciona un valor, rechazar una tambi√©n lo hace, generalmente llamado el <em>motivo</em> del rechazo. Cuando una excepci√≥n en una funci√≥n manejadora causa el rechazo, el valor de la excepci√≥n se usa como el motivo. De manera similar, cuando una funci√≥n manejadora devuelve una promesa que es rechazada, ese rechazo fluye hacia la siguiente promesa. Existe una funci√≥n <code>Promise.reject</code> que crea una nueva promesa inmediatamente rechazada.</p>

<p><a class="p_ident" id="p-gAl8dny3ZI" href="#p-gAl8dny3ZI" tabindex="-1" role="presentation"></a>Para manejar expl√≠citamente tales rechazos, las promesas tienen un m√©todo <code>catch</code> que registra un manejador para ser llamado cuando la promesa es rechazada, similar a c√≥mo los manejadores de <code>then</code> manejan la resoluci√≥n normal. Tambi√©n es muy similar a <code>then</code> en que devuelve una nueva promesa, que se resuelve con el valor de la promesa original cuando se resuelve normalmente y con el resultado del manejador <code>catch</code> en caso contrario. Si un manejador de <code>catch</code> lanza un error, la nueva promesa tambi√©n se rechaza.</p>

<p><a class="p_ident" id="p-SHY7aonJ/O" href="#p-SHY7aonJ/O" tabindex="-1" role="presentation"></a>Como un atajo, <code>then</code> tambi√©n acepta un manejador de rechazo como segundo argumento, para poder instalar ambos tipos de manejadores en una sola llamada de m√©todo.</p>

<p><a class="p_ident" id="p-cAXjTS7KlW" href="#p-cAXjTS7KlW" tabindex="-1" role="presentation"></a>Una funci√≥n pasada al constructor <code>Promise</code> recibe un segundo argumento, junto con la funci√≥n de resoluci√≥n, que puede usar para rechazar la nueva promesa.Cuando nuestra funci√≥n <code>readTextFile</code> encuentra un problema, pasa el error a su funci√≥n de devoluci√≥n de llamada como segundo argumento. Nuestro envoltorio <code>textFile</code> deber√≠a realmente examinar ese argumento, de manera que un fallo cause que la promesa que devuelve sea rechazada.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Z3TGL4evDx" href="#c-Z3TGL4evDx" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">textFile</span>(<span class="tok-definition">filename</span>) {
  <span class="tok-keyword">return</span> <span class="tok-keyword">new</span> Promise((<span class="tok-definition">resolve</span>, <span class="tok-definition">reject</span>) =&gt; {
    readTextFile(filename, (<span class="tok-definition">text</span>, <span class="tok-definition">error</span>) =&gt; {
      <span class="tok-keyword">if</span> (error) reject(error);
      <span class="tok-keyword">else</span> resolve(text);
    });
  });
}</pre>

<p><a class="p_ident" id="p-LtILeb1bZh" href="#p-LtILeb1bZh" tabindex="-1" role="presentation"></a>Las cadenas de valores de promesa creadas por llamadas a <code>then</code> y <code>catch</code> forman as√≠ un pipeline a trav√©s del cual se mueven los valores as√≠ncronos o fallos. Dado que dichas cadenas se crean registrando manejadores, cada eslab√≥n tiene asociado un manejador de √©xito o un manejador de rechazo (o ambos). Los manejadores que no coinciden con el tipo de resultado (√©xito o fallo) son ignorados. Pero aquellos que coinciden son llamados, y su resultado determina qu√© tipo de valor viene a continuaci√≥n: √©xito cuando devuelve un valor que no es una promesa, rechazo cuando genera una excepci√≥n, y el resultado de la promesa cuando devuelve una promesa.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-2Eh0hD89OR" href="#c-2Eh0hD89OR" tabindex="-1" role="presentation"></a><span class="tok-keyword">new</span> Promise((<span class="tok-definition">_</span>, <span class="tok-definition">reject</span>) =&gt; reject(<span class="tok-keyword">new</span> Error(<span class="tok-string">&quot;Fail&quot;</span>)))
  .then(<span class="tok-definition">value</span> =&gt; console.log(<span class="tok-string">&quot;Manejador 1:&quot;</span>, value))
  .catch(<span class="tok-definition">reason</span> =&gt; {
    console.log(<span class="tok-string">&quot;Error capturado &quot;</span> + reason);
    <span class="tok-keyword">return</span> <span class="tok-string">&quot;nada&quot;</span>;
  })
  .then(<span class="tok-definition">value</span> =&gt; console.log(<span class="tok-string">&quot;Manejador 2:&quot;</span>, value));
<span class="tok-comment">// ‚Üí Error capturado Error: Fail</span>
<span class="tok-comment">// ‚Üí Handler 2: nothing</span></pre>

<p><a class="p_ident" id="p-iBD0Lbg2Bk" href="#p-iBD0Lbg2Bk" tabindex="-1" role="presentation"></a>La primera funci√≥n de manejador regular no es llamada, porque en ese punto del pipeline la promesa contiene un rechazo. El manejador <code>catch</code> maneja ese rechazo y devuelve un valor, que se le da a la segunda funci√≥n de manejador.</p>

<p><a class="p_ident" id="p-nAXpd8J86T" href="#p-nAXpd8J86T" tabindex="-1" role="presentation"></a>Cuando una excepci√≥n no controlada es manejada por el entorno, los entornos de JavaScript pueden detectar cu√°ndo un rechazo de promesa no es manejado y lo reportar√°n como un error.</p>

<h2><a class="h_ident" id="h-XxJsV0JUaZ" href="#h-XxJsV0JUaZ" tabindex="-1" role="presentation"></a>Carla</h2>

<p><a class="p_ident" id="p-sI2r0mTENb" href="#p-sI2r0mTENb" tabindex="-1" role="presentation"></a>Es un d√≠a soleado en Berl√≠n. La pista del antiguo aeropuerto desmantelado rebosa de ciclistas y patinadores en l√≠nea. En el c√©sped cerca de un contenedor de basura un grupo de cuervos se agita ruidosamente, intentando convencer a un grupo de turistas de que les den sus s√°ndwiches.</p>

<p><a class="p_ident" id="p-jIHoxx51eu" href="#p-jIHoxx51eu" tabindex="-1" role="presentation"></a>Uno de los cuervos destaca: una hembra grande andrajosa con algunas plumas blancas en su ala derecha. Est√° atrayendo a la gente con habilidad y confianza que sugieren que ha estado haciendo esto durante mucho tiempo. Cuando un anciano se distrae con las travesuras de otro cuervo, ella se abalanza casualmente, arrebata su bollo a medio comer de su mano y se aleja planeando.</p>

<p><a class="p_ident" id="p-cvIv/A82B2" href="#p-cvIv/A82B2" tabindex="-1" role="presentation"></a>A diferencia del resto del grupo, que parece estar feliz de pasar el d√≠a holgazaneando aqu√≠, el cuervo grande parece tener un prop√≥sito. Llevando su bot√≠n, vuela directamente hacia el techo del edificio del hangar, desapareciendo en una rejilla de ventilaci√≥n.</p>

<p><a class="p_ident" id="p-LznaJcdrKY" href="#p-LznaJcdrKY" tabindex="-1" role="presentation"></a>Dentro del edificio, se puede escuchar un sonido peculiar: suave, pero persistente. Viene de un espacio estrecho bajo el techo de una escalera sin terminar. El cuervo est√° sentado all√≠, rodeado de sus botines robados, media docena de tel√©fonos inteligentes (varios de los cuales est√°n encendidos) y un enredo de cables. Golpea r√°pidamente la pantalla de uno de los tel√©fonos con su pico. Aparecen palabras en √©l. Si no supieras mejor, pensar√≠as que estaba escribiendo.Este cuervo es conocido por sus pares como ‚ÄúcƒÅƒÅw-kr√∂&quot;. Pero dado que esos sonidos no son adecuados para las cuerdas vocales humanas, la llamaremos Carla.</p>

<p><a class="p_ident" id="p-qyFUB1V+JF" href="#p-qyFUB1V+JF" tabindex="-1" role="presentation"></a>Carla es un cuervo algo peculiar. En su juventud, estaba fascinada por el lenguaje humano, escuchando a la gente hasta que tuvo un buen entendimiento de lo que dec√≠an. M√°s tarde, su inter√©s se traslad√≥ a la tecnolog√≠a humana, y comenz√≥ a robar tel√©fonos para estudiarlos. Su proyecto actual es aprender a programar. El texto que est√° escribiendo en su laboratorio secreto, de hecho, es un fragmento de c√≥digo JavaScript.</p>

<h2><a class="h_ident" id="h-/5q4Gr2m3m" href="#h-/5q4Gr2m3m" tabindex="-1" role="presentation"></a>Infiltraci√≥n</h2>

<p><a class="p_ident" id="p-lIH7NawKaH" href="#p-lIH7NawKaH" tabindex="-1" role="presentation"></a>A Carla le encanta Internet. Fastidiosamente, el tel√©fono en el que est√° trabajando est√° a punto de quedarse sin datos prepagos. El edificio tiene una red inal√°mbrica, pero se requiere un c√≥digo para acceder a ella.</p>

<p><a class="p_ident" id="p-8ZznJOIiK/" href="#p-8ZznJOIiK/" tabindex="-1" role="presentation"></a>Afortunadamente, los enrutadores inal√°mbricos en el edificio tienen 20 a√±os y est√°n mal protegidos. Tras investigar un poco, Carla descubre que el mecanismo de autenticaci√≥n de la red tiene una falla que puede aprovechar. Al unirse a la red, un dispositivo debe enviar el c√≥digo correcto de 6 d√≠gitos. El punto de acceso responder√° con un mensaje de √©xito o fracaso dependiendo de si se proporciona el c√≥digo correcto. Sin embargo, al enviar solo un c√≥digo parcial (digamos, solo 3 d√≠gitos), la respuesta es diferente seg√∫n si esos d√≠gitos son el inicio correcto del c√≥digo o no. Cuando se env√≠a un n√∫mero incorrecto, se recibe inmediatamente un mensaje de fracaso. Cuando se env√≠an los correctos, el punto de acceso espera m√°s d√≠gitos.</p>

<p><a class="p_ident" id="p-Jzo5cZ0BBA" href="#p-Jzo5cZ0BBA" tabindex="-1" role="presentation"></a>Esto hace posible acelerar enormemente la adivinaci√≥n del n√∫mero. Carla puede encontrar el primer d√≠gito probando cada n√∫mero a su vez, hasta que encuentre uno que no devuelva inmediatamente un fracaso. Teniendo un d√≠gito, puede encontrar el segundo de la misma manera, y as√≠ sucesivamente, hasta que conozca todo el c√≥digo de acceso.</p>

<p><a class="p_ident" id="p-RIZ6rVDtx9" href="#p-RIZ6rVDtx9" tabindex="-1" role="presentation"></a>Supongamos que tenemos una funci√≥n <code>joinWifi</code>. Dado el nombre de la red y el c√≥digo de acceso (como una cadena), intenta unirse a la red, devolviendo una promesa que se resuelve si tiene √©xito, y se rechaza si la autenticaci√≥n falla. Lo primero que necesitamos es una forma de envolver una promesa para que se rechace autom√°ticamente despu√©s de transcurrir demasiado tiempo, de manera que podamos avanzar r√°pidamente si el punto de acceso no responde.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-yGIEN33W5z" href="#c-yGIEN33W5z" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">withTimeout</span>(<span class="tok-definition">promise</span>, <span class="tok-definition">tiempo</span>) {
  <span class="tok-keyword">return</span> <span class="tok-keyword">new</span> Promise((<span class="tok-definition">resolve</span>, <span class="tok-definition">reject</span>) =&gt; {
    promise.then(resolve, reject);
    setTimeout(() =&gt; reject(<span class="tok-string">&quot;Se agot√≥ el tiempo&quot;</span>), tiempo);
  });
}</pre>

<p><a class="p_ident" id="p-5b6JDzOqB2" href="#p-5b6JDzOqB2" tabindex="-1" role="presentation"></a>Esto aprovecha el hecho de que una promesa solo puede resolverse o rechazarse una vez: si la promesa dada como argumento se resuelve o se rechaza primero, ese ser√° el resultado de la promesa devuelta por <code>withTimeout</code>. Si, por otro lado, el <code>setTimeout</code> se ejecuta primero, rechazando la promesa, se ignoran cualquier llamada posterior a resolve o reject.</p>

<p><a class="p_ident" id="p-aGXBBNJk0l" href="#p-aGXBBNJk0l" tabindex="-1" role="presentation"></a>Para encontrar todo el c√≥digo de acceso, necesitamos buscar repetidamente el siguiente d√≠gito probando cada d√≠gito. Si la autenticaci√≥n tiene √©xito, sabremos que hemos encontrado lo que buscamos. Si falla inmediatamente, sabremos que ese d√≠gito era incorrecto y debemos probar con el siguiente. Si la solicitud se agota, hemos encontrado otro d√≠gito correcto y debemos continuar agregando otro d√≠gito.Debido a que no puedes esperar una promesa dentro de un bucle <code>for</code>, Carla utiliza una funci√≥n recursiva para llevar a cabo este proceso. En cada llamada, obtiene el c√≥digo tal como lo conocemos hasta ahora, as√≠ como el siguiente d√≠gito a probar. Dependiendo de lo que suceda, puede devolver un c√≥digo terminado, o llamar de nuevo a s√≠ misma, ya sea para comenzar a descifrar la siguiente posici√≥n en el c√≥digo, o para intentarlo de nuevo con otro d√≠gito.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-rKTBHF8p2l" href="#c-rKTBHF8p2l" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">crackPasscode</span>(<span class="tok-definition">networkID</span>) {
  <span class="tok-keyword">function</span> <span class="tok-definition">nextDigit</span>(<span class="tok-definition">code</span>, <span class="tok-definition">digit</span>) {
    <span class="tok-keyword">let</span> <span class="tok-definition">newCode</span> = code + digit;
    <span class="tok-keyword">return</span> withTimeout(joinWifi(networkID, newCode), <span class="tok-number">50</span>)
      .then(() =&gt; newCode)
      .catch(<span class="tok-definition">failure</span> =&gt; {
        <span class="tok-keyword">if</span> (failure == <span class="tok-string">&quot;Timed out&quot;</span>) {
          <span class="tok-keyword">return</span> nextDigit(newCode, <span class="tok-number">0</span>);
        } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (digit &lt; <span class="tok-number">9</span>) {
          <span class="tok-keyword">return</span> nextDigit(code, digit + <span class="tok-number">1</span>);
        } <span class="tok-keyword">else</span> {
          <span class="tok-keyword">throw</span> failure;
        }
      });
  }
  <span class="tok-keyword">return</span> nextDigit(<span class="tok-string">&quot;&quot;</span>, <span class="tok-number">0</span>);
}</pre>

<p><a class="p_ident" id="p-7c/57tY3Ft" href="#p-7c/57tY3Ft" tabindex="-1" role="presentation"></a>El punto de acceso suele responder a solicitudes de autenticaci√≥n incorrectas en aproximadamente 20 milisegundos, por lo que, para estar seguros, esta funci√≥n espera 50 milisegundos antes de hacer expirar una solicitud.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-QKY6kJy25c" href="#c-QKY6kJy25c" tabindex="-1" role="presentation"></a>crackPasscode(<span class="tok-string">&quot;HANGAR 2&quot;</span>).then(console.log);
<span class="tok-comment">// ‚Üí 555555</span></pre>

<p><a class="p_ident" id="p-KpmbzaGvuk" href="#p-KpmbzaGvuk" tabindex="-1" role="presentation"></a>Carla inclina la cabeza y suspira. Esto habr√≠a sido m√°s satisfactorio si el c√≥digo hubiera sido un poco m√°s dif√≠cil de adivinar.</p>

<h2><a class="h_ident" id="h-NGTlK4NQNX" href="#h-NGTlK4NQNX" tabindex="-1" role="presentation"></a>Funciones as√≠ncronas</h2>

<p><a class="p_ident" id="p-1bcWQeAU8b" href="#p-1bcWQeAU8b" tabindex="-1" role="presentation"></a>Incluso con promesas, este tipo de c√≥digo as√≠ncrono es molesto de escribir. Las promesas a menudo necesitan ser encadenadas de manera verbosa y arbitraria. Y nos vimos obligados a introducir una funci√≥n recursiva solo para crear un bucle.</p>

<p><a class="p_ident" id="p-JTBQPMRuqH" href="#p-JTBQPMRuqH" tabindex="-1" role="presentation"></a>Lo que la funci√≥n de descifrado realmente hace es completamente lineal: siempre espera a que la acci√≥n anterior se complete antes de comenzar la siguiente. En un modelo de programaci√≥n s√≠ncrona, ser√≠a m√°s sencillo de expresar.</p>

<p><a class="p_ident" id="p-G5SArOKa1V" href="#p-G5SArOKa1V" tabindex="-1" role="presentation"></a>La buena noticia es que JavaScript te permite escribir c√≥digo pseudo-sincr√≥nico para describir la computaci√≥n as√≠ncrona. Una funci√≥n <code>async</code> es una funci√≥n que impl√≠citamente devuelve una promesa y que puede, en su cuerpo, <code>await</code> otras promesas de una manera que <em>parece</em> sincr√≥nica.</p>

<p><a class="p_ident" id="p-QE3XBITstL" href="#p-QE3XBITstL" tabindex="-1" role="presentation"></a>Podemos reescribir <code>crackPasscode</code> de la siguiente manera:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-f8fODDM35B" href="#c-f8fODDM35B" tabindex="-1" role="presentation"></a><span class="tok-keyword">async</span> <span class="tok-keyword">function</span> <span class="tok-definition">crackPasscode</span>(<span class="tok-definition">networkID</span>) {
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">code</span> = <span class="tok-string">&quot;&quot;</span>;;) {
    <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">digit</span> = <span class="tok-number">0</span>;; digit++) {
      <span class="tok-keyword">let</span> <span class="tok-definition">newCode</span> = code + digit;
      <span class="tok-keyword">try</span> {
        <span class="tok-keyword">await</span> withTimeout(joinWifi(networkID, newCode), <span class="tok-number">50</span>);
        <span class="tok-keyword">return</span> newCode;
      } <span class="tok-keyword">catch</span> (<span class="tok-definition">failure</span>) {
        <span class="tok-keyword">if</span> (failure == <span class="tok-string">&quot;Timed out&quot;</span>) {
          code = newCode;
          <span class="tok-keyword">break</span>;
        } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (digit == <span class="tok-number">9</span>) {
          <span class="tok-keyword">throw</span> failure;
        }
      }
    }
  }
}</pre>

<p><a class="p_ident" id="p-+4mFixoWg7" href="#p-+4mFixoWg7" tabindex="-1" role="presentation"></a>Esta versi√≥n muestra de manera m√°s clara la estructura de doble bucle de la funci√≥n (el bucle interno prueba el d√≠gito 0 al 9, el bucle externo a√±ade d√≠gitos al c√≥digo de acceso).</p>

<p><a class="p_ident" id="p-MHiEBPHcq0" href="#p-MHiEBPHcq0" tabindex="-1" role="presentation"></a>Una funci√≥n <code>async</code> est√° marcada con la palabra <code>async</code> antes de la palabra clave <code>function</code>. Los m√©todos tambi√©n pueden ser marcados como <code>async</code> escribiendo <code>async</code> antes de su nombre. Cuando se llama a una funci√≥n o m√©todo de esta manera, devuelve una promesa. Tan pronto como la funci√≥n devuelve algo, esa promesa se resuelve. Si el cuerpo genera una excepci√≥n, la promesa es rechazada.</p>

<p><a class="p_ident" id="p-GXfnmGh9zs" href="#p-GXfnmGh9zs" tabindex="-1" role="presentation"></a>Dentro de una funci√≥n <code>async</code>, la palabra <code>await</code> puede colocarse delante de una expresi√≥n para esperar a que una promesa se resuelva y luego continuar con la ejecuci√≥n de la funci√≥n. Si la promesa es rechazada, se genera una excepci√≥n en el punto del <code>await</code>.</p>

<p><a class="p_ident" id="p-o9TSZxwXki" href="#p-o9TSZxwXki" tabindex="-1" role="presentation"></a>Una funci√≥n as√≠ ya no se ejecuta, como una funci√≥n regular de JavaScript, de principio a fin de una sola vez. En su lugar, puede estar <em>congelada</em> en cualquier punto que tenga un <code>await</code>, y puede continuar m√°s tarde.</p>

<p><a class="p_ident" id="p-YwhF0rS3qb" href="#p-YwhF0rS3qb" tabindex="-1" role="presentation"></a>Para la mayor√≠a del c√≥digo as√≠ncrono, esta notaci√≥n es m√°s conveniente que usar directamente promesas. A√∫n necesitas comprender las promesas, ya que en muchos casos todav√≠a interact√∫as con ellas directamente. Pero al encadenarlas, las funciones <code>async</code> suelen ser m√°s agradables de escribir que encadenar llamadas <code>then</code>.</p>

<h2 id="generator"><a class="h_ident" id="h-LGLwBM7N7Q" href="#h-LGLwBM7N7Q" tabindex="-1" role="presentation"></a>Generadores</h2>

<p><a class="p_ident" id="p-vucanJZjN2" href="#p-vucanJZjN2" tabindex="-1" role="presentation"></a>Esta capacidad de pausar y luego reanudar funciones no es exclusiva de las funciones <code>async</code>. JavaScript tambi√©n tiene una caracter√≠stica llamada <em>generador</em> functions. Son similares, pero sin las promesas.</p>

<p><a class="p_ident" id="p-KhGB+fXocF" href="#p-KhGB+fXocF" tabindex="-1" role="presentation"></a>Cuando defines una funci√≥n con <code>function*</code> (colocando un asterisco despu√©s de la palabra <code>function</code>), se convierte en un generador. Al llamar a un generador, devuelve un iterador, que ya vimos en el <a href="06_object.html">Cap√≠tulo 6</a>.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-B4ek89g871" href="#c-B4ek89g871" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span><span class="tok-keyword">*</span> <span class="tok-definition">powers</span>(<span class="tok-definition">n</span>) {
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">current</span> = n;; current *= n) {
    <span class="tok-keyword">yield</span> current;
  }
}

<span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">power</span> <span class="tok-keyword">of</span> powers(<span class="tok-number">3</span>)) {
  <span class="tok-keyword">if</span> (power &gt; <span class="tok-number">50</span>) <span class="tok-keyword">break</span>;
  console.log(power);
}
<span class="tok-comment">// ‚Üí 3</span>
<span class="tok-comment">// ‚Üí 9</span>
<span class="tok-comment">// ‚Üí 27</span></pre>

<p><a class="p_ident" id="p-aD9V5e562+" href="#p-aD9V5e562+" tabindex="-1" role="presentation"></a>Inicialmente, al llamar a <code>powers</code>, la funci√≥n se congela desde el principio. Cada vez que llamas a <code>next</code> en el iterador, la funci√≥n se ejecuta hasta que encuentra una expresi√≥n <code>yield</code>, que la pausa y hace que el valor generado se convierta en el pr√≥ximo valor producido por el iterador. Cuando la funci√≥n retorna (la del ejemplo nunca lo hace), el iterador ha terminado.</p>

<p><a class="p_ident" id="p-+edzRQNWn2" href="#p-+edzRQNWn2" tabindex="-1" role="presentation"></a>Escribir iteradores a menudo es mucho m√°s f√°cil cuando usas funciones generadoras. El iterador para la clase <code>Group</code> (del ejercicio en el <a href="06_object.html#group_iterator">Cap√≠tulo 6</a>) se puede escribir con este generador:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-C6OZWjI9EM" href="#c-C6OZWjI9EM" tabindex="-1" role="presentation"></a>Group.prototype[Symbol.iterator] = <span class="tok-keyword">function</span><span class="tok-keyword">*</span>() {
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">i</span> = <span class="tok-number">0</span>; i &lt; <span class="tok-keyword">this</span>.members.length; i++) {
    <span class="tok-keyword">yield</span> <span class="tok-keyword">this</span>.members[i];
  }
};</pre>

<p><a class="p_ident" id="p-Tcmh5kj782" href="#p-Tcmh5kj782" tabindex="-1" role="presentation"></a>Ya no es necesario crear un objeto para mantener el estado de la iteraci√≥n: los generadores guardan autom√°ticamente su estado local cada vez que hacen un <code>yield</code>.</p>

<p><a class="p_ident" id="p-C276cu76si" href="#p-C276cu76si" tabindex="-1" role="presentation"></a>Tales expresiones <code>yield</code> solo pueden ocurrir directamente en la funci√≥n generadora misma y no en una funci√≥n interna que definas dentro de ella. El estado que un generador guarda, al hacer yield, es solo su entorno <em>local</em> y la posici√≥n donde hizo el yield.</p>

<p><a class="p_ident" id="p-+kfgMm93qQ" href="#p-+kfgMm93qQ" tabindex="-1" role="presentation"></a>Una funci√≥n <code>async</code> es un tipo especial de generador. Produce una promesa al llamarla, la cual se resuelve cuando retorna (termina) y se rechaza cuando arroja una excepci√≥n. Cada vez que hace un yield (awaits) una promesa, el resultado de esa promesa (valor o excepci√≥n generada) es el resultado de la expresi√≥n <code>await</code>.</p>

<h2><a class="h_ident" id="h-0q8YSKeCAX" href="#h-0q8YSKeCAX" tabindex="-1" role="presentation"></a>Un Proyecto de Arte de Corvidos</h2>

<p><a class="p_ident" id="p-EIAKJkXc8j" href="#p-EIAKJkXc8j" tabindex="-1" role="presentation"></a>Esta ma√±ana, Carla se despert√≥ con un ruido desconocido en la pista de aterrizaje fuera de su hangar. Saltando al borde del techo, ve que los humanos est√°n preparando algo. Hay muchos cables el√©ctricos, un escenario y una especie de gran pared negra que est√°n construyendo.</p>

<p><a class="p_ident" id="p-7+FP7NBriA" href="#p-7+FP7NBriA" tabindex="-1" role="presentation"></a>Siendo una cuerva curiosa, Carla echa un vistazo m√°s de cerca a la pared. Parece estar compuesta por varios dispositivos grandes con frente de vidrio conectados a cables. En la parte trasera, los dispositivos dicen ‚ÄúLedTec SIG-5030‚Äù.</p>

<p><a class="p_ident" id="p-yBNrkTbIgn" href="#p-yBNrkTbIgn" tabindex="-1" role="presentation"></a>Una r√°pida b√∫squeda en Internet saca a relucir un manual de usuario para estos dispositivos. Parecen ser se√±ales de tr√°fico, con una matriz programable de luces LED ambarinas. La intenci√≥n de los humanos probablemente sea mostrar alg√∫n tipo de informaci√≥n en ellas durante su evento. Curiosamente, las pantallas pueden ser programadas a trav√©s de una red inal√°mbrica. ¬øPodr√≠a ser que est√©n conectadas a la red local del edificio?</p>

<p><a class="p_ident" id="p-4e69YlbBkR" href="#p-4e69YlbBkR" tabindex="-1" role="presentation"></a>Cada dispositivo en una red recibe una <em>direcci√≥n IP</em>, que otros dispositivos pueden usar para enviarle mensajes. Hablamos m√°s sobre eso en el <a href="13_browser.html">Cap√≠tulo 13</a>. Carla nota que sus propios tel√©fonos reciben direcciones como <code>10.0.0.20</code> o <code>10.0.0.33</code>. Podr√≠a valer la pena intentar enviar mensajes a todas esas direcciones y ver si alguna responde a la interfaz descrita en el manual de las se√±ales.</p>

<p><a class="p_ident" id="p-nKIobazOIw" href="#p-nKIobazOIw" tabindex="-1" role="presentation"></a>El <a href="18_http.html">Cap√≠tulo 18</a> muestra c√≥mo hacer solicitudes reales en redes reales. En este cap√≠tulo, usaremos una funci√≥n ficticia simplificada llamada <code>request</code> para la comunicaci√≥n en red. Esta funci√≥n toma dos argumentos: una direcci√≥n de red y un mensaje, que puede ser cualquier cosa que se pueda enviar como JSON, y devuelve una promesa que se resuelve con una respuesta de la m√°quina en la direcci√≥n dada, o se rechaza si hubo un problema.</p>

<p><a class="p_ident" id="p-3j7VheCqjp" href="#p-3j7VheCqjp" tabindex="-1" role="presentation"></a>Seg√∫n el manual, puedes cambiar lo que se muestra en una se√±al SIG-5030 envi√°ndole un mensaje con contenido como <code>{&quot;command&quot;: &quot;display&quot;, &quot;data&quot;: [0, 0, 3, ‚Ä¶]}</code>, donde <code>data</code> contiene un n√∫mero por cada punto de LED, indicando su brillo; 0 significa apagado, 3 significa brillo m√°ximo. Cada se√±al tiene 50 luces de ancho y 30 luces de alto, por lo que un comando de actualizaci√≥n debe enviar 1500 n√∫meros.</p>

<p><a class="p_ident" id="p-Id2shPCIz0" href="#p-Id2shPCIz0" tabindex="-1" role="presentation"></a>Este c√≥digo env√≠a un mensaje de actualizaci√≥n de pantalla a todas las direcciones en la red local para ver cu√°l se queda. Cada uno de los n√∫meros en una direcci√≥n IP puede ir de 0 a 255. En los datos que env√≠a, activa un n√∫mero de luces correspondiente al √∫ltimo n√∫mero de la direcci√≥n de red.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-2FC1PT/yQn" href="#c-2FC1PT/yQn" tabindex="-1" role="presentation"></a><span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">addr</span> = <span class="tok-number">1</span>; addr &lt; <span class="tok-number">256</span>; addr++) {
  <span class="tok-keyword">let</span> <span class="tok-definition">data</span> = [];
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">n</span> = <span class="tok-number">0</span>; n &lt; <span class="tok-number">1500</span>; n++) {
    data.push(n &lt; addr ? <span class="tok-number">3</span> : <span class="tok-number">0</span>);
  }
  <span class="tok-keyword">let</span> <span class="tok-definition">ip</span> = <span class="tok-string2">`10.0.0.</span>${addr}<span class="tok-string2">`</span>;
  request(ip, {<span class="tok-definition">command</span>: <span class="tok-string">&quot;display&quot;</span>, <span class="tok-definition">data</span>})
    .then(() =&gt; console.log(<span class="tok-string2">`Solicitud a </span>${ip}<span class="tok-string2"> aceptada`</span>))
    .catch(() =&gt; {});
}</pre>

<p><a class="p_ident" id="p-nJVIxRRyu8" href="#p-nJVIxRRyu8" tabindex="-1" role="presentation"></a>Dado que la mayor√≠a de estas direcciones no existir√°n o no aceptar√°n tales mensajes, la llamada a <code>catch</code> se asegura de que los errores de red no hagan que el programa falle. Las solicitudes se env√≠an todas inmediatamente, sin esperar a que otras solicitudes terminen, para no perder tiempo cuando algunas de las m√°quinas no respondan.</p>

<p><a class="p_ident" id="p-XT02BFndLm" href="#p-XT02BFndLm" tabindex="-1" role="presentation"></a>Despu√©s de haber iniciado su exploraci√≥n de red, Carla regresa afuera para ver el resultado. Para su deleite, todas las pantallas ahora muestran una franja de luz en sus esquinas superiores izquierdas. Est√°n en la red local y s√≠ aceptan comandos. R√°pidamente toma nota de los n√∫meros mostrados en cada pantalla. Hay 9 pantallas, dispuestas tres en alto y tres en ancho. Tienen las siguientes direcciones de red:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-YxTIbNKE+b" href="#c-YxTIbNKE+b" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">screenAddresses</span> = [
  <span class="tok-string">&quot;10.0.0.44&quot;</span>, <span class="tok-string">&quot;10.0.0.45&quot;</span>, <span class="tok-string">&quot;10.0.0.41&quot;</span>,
  <span class="tok-string">&quot;10.0.0.31&quot;</span>, <span class="tok-string">&quot;10.0.0.40&quot;</span>, <span class="tok-string">&quot;10.0.0.42&quot;</span>,
  <span class="tok-string">&quot;10.0.0.48&quot;</span>, <span class="tok-string">&quot;10.0.0.47&quot;</span>, <span class="tok-string">&quot;10.0.0.46&quot;</span>
];</pre>

<p><a class="p_ident" id="p-t3lXdYG6kN" href="#p-t3lXdYG6kN" tabindex="-1" role="presentation"></a>Ahora esto abre posibilidades para todo tipo de travesuras. Podr√≠a mostrar ‚Äúlos cuervos mandan, los humanos babean‚Äù en la pared en letras gigantes. Pero eso se siente un poco grosero. En su lugar, planea mostrar un video de un cuervo volando que cubre todas las pantallas por la noche.</p>

<p><a class="p_ident" id="p-y5Q2eMHG15" href="#p-y5Q2eMHG15" tabindex="-1" role="presentation"></a>Carla encuentra un clip de video adecuado, en el cual un segundo y medio de metraje se puede repetir para crear un video en bucle mostrando el aleteo de un cuervo. Para ajustarse a las nueve pantallas (cada una de las cuales puede mostrar 50 por 30 p√≠xeles), Carla corta y redimensiona los videos para obtener una serie de im√°genes de 150 por 90, diez por segundo. Estas luego se cortan en nueve rect√°ngulos cada una, y se procesan para que los puntos oscuros en el video (donde est√° el cuervo) muestren una luz brillante, y los puntos claros (sin cuervo) permanezcan oscuros, lo que deber√≠a crear el efecto de un cuervo √°mbar volando contra un fondo negro.</p>

<p><a class="p_ident" id="p-y6uk8qBvhT" href="#p-y6uk8qBvhT" tabindex="-1" role="presentation"></a>Ella ha configurado la variable <code>clipImages</code> para contener un array de fotogramas, donde cada fotograma se representa con un array de nueve conjuntos de p√≠xeles, uno para cada pantalla, en el formato que los letreros esperan.</p>

<p><a class="p_ident" id="p-KvXTg6wDLF" href="#p-KvXTg6wDLF" tabindex="-1" role="presentation"></a>Para mostrar un √∫nico fotograma del video, Carla necesita enviar una solicitud a todas las pantallas a la vez. Pero tambi√©n necesita esperar el resultado de estas solicitudes, tanto para no comenzar a enviar el siguiente fotograma antes de que el actual se haya enviado correctamente, como para notar cuando las solicitudes est√°n fallando.</p>

<p><a class="p_ident" id="p-YW17AqPsQ1" href="#p-YW17AqPsQ1" tabindex="-1" role="presentation"></a><code>Promise</code> tiene un m√©todo est√°tico <code>all</code> que se puede usar para convertir un array de promesas en una sola promesa que se resuelve en un array de resultados. Esto proporciona una forma conveniente de que algunas acciones as√≠ncronas sucedan al lado unas de otras, esperar a que todas terminen y luego hacer algo con sus resultados (o al menos esperar a que terminen para asegurarse de que no fallen).</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-IQcpgoIvEH" href="#c-IQcpgoIvEH" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">displayFrame</span>(<span class="tok-definition">frame</span>) {
  <span class="tok-keyword">return</span> Promise.all(frame.map((<span class="tok-definition">data</span>, <span class="tok-definition">i</span>) =&gt; {
    <span class="tok-keyword">return</span> request(screenAddresses[i], {
      <span class="tok-definition">command</span>: <span class="tok-string">&quot;display&quot;</span>,
      <span class="tok-definition">data</span>
    });
  }));
}</pre>

<p><a class="p_ident" id="p-FPLMeF12gv" href="#p-FPLMeF12gv" tabindex="-1" role="presentation"></a>Esto recorre las im√°genes en <code>frame</code> (que es un array de arrays de datos de visualizaci√≥n) para crear un array de promesas de solicitud. Luego devuelve una promesa que combina todas esas promesas.</p>

<p><a class="p_ident" id="p-toeS8qCaQC" href="#p-toeS8qCaQC" tabindex="-1" role="presentation"></a>Para poder detener un video en reproducci√≥n, el proceso est√° envuelto en una clase. Esta clase tiene un m√©todo as√≠ncrono <code>play</code> que devuelve una promesa que solo se resuelve cuando la reproducci√≥n se detiene de nuevo a trav√©s del m√©todo <code>stop</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-9CWs6kw1Nf" href="#c-9CWs6kw1Nf" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">wait</span>(<span class="tok-definition">time</span>) {
  <span class="tok-keyword">return</span> <span class="tok-keyword">new</span> Promise(<span class="tok-definition">accept</span> =&gt; setTimeout(accept, time));
}

<span class="tok-keyword">class</span> VideoPlayer {
  <span class="tok-definition">constructor</span>(<span class="tok-definition">frames</span>, <span class="tok-definition">frameTime</span>) {
    <span class="tok-keyword">this</span>.frames = frames;
    <span class="tok-keyword">this</span>.frameTime = frameTime;
    <span class="tok-keyword">this</span>.stopped = true;
  }

  <span class="tok-keyword">async</span> <span class="tok-definition">play</span>() {
    <span class="tok-keyword">this</span>.stopped = false;
    <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">i</span> = <span class="tok-number">0</span>; !<span class="tok-keyword">this</span>.stopped; i++) {
      <span class="tok-keyword">let</span> <span class="tok-definition">nextFrame</span> = wait(<span class="tok-keyword">this</span>.frameTime);
      <span class="tok-keyword">await</span> displayFrame(<span class="tok-keyword">this</span>.frames[i % <span class="tok-keyword">this</span>.frames.length]);
      <span class="tok-keyword">await</span> nextFrame;
    }
  }

  <span class="tok-definition">stop</span>() {
    <span class="tok-keyword">this</span>.stopped = true;
  }
}</pre>

<p><a class="p_ident" id="p-wKK2/D6QRW" href="#p-wKK2/D6QRW" tabindex="-1" role="presentation"></a>La funci√≥n <code>wait</code> envuelve <code>setTimeout</code> en una promesa que se resuelve despu√©s del n√∫mero de milisegundos especificado. Esto es √∫til para controlar la velocidad de reproducci√≥n.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-WIv+1JofkY" href="#c-WIv+1JofkY" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">video</span> = <span class="tok-keyword">new</span> VideoPlayer(clipImages, <span class="tok-number">100</span>);
video.play().catch(<span class="tok-definition">e</span> =&gt; {
  console.log(<span class="tok-string">&quot;La reproducci√≥n fall√≥: &quot;</span> + e);
});
setTimeout(() =&gt; video.stop(), <span class="tok-number">15000</span>);</pre>

<p><a class="p_ident" id="p-Yx3D6CTz+N" href="#p-Yx3D6CTz+N" tabindex="-1" role="presentation"></a>Durante toda la semana que dura el muro de pantalla, todas las noches, cuando est√° oscuro, aparece misteriosamente un enorme p√°jaro naranja brillante en √©l.</p>

<h2><a class="h_ident" id="h-iSkjGslyNf" href="#h-iSkjGslyNf" tabindex="-1" role="presentation"></a>El bucle de eventos</h2>

<p><a class="p_ident" id="p-uqFuigR5hW" href="#p-uqFuigR5hW" tabindex="-1" role="presentation"></a>Un programa asincr√≥nico comienza ejecutando su script principal, que a menudo configurar√° devoluciones de llamada para ser llamadas m√°s tarde. Ese script principal, as√≠ como las devoluciones de llamada, se ejecutan por completo de una vez, sin interrupciones. Pero entre ellos, el programa puede estar inactivo, esperando a que ocurra algo.</p>

<p><a class="p_ident" id="p-RRuVVhfUCF" href="#p-RRuVVhfUCF" tabindex="-1" role="presentation"></a>Por lo tanto, las devoluciones de llamada no son llamadas directamente por el c√≥digo que las program√≥. Si llamo a <code>setTimeout</code> desde dentro de una funci√≥n, esa funci√≥n ya habr√° retornado en el momento en que se llame a la funci√≥n de devoluci√≥n de llamada. Y cuando la devoluci√≥n de llamada regresa, el control no vuelve a la funci√≥n que lo program√≥.</p>

<p><a class="p_ident" id="p-ekUlWC/PZ3" href="#p-ekUlWC/PZ3" tabindex="-1" role="presentation"></a>El comportamiento asincr√≥nico ocurre en su propia funci√≥n vac√≠a pila de llamadas. Esta es una de las razones por las que, sin promesas, gestionar excepciones en c√≥digo asincr√≥nico es tan dif√≠cil. Dado que cada devoluci√≥n de llamada comienza con una pila de llamadas en su mayor√≠a vac√≠a, sus manejadores de <code>catch</code> no estar√°n en la pila cuando lancen una excepci√≥n.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-RZ/XhGQYYZ" href="#c-RZ/XhGQYYZ" tabindex="-1" role="presentation"></a><span class="tok-keyword">try</span> {
  setTimeout(() =&gt; {
    <span class="tok-keyword">throw</span> <span class="tok-keyword">new</span> Error(<span class="tok-string">&quot;¬°Zoom!&quot;</span>);
  }, <span class="tok-number">20</span>);
} <span class="tok-keyword">catch</span> (<span class="tok-definition">e</span>) {
  <span class="tok-comment">// Esto no se ejecutar√°</span>
  console.log(<span class="tok-string">&quot;Atrapado&quot;</span>, e);
}</pre>

<p><a class="p_ident" id="p-joSObRYrFp" href="#p-joSObRYrFp" tabindex="-1" role="presentation"></a>No importa cu√°n cerca ocurran eventos, como tiempos de espera o solicitudes entrantes, un entorno JavaScript ejecutar√° solo un programa a la vez. Puedes pensar en esto como ejecutar un gran bucle <em>alrededor</em> de tu programa, llamado el <em>bucle de eventos</em>. Cuando no hay nada que hacer, ese bucle se pausa. Pero a medida que llegan eventos, se agregan a una cola y su c√≥digo se ejecuta uno tras otro. Debido a que no se ejecutan dos cosas al mismo tiempo, un c√≥digo lento puede retrasar el manejo de otros eventos.</p>

<p><a class="p_ident" id="p-5ZkjsY7Yeu" href="#p-5ZkjsY7Yeu" tabindex="-1" role="presentation"></a>Este ejemplo establece un tiempo de espera pero luego se demora hasta despu√©s del momento previsto para el tiempo de espera, provocando que el tiempo de espera sea tard√≠o.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Avc3WZx6ck" href="#c-Avc3WZx6ck" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">start</span> = Date.now();
setTimeout(() =&gt; {
  console.log(<span class="tok-string">&quot;El tiempo de espera se ejecut√≥ en&quot;</span>, Date.now() - start);
}, <span class="tok-number">20</span>);
<span class="tok-keyword">while</span> (Date.now() &lt; start + <span class="tok-number">50</span>) {}
console.log(<span class="tok-string">&quot;Tiempo perdido hasta&quot;</span>, Date.now() - start);
<span class="tok-comment">// ‚Üí Tiempo perdido hasta 50</span>
<span class="tok-comment">// ‚Üí El tiempo de espera se ejecut√≥ en 55</span></pre>

<p><a class="p_ident" id="p-rhhrRkqin4" href="#p-rhhrRkqin4" tabindex="-1" role="presentation"></a>Las promesas siempre se resuelven o se rechazan como un nuevo evento. Incluso si una promesa ya est√° resuelta, esperarla har√° que su devoluci√≥n de llamada se ejecute despu√©s de que termine el script actual, en lugar de inmediatamente.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-CpYlSjFfYU" href="#c-CpYlSjFfYU" tabindex="-1" role="presentation"></a>Promise.resolve(<span class="tok-string">&quot;Hecho&quot;</span>).then(console.log);
console.log(<span class="tok-string">&quot;¬°Yo primero!&quot;</span>);
<span class="tok-comment">// ‚Üí ¬°Yo primero!</span>
<span class="tok-comment">// ‚Üí Hecho</span></pre>

<p><a class="p_ident" id="p-qwnR1hGJw8" href="#p-qwnR1hGJw8" tabindex="-1" role="presentation"></a>En cap√≠tulos posteriores veremos varios tipos de eventos que se ejecutan en el bucle de eventos.</p>

<h2><a class="h_ident" id="h-5F87Tj7sc7" href="#h-5F87Tj7sc7" tabindex="-1" role="presentation"></a>Errores asincr√≥nicos</h2>

<p><a class="p_ident" id="p-DJqLCQdudP" href="#p-DJqLCQdudP" tabindex="-1" role="presentation"></a>Cuando tu programa se ejecuta de forma s√≠ncrona, de una sola vez, no hay cambios de estado ocurriendo excepto aquellos que el programa mismo realiza. Para programas as√≠ncronos esto es diferente, pueden tener <em>brechas</em> en su ejecuci√≥n durante las cuales otro c√≥digo puede correr.</p>

<p><a class="p_ident" id="p-1YB4rmos4T" href="#p-1YB4rmos4T" tabindex="-1" role="presentation"></a>Veamos un ejemplo. Esta es una funci√≥n que intenta reportar el tama√±o de cada archivo en un arreglo de archivos, asegur√°ndose de leerlos todos al mismo tiempo en lugar de en secuencia.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-SNIwqfk7T3" href="#c-SNIwqfk7T3" tabindex="-1" role="presentation"></a><span class="tok-keyword">async</span> <span class="tok-keyword">function</span> <span class="tok-definition">fileSizes</span>(<span class="tok-definition">files</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">lista</span> = <span class="tok-string">&quot;&quot;</span>;
  <span class="tok-keyword">await</span> Promise.all(files.map(<span class="tok-keyword">async</span> <span class="tok-definition">fileName</span> =&gt; {
    lista += fileName + <span class="tok-string">&quot;: &quot;</span> +
      (<span class="tok-keyword">await</span> textFile(fileName)).length + <span class="tok-string">&quot;</span><span class="tok-string2">\n</span><span class="tok-string">&quot;</span>;
  }));
  <span class="tok-keyword">return</span> lista;
}</pre>

<p><a class="p_ident" id="p-HiAwDFFOUL" href="#p-HiAwDFFOUL" tabindex="-1" role="presentation"></a>La parte <code>async fileName =&gt;</code> muestra c√≥mo tambi√©n se pueden hacer arrow functions <code>async</code> colocando la palabra <code>async</code> delante de ellas.</p>

<p><a class="p_ident" id="p-pPIiTEafT4" href="#p-pPIiTEafT4" tabindex="-1" role="presentation"></a>El c√≥digo no parece ser sospechoso de inmediato... mapea la funci√≥n flecha <code>async</code> sobre el arreglo de nombres, creando un arreglo de promesas, y luego usa <code>Promise.all</code> para esperar a todas ellas antes de devolver la lista que construyen.</p>

<p><a class="p_ident" id="p-exvEa8QEiP" href="#p-exvEa8QEiP" tabindex="-1" role="presentation"></a>Pero est√° totalmente roto. Siempre devolver√° solo una l√≠nea de salida, enumerando el archivo que tard√≥ m√°s en leer.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-KqsJmHqBh2" href="#c-KqsJmHqBh2" tabindex="-1" role="presentation"></a>fileSizes([<span class="tok-string">&quot;plans.txt&quot;</span>, <span class="tok-string">&quot;shopping_list.txt&quot;</span>])
  .then(console.log);</pre>

<p><a class="p_ident" id="p-s9Q+INoyNl" href="#p-s9Q+INoyNl" tabindex="-1" role="presentation"></a>¬øPuedes descubrir por qu√©?</p>

<p><a class="p_ident" id="p-GBG4on0Rh9" href="#p-GBG4on0Rh9" tabindex="-1" role="presentation"></a>El problema radica en el operador <code>+=</code>, que toma el valor <em>actual</em> de <code>lista</code> en el momento en que comienza a ejecutarse la instrucci√≥n y luego, cuando el <code>await</code> termina, establece el enlace <code>lista</code> como ese valor m√°s la cadena agregada.</p>

<p><a class="p_ident" id="p-gKQGh439Yc" href="#p-gKQGh439Yc" tabindex="-1" role="presentation"></a>Pero entre el momento en que comienza a ejecutarse la instrucci√≥n y el momento en que termina, hay una brecha asincr√≥nica. La expresi√≥n <code>map</code> se ejecuta antes de que se agregue cualquier cosa a la lista, por lo que cada uno de los operadores <code>+=</code> comienza desde una cadena vac√≠a y termina, cuando termina su recuperaci√≥n de almacenamiento, estableciendo <code>lista</code> en el resultado de agregar su l√≠nea a la cadena vac√≠a.</p>

<p><a class="p_ident" id="p-MBjCCi/2ci" href="#p-MBjCCi/2ci" tabindex="-1" role="presentation"></a>Esto podr√≠a haberse evitado f√°cilmente devolviendo las l√≠neas de las promesas mapeadas y llamando a <code>join</code> en el resultado de <code>Promise.all</code>, en lugar de construir la lista cambiando un enlace. Como suele ser, calcular nuevos valores es menos propenso a errores que cambiar valores existentes.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-9cdVzSKas5" href="#c-9cdVzSKas5" tabindex="-1" role="presentation"></a><span class="tok-keyword">async</span> <span class="tok-keyword">function</span> <span class="tok-definition">fileSizes</span>(<span class="tok-definition">files</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">l√≠neas</span> = files.map(<span class="tok-keyword">async</span> <span class="tok-definition">fileName</span> =&gt; {
    <span class="tok-keyword">return</span> fileName + <span class="tok-string">&quot;: &quot;</span> +
      (<span class="tok-keyword">await</span> textFile(fileName)).length;
  });
  <span class="tok-keyword">return</span> (<span class="tok-keyword">await</span> Promise.all(l√≠neas)).join(<span class="tok-string">&quot;</span><span class="tok-string2">\n</span><span class="tok-string">&quot;</span>);
}</pre>

<p><a class="p_ident" id="p-D5OZ7eAJk7" href="#p-D5OZ7eAJk7" tabindex="-1" role="presentation"></a>Errores como este son f√°ciles de cometer, especialmente al usar <code>await</code>, y debes ser consciente de d√≥nde ocurren las brechas en tu c√≥digo. Una ventaja de la asincron√≠a <em>expl√≠cita</em> de JavaScript (ya sea a trav√©s de devoluciones de llamada, promesas o <code>await</code>) es que identificar estas brechas es relativamente f√°cil.</p>

<h2><a class="h_ident" id="h-NUFOUyK+lw" href="#h-NUFOUyK+lw" tabindex="-1" role="presentation"></a>Resumen</h2>

<p><a class="p_ident" id="p-/tyI2XiFVY" href="#p-/tyI2XiFVY" tabindex="-1" role="presentation"></a>La programaci√≥n asincr√≥nica hace posible expresar la espera de acciones de larga duraci√≥n sin congelar todo el programa. Los entornos de JavaScript t√≠picamente implementan este estilo de programaci√≥n utilizando devoluciones de llamada, funciones que se llaman cuando las acciones se completan. Un bucle de eventos programa estas devoluciones de llamada para que se llamen cuando sea apropiado, una tras otra, de modo que su ejecuci√≥n no se superponga.La programaci√≥n de forma as√≠ncrona se facilita gracias a las promesas, que son objetos que representan acciones que podr√≠an completarse en el futuro, y las funciones <code>async</code>, que te permiten escribir un programa as√≠ncrono como si fuera sincr√≥nico.</p>

<h2><a class="h_ident" id="h-tkm7ntLto1" href="#h-tkm7ntLto1" tabindex="-1" role="presentation"></a>Ejercicios</h2>

<h3><a class="i_ident" id="i-+uVmJAkWrn" href="#i-+uVmJAkWrn" tabindex="-1" role="presentation"></a>Momentos de tranquilidad</h3>

<p><a class="p_ident" id="p-6ZL6bHpqZH" href="#p-6ZL6bHpqZH" tabindex="-1" role="presentation"></a>Hay una c√°mara de seguridad cerca del laboratorio de Carla que se activa con un sensor de movimiento. Est√° conectada a la red y comienza a enviar un flujo de video cuando est√° activa. Como prefiere no ser descubierta, Carla ha configurado un sistema que detecta este tipo de tr√°fico de red inal√°mbrico y enciende una luz en su guarida cada vez que hay actividad afuera, para que ella sepa cu√°ndo mantenerse en silencio.</p>

<p><a class="p_ident" id="p-0yy81tIz2h" href="#p-0yy81tIz2h" tabindex="-1" role="presentation"></a>Tambi√©n ha estado registrando los momentos en que la c√°mara se activa desde hace un tiempo, y quiere utilizar esta informaci√≥n para visualizar qu√© momentos, en una semana promedio, tienden a ser tranquilos y cu√°les tienden a ser ocupados. El registro se almacena en archivos que contienen un n√∫mero de marca de tiempo por l√≠nea (como devuelto por <code>Date.now()</code>).</p>

<pre class="snippet" data-language="null" ><a class="c_ident" id="c-oYpYSTh/9y" href="#c-oYpYSTh/9y" tabindex="-1" role="presentation"></a>1695709940692
1695701068331
1695701189163</pre>

<p><a class="p_ident" id="p-jjaZ48VGVD" href="#p-jjaZ48VGVD" tabindex="-1" role="presentation"></a>El archivo <code>&quot;camera_logs.<wbr>txt&quot;</code> contiene una lista de archivos de registro. Escribe una funci√≥n as√≠ncrona <code>activityTable(d√≠a)</code> que, para un d√≠a de la semana dado, devuelva un array de 24 n√∫meros, uno para cada hora del d√≠a, que contenga la cantidad de observaciones de tr√°fico de red de la c√°mara vista en esa hora del d√≠a. Los d√≠as se identifican por n√∫mero utilizando el sistema utilizado por <code>Date.getDay</code>, donde el domingo es 0 y el s√°bado es 6.</p>

<p><a class="p_ident" id="p-nq7jr1mWcA" href="#p-nq7jr1mWcA" tabindex="-1" role="presentation"></a>La funci√≥n <code>activityGraph</code>, proporcionada por el sandbox, resume dicha tabla en una cadena.</p>

<p><a class="p_ident" id="p-4EjrIsWVmx" href="#p-4EjrIsWVmx" tabindex="-1" role="presentation"></a>Utiliza la funci√≥n <code>textFile</code> definida anteriormente, que al recibir un nombre de archivo devuelve una promesa que se resuelve en el contenido del archivo. Recuerda que <code>new Date(marcaDeTiempo)</code> crea un objeto <code>Date</code> para ese momento, que tiene m√©todos <code>getDay</code> y <code>getHours</code> que devuelven el d√≠a de la semana y la hora del d√≠a.</p>

<p><a class="p_ident" id="p-oVU7j47Kad" href="#p-oVU7j47Kad" tabindex="-1" role="presentation"></a>Ambos tipos de archivos, la lista de archivos de registro y los propios archivos de registro, tienen cada dato en su propia l√≠nea, separados por caracteres de nueva l√≠nea (<code>&quot;\n&quot;</code>).</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-lwkjHlEwNf" href="#c-lwkjHlEwNf" tabindex="-1" role="presentation"></a><span class="tok-keyword">async</span> <span class="tok-keyword">function</span> <span class="tok-definition">activityTable</span>(<span class="tok-definition">day</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">logFileList</span> = <span class="tok-keyword">await</span> textFile(<span class="tok-string">&quot;camera_logs.txt&quot;</span>);
  <span class="tok-comment">// Tu c√≥digo aqu√≠</span>
}

activityTable(<span class="tok-number">1</span>)
  .then(<span class="tok-definition">table</span> =&gt; console.log(activityGraph(table)));</pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-jZ7OykMDrT" href="#p-jZ7OykMDrT" tabindex="-1" role="presentation"></a>Necesitar√°s convertir el contenido de estos archivos en un array. La forma m√°s f√°cil de hacerlo es utilizando el m√©todo <code>split</code> en la cadena producida por <code>textFile</code>. Ten en cuenta que para los archivos de registro, eso seguir√° d√°ndote un array de cadenas, que debes convertir a n√∫meros antes de pasarlos a <code>new Date</code>.</p>

<p><a class="p_ident" id="p-9fBqjU8ju+" href="#p-9fBqjU8ju+" tabindex="-1" role="presentation"></a>Resumir todos los puntos temporales en una tabla de horas se puede hacer creando una tabla (array) que contenga un n√∫mero para cada hora del d√≠a. Luego puedes recorrer todos los marca de tiempos (sobre los archivos de registro y los n√∫meros en cada archivo de registro) y, para cada uno, si sucedi√≥ en el d√≠a correcto, toma la hora en que ocurri√≥ y suma uno al n√∫mero correspondiente en la tabla.</p>

<p><a class="p_ident" id="p-iW4mBbLVDT" href="#p-iW4mBbLVDT" tabindex="-1" role="presentation"></a>Aseg√∫rate de usar <code>await</code> en el resultado de las funciones as√≠ncronas antes de hacer cualquier cosa con √©l, o terminar√°s con una <code>Promise</code> donde esperabas un string.</p>

<p><a class="p_ident" id="p-MYC7CGnZ1D" href="#p-MYC7CGnZ1D" tabindex="-1" role="presentation"></a>hinting}}</p>

<h3><a class="i_ident" id="i-rAhebsaSY2" href="#i-rAhebsaSY2" tabindex="-1" role="presentation"></a>Promesas Reales</h3>

<p><a class="p_ident" id="p-vfx72TWCka" href="#p-vfx72TWCka" tabindex="-1" role="presentation"></a>Reescribe la funci√≥n del ejercicio anterior sin <code>async</code>/<code>await</code>, utilizando m√©todos simples de <code>Promise</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-3oGelkObvZ" href="#c-3oGelkObvZ" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">activityTable</span>(<span class="tok-definition">d√≠a</span>) {
  <span class="tok-comment">// Tu c√≥digo aqu√≠</span>
}

activityTable(<span class="tok-number">6</span>)
  .then(<span class="tok-definition">tabla</span> =&gt; console.log(gr√°ficoActividad(tabla)));</pre>

<p><a class="p_ident" id="p-BGph0/UdzK" href="#p-BGph0/UdzK" tabindex="-1" role="presentation"></a>En este estilo, usar <code>Promise.all</code> ser√° m√°s conveniente que intentar modelar un bucle sobre los archivos de registro. En la funci√≥n <code>async</code>, simplemente usar <code>await</code> en un bucle es m√°s simple. Si leer un archivo toma un tiempo, ¬øcu√°l de estos dos enfoques tomar√° menos tiempo para ejecutarse?</p>

<p><a class="p_ident" id="p-EBStIx8OmH" href="#p-EBStIx8OmH" tabindex="-1" role="presentation"></a>Si uno de los archivos listados en la lista de archivos tiene un error tipogr√°fico, y falla al leerlo, ¬øc√≥mo termina ese fallo en el objeto <code>Promise</code> que retorna tu funci√≥n?</p>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-aw5MLt4jxJ" href="#p-aw5MLt4jxJ" tabindex="-1" role="presentation"></a>El enfoque m√°s directo para escribir esta funci√≥n es usar una cadena de llamadas <code>then</code>. La primera promesa se produce al leer la lista de archivos de registro. El primer callback puede dividir esta lista y mapear <code>textFile</code> sobre ella para obtener una matriz de promesas para pasar a <code>Promise.all</code>. Puede devolver el objeto devuelto por <code>Promise.all</code>, para que lo que sea que eso devuelva se convierta en el resultado del valor de retorno de este primer <code>then</code>.</p>

<p><a class="p_ident" id="p-XLfKUPx5h8" href="#p-XLfKUPx5h8" tabindex="-1" role="presentation"></a>Ahora tenemos una promesa que devuelve un array de archivos de registro. Podemos llamar a <code>then</code> nuevamente en eso, y poner la l√≥gica de conteo de marcas de tiempo all√≠. Algo as√≠:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Ri43SdEaNh" href="#c-Ri43SdEaNh" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">activityTable</span>(<span class="tok-definition">d√≠a</span>) {
  <span class="tok-keyword">return</span> textoArchivo(<span class="tok-string">&quot;registros_camara.txt&quot;</span>).then(<span class="tok-definition">archivos</span> =&gt; {
    <span class="tok-keyword">return</span> Promise.all(archivos.split(<span class="tok-string">&quot;</span><span class="tok-string2">\n</span><span class="tok-string">&quot;</span>).map(textoArchivo));
  }).then(<span class="tok-definition">logs</span> =&gt; {
    <span class="tok-comment">// analizar...</span>
  });
}</pre>

<p><a class="p_ident" id="p-nemG+o6551" href="#p-nemG+o6551" tabindex="-1" role="presentation"></a>O podr√≠as, para una programaci√≥n a√∫n mejor, poner el an√°lisis de cada archivo dentro de <code>Promise.all</code>, para que ese trabajo pueda comenzar para el primer archivo que regresa del disco, incluso antes de que los otros archivos regresen.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-c8ZiPZOaXj" href="#c-c8ZiPZOaXj" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">activityTable</span>(<span class="tok-definition">d√≠a</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">tabla</span> = []; <span class="tok-comment">// inicializar...</span>
  <span class="tok-keyword">return</span> textoArchivo(<span class="tok-string">&quot;registros_camara.txt&quot;</span>).then(<span class="tok-definition">archivos</span> =&gt; {
    <span class="tok-keyword">return</span> Promise.all(archivos.split(<span class="tok-string">&quot;</span><span class="tok-string2">\n</span><span class="tok-string">&quot;</span>).map(<span class="tok-definition">nombre</span> =&gt; {
      <span class="tok-keyword">return</span> textoArchivo(nombre).then(<span class="tok-definition">log</span> =&gt; {
        <span class="tok-comment">// analizar...</span>
      });
    }));
  }).then(() =&gt; tabla);
}</pre>

<p><a class="p_ident" id="p-ZHUmUZs29f" href="#p-ZHUmUZs29f" tabindex="-1" role="presentation"></a>Lo que muestra que la forma en que estructuras tus promesas puede tener un efecto real en la forma en que se programa el trabajo. Un simple bucle con <code>await</code> har√° que el proceso sea completamente lineal: espera a que se cargue cada archivo antes de continuar. <code>Promise.all</code> hace posible que varias tareas sean trabajadas conceptualmente al mismo tiempo, permiti√©ndoles progresar mientras los archivos a√∫n se est√°n cargando. Esto puede ser m√°s r√°pido, pero tambi√©n hace que el orden en que suceder√°n las cosas sea menos predecible. En este caso, donde solo vamos a estar incrementando n√∫meros en una tabla, eso no es dif√≠cil de hacer de manera segura. Para otros tipos de problemas, puede ser mucho m√°s dif√≠cil.</p>

<p><a class="p_ident" id="p-Ld+4EByL4v" href="#p-Ld+4EByL4v" tabindex="-1" role="presentation"></a>Cuando un archivo en la lista no existe, la promesa devuelta por <code>textFile</code> ser√° rechazada. Debido a que <code>Promise.all</code> se rechaza si alguna de las promesas que se le pasan falla, el valor de retorno de la devoluci√≥n de llamada dada al primer <code>then</code> tambi√©n ser√° una promesa rechazada. Esto hace que la promesa devuelta por <code>then</code> falle, por lo que la devoluci√≥n de llamada dada al segundo <code>then</code> ni siquiera se llama, y se devuelve una promesa rechazada desde la funci√≥n.</p>

</div></details>

<h3><a class="i_ident" id="i-pfc5Y5gAWn" href="#i-pfc5Y5gAWn" tabindex="-1" role="presentation"></a>Construyendo Promise.all</h3>

<p><a class="p_ident" id="p-M8QzvSw1av" href="#p-M8QzvSw1av" tabindex="-1" role="presentation"></a>Como vimos, dado un array de promesas, <code>Promise.all</code> devuelve una promesa que espera a que todas las promesas en el array finalicen. Luego tiene √©xito, devolviendo un array de valores de resultado. Si una promesa en el array falla, la promesa devuelta por <code>all</code> tambi√©n falla, con la raz√≥n de fallo de la promesa que fall√≥.</p>

<p><a class="p_ident" id="p-7xgUT0fq6f" href="#p-7xgUT0fq6f" tabindex="-1" role="presentation"></a>Implementa algo similar t√∫ mismo como una funci√≥n regular llamada <code>Promise_all</code>.</p>

<p><a class="p_ident" id="p-JLqRagv2ZP" href="#p-JLqRagv2ZP" tabindex="-1" role="presentation"></a>Recuerda que despu√©s de que una promesa tiene √©xito o falla, no puede volver a tener √©xito o fallar, y las llamadas posteriores a las funciones que la resuelven se ignoran. Esto puede simplificar la forma en que manejas el fallo de tu promesa.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-ksC0e2Z7aT" href="#c-ksC0e2Z7aT" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">Promise_all</span>(<span class="tok-definition">promesas</span>) {
  <span class="tok-keyword">return</span> <span class="tok-keyword">new</span> Promise((<span class="tok-definition">resolver</span>, <span class="tok-definition">rechazar</span>) =&gt; {
    <span class="tok-comment">// Tu c√≥digo aqu√≠.</span>
  });
}

<span class="tok-comment">// C√≥digo de prueba.</span>
Promise_all([]).then(<span class="tok-definition">array</span> =&gt; {
  console.log(<span class="tok-string">&quot;Esto deber√≠a ser []:&quot;</span>, array);
});
<span class="tok-keyword">function</span> <span class="tok-definition">pronto</span>(<span class="tok-definition">val</span>) {
  <span class="tok-keyword">return</span> <span class="tok-keyword">new</span> Promise(<span class="tok-definition">resolve</span> =&gt; {
    setTimeout(() =&gt; resolve(val), Math.random() * <span class="tok-number">500</span>);
  });
}
Promise_all([pronto(<span class="tok-number">1</span>), pronto(<span class="tok-number">2</span>), pronto(<span class="tok-number">3</span>)]).then(<span class="tok-definition">array</span> =&gt; {
  console.log(<span class="tok-string">&quot;Esto deber√≠a ser [1, 2, 3]:&quot;</span>, array);
});
Promise_all([pronto(<span class="tok-number">1</span>), Promise.reject(<span class="tok-string">&quot;X&quot;</span>), pronto(<span class="tok-number">3</span>)])
  .then(<span class="tok-definition">array</span> =&gt; {
    console.log(<span class="tok-string">&quot;No deber√≠amos llegar aqu√≠&quot;</span>);
  })
  .catch(<span class="tok-definition">error</span> =&gt; {
    <span class="tok-keyword">if</span> (error != <span class="tok-string">&quot;X&quot;</span>) {
      console.log(<span class="tok-string">&quot;Fallo inesperado:&quot;</span>, error);
    }
  });</pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-jsnP1W7uln" href="#p-jsnP1W7uln" tabindex="-1" role="presentation"></a>La funci√≥n pasada al constructor <code>Promise</code> tendr√° que llamar a <code>then</code> en cada una de las promesas en el array dado. Cuando una de ellas tiene √©xito, dos cosas deben suceder. El valor resultante debe ser almacenado en la posici√≥n correcta de un array de resultados, y debemos verificar si esta era la √∫ltima promesa pendiente y finalizar nuestra propia promesa si lo era.</p>

<p><a class="p_ident" id="p-pv4cygIqmH" href="#p-pv4cygIqmH" tabindex="-1" role="presentation"></a>Esto √∫ltimo se puede hacer con un contador que se inicializa con la longitud del array de entrada y del cual restamos 1 cada vez que una promesa tiene √©xito. Cuando llegue a 0, hemos terminado. Aseg√∫rate de tener en cuenta la situaci√≥n en la que el array de entrada est√° vac√≠o (y por lo tanto ninguna promesa se resolver√° nunca).</p>

<p><a class="p_ident" id="p-RfvboDBLxx" href="#p-RfvboDBLxx" tabindex="-1" role="presentation"></a>Manejar el fallo requiere un poco de pensamiento pero resulta ser extremadamente simple. Simplemente pasa la funci√≥n <code>reject</code> de la promesa contenedora a cada una de las promesas en el array como un controlador <code>catch</code> o como un segundo argumento para <code>then</code> para que un fallo en una de ellas desencadene el rechazo de toda la promesa contenedora.</p>

<p><a class="p_ident" id="p-nfQ6A5rdkZ" href="#p-nfQ6A5rdkZ" tabindex="-1" role="presentation"></a>pista</p>

</div></details>

</div></details><nav><a href="10_modules.html" title="previous chapter" aria-label="previous chapter">‚óÇ</a>¬†<a href="index.html" title="cover" aria-label="cover">‚óè</a>¬†<a href="12_language.html" title="next chapter" aria-label="next chapter">‚ñ∏</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>&nbsp;<button class="dark-mode-toggle">üåô</button>
</nav>
</article>

<script src="ejs.js"></script>
