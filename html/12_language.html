<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Proyecto: Un Lenguaje de Programaci√≥n :: Eloquent JavaScript</title>
  <link rel=stylesheet href="css/ejs.css"><script>
      var page = {"type":"chapter","number":12,"load_files":["code/chapter/12_language.js"]}</script></head>

<article>
<nav><a href="11_async.html" title="previous chapter" aria-label="previous chapter">‚óÇ</a>¬†<a href="index.html" title="cover" aria-label="cover">‚óè</a>¬†<a href="13_browser.html" title="next chapter" aria-label="next chapter">‚ñ∏</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>&nbsp;<button class="dark-mode-toggle">üåô</button>
</nav>

<h1>Proyecto: Un Lenguaje de Programaci√≥n</h1>

<blockquote>

<p><a class="p_ident" id="p-NCKe5tEBSN" href="#p-NCKe5tEBSN" tabindex="-1" role="presentation"></a>El evaluador, que determina el significado de expresiones en un lenguaje de programaci√≥n, es solo otro programa.</p>

<footer>Hal Abelson y Gerald Sussman, <cite>Estructura e Interpretaci√≥n de Programas de Computadora</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_12.jpg" alt="Ilustraci√≥n que muestra un huevo con agujeros, mostrando huevos m√°s peque√±os dentro, que a su vez tienen huevos a√∫n m√°s peque√±os dentro de ellos, y as√≠ sucesivamente"></figure>

<p><a class="p_ident" id="p-xcNW3HLt2k" href="#p-xcNW3HLt2k" tabindex="-1" role="presentation"></a>Crear tu propio lenguaje de programaci√≥n es sorprendentemente f√°cil (si no apuntas muy alto) y muy esclarecedor.</p>

<p><a class="p_ident" id="p-mZbmmA9jPL" href="#p-mZbmmA9jPL" tabindex="-1" role="presentation"></a>Lo principal que quiero mostrar en este cap√≠tulo es que no hay magia involucrada en la construcci√≥n de un lenguaje de programaci√≥n. A menudo he sentido que algunas invenciones humanas eran tan inmensamente inteligentes y complicadas que nunca las entender√≠a. Pero con un poco de lectura y experimentaci√≥n, a menudo resultan ser bastante mundanas.</p>

<p><a class="p_ident" id="p-AY1eTWKK2r" href="#p-AY1eTWKK2r" tabindex="-1" role="presentation"></a>Construiremos un lenguaje de programaci√≥n llamado Egg. Ser√° un lenguaje simple y diminuto, pero lo suficientemente poderoso como para expresar cualquier c√°lculo que puedas imaginar. Permitir√° una simple abstracci√≥n basada en funciones.</p>

<h2 id="parsing"><a class="h_ident" id="h-Ri8DEsFixT" href="#h-Ri8DEsFixT" tabindex="-1" role="presentation"></a>An√°lisis Sint√°ctico</h2>

<p><a class="p_ident" id="p-LWCHgQ8jiK" href="#p-LWCHgQ8jiK" tabindex="-1" role="presentation"></a>La parte m√°s inmediatamente visible de un lenguaje de programaci√≥n es su <em>sintaxis</em>, o notaci√≥n. Un <em>analizador sint√°ctico</em> es un programa que lee un fragmento de texto y produce una estructura de datos que refleja la estructura del programa contenido en ese texto. Si el texto no forma un programa v√°lido, el analizador sint√°ctico deber√≠a se√±alar el error.</p>

<p><a class="p_ident" id="p-ZtGU+dhqC7" href="#p-ZtGU+dhqC7" tabindex="-1" role="presentation"></a>Nuestro lenguaje tendr√° una sintaxis simple y uniforme. Todo en Egg es una expresi√≥n. Una expresi√≥n puede ser el nombre de una asignaci√≥n, un n√∫mero, una cadena o una <em>aplicaci√≥n</em>. Las aplicaciones se utilizan para llamadas de funciones pero tambi√©n para estructuras como <code>if</code> o <code>while</code>.</p>

<p><a class="p_ident" id="p-ep+0glVGES" href="#p-ep+0glVGES" tabindex="-1" role="presentation"></a>Para mantener el analizador sint√°ctico simple, las cadenas en Egg no admiten nada parecido a los escapes con barra invertida. Una cadena es simplemente una secuencia de caracteres que no son comillas dobles, envueltos entre comillas dobles. Un n√∫mero es una secuencia de d√≠gitos. Los nombres de las asignaciones pueden consistir en cualquier car√°cter que no sea espacio en blanco y que no tenga un significado especial en la sintaxis.</p>

<p><a class="p_ident" id="p-vwvgo3jFhV" href="#p-vwvgo3jFhV" tabindex="-1" role="presentation"></a>Las aplicaciones se escriben de la misma manera que en JavaScript, colocando par√©ntesis despu√©s de una expresi√≥n y teniendo cualquier n√∫mero de argumentos entre esos par√©ntesis, separados por comas.</p>

<pre class="snippet" data-language="null" ><a class="c_ident" id="c-mxbdQPKeHJ" href="#c-mxbdQPKeHJ" tabindex="-1" role="presentation"></a>do(define(x, 10),
   if(&gt;(x, 5),
      print(&quot;grande&quot;),
      print(&quot;peque√±o&quot;)))</pre>

<p><a class="p_ident" id="p-C/tUY61w0R" href="#p-C/tUY61w0R" tabindex="-1" role="presentation"></a>La uniformidad del lenguaje Egg significa que las cosas que son operadores en JavaScript (como <code>&gt;</code>) son asignaciones normales en este lenguaje, aplicadas de la misma manera que otras funciones. Y dado que la sintaxis no tiene concepto de bloque, necesitamos un constructo <code>do</code> para representar la realizaci√≥n de m√∫ltiples tareas en secuencia.</p>

<p><a class="p_ident" id="p-U5mB4GWXLX" href="#p-U5mB4GWXLX" tabindex="-1" role="presentation"></a>La estructura de datos que el analizador sint√°ctico utilizar√° para describir un programa consiste en objetos expresi√≥n, cada uno de los cuales tiene una propiedad <code>type</code> que indica el tipo de expresi√≥n que es y otras propiedades para describir su contenido.</p>

<p><a class="p_ident" id="p-dTPyueuVSb" href="#p-dTPyueuVSb" tabindex="-1" role="presentation"></a>Las expresiones de tipo <code>&quot;value&quot;</code> representan cadenas literales o n√∫meros. Su propiedad <code>value</code> contiene el valor de cadena o n√∫mero que representan. Las expresiones de tipo <code>&quot;word&quot;</code> se utilizan para identificadores (nombres). Estos objetos tienen una propiedad <code>name</code> que contiene el nombre del identificador como cadena. Finalmente, las expresiones <code>&quot;apply&quot;</code> representan aplicaciones. Tienen una propiedad <code>operator</code> que se refiere a la expresi√≥n que se est√° aplicando, as√≠ como una propiedad <code>args</code> que contiene una serie de expresiones de argumento.</p>

<p><a class="p_ident" id="p-RNNQ9+j+mM" href="#p-RNNQ9+j+mM" tabindex="-1" role="presentation"></a>La parte <code>&gt;(x, 5)</code> del programa anterior se representar√≠a de la siguiente manera:</p>

<pre class="snippet" data-language="json" ><a class="c_ident" id="c-YRUVy1WdLZ" href="#c-YRUVy1WdLZ" tabindex="-1" role="presentation"></a>{
  <span class="tok-definition">type</span>: <span class="tok-string">&quot;apply&quot;</span>,
  <span class="tok-definition">operator</span>: {<span class="tok-definition">type</span>: <span class="tok-string">&quot;word&quot;</span>, <span class="tok-definition">name</span>: <span class="tok-string">&quot;&gt;&quot;</span>},
  <span class="tok-definition">args</span>: [
    {<span class="tok-definition">type</span>: <span class="tok-string">&quot;word&quot;</span>, <span class="tok-definition">name</span>: <span class="tok-string">&quot;x&quot;</span>},
    {<span class="tok-definition">type</span>: <span class="tok-string">&quot;value&quot;</span>, <span class="tok-definition">value</span>: <span class="tok-number">5</span>}
  ]
}</pre>

<p><a class="p_ident" id="p-xa+b6R6Gzl" href="#p-xa+b6R6Gzl" tabindex="-1" role="presentation"></a>Esta estructura de datos se llama un <em>√°rbol de sintaxis</em>. Si te imaginas los objetos como puntos y los enlaces entre ellos como l√≠neas entre esos puntos, tiene una forma similar a un √°rbol. El hecho de que las expresiones contienen otras expresiones, que a su vez pueden contener m√°s expresiones, es similar a la forma en que las ramas de un √°rbol se dividen y vuelven a dividir.</p><figure><img src="img/syntax_tree.svg" alt="Un diagrama que muestra la estructura del √°rbol de sintaxis del programa de ejemplo. La ra√≠z est√° etiquetada como 'do' y tiene dos hijos, uno etiquetado como 'define' y otro como 'if'. A su vez, estos tienen m√°s hijos que describen su contenido."></figure>

<p><a class="p_ident" id="p-oWghglriRc" href="#p-oWghglriRc" tabindex="-1" role="presentation"></a>Contrasta esto con el analizador que escribimos para el formato de archivo de configuraci√≥n en el <a href="09_regexp.html#ini">Cap√≠tulo 9</a>, que ten√≠a una estructura simple: divid√≠a la entrada en l√≠neas y manejaba esas l√≠neas una a la vez. Solo hab√≠a algunas formas simples que una l√≠nea pod√≠a tener.</p>

<p><a class="p_ident" id="p-6Mz6uGItWm" href="#p-6Mz6uGItWm" tabindex="-1" role="presentation"></a>Aqu√≠ debemos encontrar un enfoque diferente. Las expresiones no est√°n separadas en l√≠neas, y tienen una estructura recursiva. Las expresiones de aplicaci√≥n <em>contienen</em> otras expresiones.</p>

<p><a class="p_ident" id="p-cXp43eu5PY" href="#p-cXp43eu5PY" tabindex="-1" role="presentation"></a>Afortunadamente, este problema puede resolverse muy bien escribiendo una funci√≥n de an√°lisis sint√°ctico que sea recursiva de una manera que refleje la naturaleza recursiva del lenguaje.</p>

<p><a class="p_ident" id="p-+kbXV3aRjp" href="#p-+kbXV3aRjp" tabindex="-1" role="presentation"></a>Definimos una funci√≥n <code>parseExpression</code>, que recibe una cadena como entrada y devuelve un objeto que contiene la estructura de datos de la expresi√≥n al inicio de la cadena, junto con la parte de la cadena que queda despu√©s de analizar esta expresi√≥n. Al analizar subexpresiones (el argumento de una aplicaci√≥n, por ejemplo), esta funci√≥n puede ser llamada nuevamente, obteniendo la expresi√≥n de argumento as√≠ como el texto que queda. Este texto a su vez puede contener m√°s argumentos o puede ser el par√©ntesis de cierre que finaliza la lista de argumentos.Esta es la primera parte del analizador sint√°ctico:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Kq2My8rR4Z" href="#c-Kq2My8rR4Z" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">parseExpression</span>(<span class="tok-definition">program</span>) {
  program = skipSpace(program);
  <span class="tok-keyword">let</span> <span class="tok-definition">match</span>, <span class="tok-definition">expr</span>;
  <span class="tok-keyword">if</span> (match = <span class="tok-string2">/^&quot;([^&quot;]*)&quot;/</span>.exec(program)) {
    expr = {<span class="tok-definition">type</span>: <span class="tok-string">&quot;value&quot;</span>, <span class="tok-definition">value</span>: match[<span class="tok-number">1</span>]};
  } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (match = <span class="tok-string2">/^\d+\b/</span>.exec(program)) {
    expr = {<span class="tok-definition">type</span>: <span class="tok-string">&quot;value&quot;</span>, <span class="tok-definition">value</span>: Number(match[<span class="tok-number">0</span>])};
  } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (match = <span class="tok-string2">/^[^\s(),#&quot;]+/</span>.exec(program)) {
    expr = {<span class="tok-definition">type</span>: <span class="tok-string">&quot;word&quot;</span>, <span class="tok-definition">name</span>: match[<span class="tok-number">0</span>]};
  } <span class="tok-keyword">else</span> {
    <span class="tok-keyword">throw</span> <span class="tok-keyword">new</span> SyntaxError(<span class="tok-string">&quot;Sintaxis inesperada: &quot;</span> + program);
  }

  <span class="tok-keyword">return</span> parseApply(expr, program.slice(match[<span class="tok-number">0</span>].length));
}

<span class="tok-keyword">function</span> <span class="tok-definition">skipSpace</span>(<span class="tok-definition">string</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">first</span> = string.search(<span class="tok-string2">/\S/</span>);
  <span class="tok-keyword">if</span> (first == -<span class="tok-number">1</span>) <span class="tok-keyword">return</span> <span class="tok-string">&quot;&quot;</span>;
  <span class="tok-keyword">return</span> string.slice(first);
}</pre>

<p><a class="p_ident" id="p-69spf6/XVL" href="#p-69spf6/XVL" tabindex="-1" role="presentation"></a>Debido a que Egg, al igual que JavaScript, permite cualquier cantidad de espacios en blanco entre sus elementos, debemos cortar repetidamente el espacio en blanco del inicio de la cadena del programa. Eso es para lo que sirve la funci√≥n <code>skipSpace</code>.</p>

<p><a class="p_ident" id="p-G2iiBlqqe/" href="#p-G2iiBlqqe/" tabindex="-1" role="presentation"></a>Despu√©s de omitir cualquier espacio inicial, <code>parseExpression</code> utiliza tres expresiones regulares para detectar los tres elementos at√≥micos que admite Egg: cadenas, n√∫meros y palabras. El analizador construye un tipo diferente de estructura de datos dependiendo de cu√°l de ellos coincida. Si la entrada no coincide con ninguna de estas tres formas, no es una expresi√≥n v√°lida y el analizador genera un error. Utilizamos el constructor <code>SyntaxError</code> aqu√≠. Esta es una clase de excepci√≥n definida por el est√°ndar, al igual que <code>Error</code>, pero m√°s espec√≠fica.</p>

<p><a class="p_ident" id="p-EgqyXKPX43" href="#p-EgqyXKPX43" tabindex="-1" role="presentation"></a>Luego cortamos la parte que coincidi√≥ de la cadena del programa y la pasamos, junto con el objeto de la expresi√≥n, a <code>parseApply</code>, que verifica si la expresi√≥n es una aplicaci√≥n. Si lo es, analiza una lista de argumentos entre par√©ntesis.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-NbmLO+XtaQ" href="#c-NbmLO+XtaQ" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">parseApply</span>(<span class="tok-definition">expr</span>, <span class="tok-definition">program</span>) {
  program = skipSpace(program);
  <span class="tok-keyword">if</span> (program[<span class="tok-number">0</span>] != <span class="tok-string">&quot;(&quot;</span>) {
    <span class="tok-keyword">return</span> {<span class="tok-definition">expr</span>: expr, <span class="tok-definition">rest</span>: program};
  }

  program = skipSpace(program.slice(<span class="tok-number">1</span>));
  expr = {<span class="tok-definition">type</span>: <span class="tok-string">&quot;apply&quot;</span>, <span class="tok-definition">operator</span>: expr, <span class="tok-definition">args</span>: []};
  <span class="tok-keyword">while</span> (program[<span class="tok-number">0</span>] != <span class="tok-string">&quot;)&quot;</span>) {
    <span class="tok-keyword">let</span> <span class="tok-definition">arg</span> = parseExpression(program);
    expr.args.push(arg.expr);
    program = skipSpace(arg.rest);
    <span class="tok-keyword">if</span> (program[<span class="tok-number">0</span>] == <span class="tok-string">&quot;,&quot;</span>) {
      program = skipSpace(program.slice(<span class="tok-number">1</span>));
    } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (program[<span class="tok-number">0</span>] != <span class="tok-string">&quot;)&quot;</span>) {
      <span class="tok-keyword">throw</span> <span class="tok-keyword">new</span> SyntaxError(<span class="tok-string">&quot;Se esperaba ',' o ')'&quot;</span>);
    }
  }
  <span class="tok-keyword">return</span> parseApply(expr, program.slice(<span class="tok-number">1</span>));
}</pre>

<p><a class="p_ident" id="p-P+rEG3RwON" href="#p-P+rEG3RwON" tabindex="-1" role="presentation"></a>Si el pr√≥ximo car√°cter en el programa no es un par√©ntesis de apertura, esto no es una aplicaci√≥n y <code>parseApply</code> devuelve la expresi√≥n que se le dio.</p>

<p><a class="p_ident" id="p-gyKfAj64fa" href="#p-gyKfAj64fa" tabindex="-1" role="presentation"></a>De lo contrario, se salta el par√©ntesis de apertura y crea el objeto √°rbol sint√°ctico para esta expresi√≥n de aplicaci√≥n. Luego llama recursivamente a <code>parseExpression</code> para analizar cada argumento hasta encontrar un par√©ntesis de cierre. La recursi√≥n es indirecta, a trav√©s de <code>parseApply</code> y <code>parseExpression</code> llam√°ndose mutuamente.</p>

<p><a class="p_ident" id="p-lwTBl+PY0V" href="#p-lwTBl+PY0V" tabindex="-1" role="presentation"></a>Dado que una expresi√≥n de aplicaci√≥n puede a su vez ser aplicada (como en <code>multiplicador(2)(1)</code>), <code>parseApply</code> debe, despu√©s de analizar una aplicaci√≥n, llamarse a s√≠ misma nuevamente para verificar si sigue otro par de par√©ntesis.</p>

<p><a class="p_ident" id="p-89g4z+3rO6" href="#p-89g4z+3rO6" tabindex="-1" role="presentation"></a>Esto es todo lo que necesitamos para analizar Egg. Lo envolvemos en una conveniente <code>parse</code> funci√≥n que verifica que ha llegado al final de la cadena de entrada despu√©s de analizar la expresi√≥n (un programa Egg es una sola expresi√≥n), y que nos da la estructura de datos del programa.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-PRcHuKWwJ9" href="#c-PRcHuKWwJ9" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">parse</span>(<span class="tok-definition">program</span>) {
  <span class="tok-keyword">let</span> {expr, rest} = parseExpression(program);
  <span class="tok-keyword">if</span> (skipSpace(rest).length &gt; <span class="tok-number">0</span>) {
    <span class="tok-keyword">throw</span> <span class="tok-keyword">new</span> SyntaxError(<span class="tok-string">&quot;Texto inesperado despu√©s del programa&quot;</span>);
  }
  <span class="tok-keyword">return</span> expr;
}

console.log(parse(<span class="tok-string">&quot;+(a, 10)&quot;</span>));
<span class="tok-comment">// ‚Üí {type: &quot;apply&quot;,</span>
<span class="tok-comment">//    operator: {type: &quot;word&quot;, name: &quot;+&quot;},</span>
<span class="tok-comment">//    args: [{type: &quot;word&quot;, name: &quot;a&quot;},</span>
<span class="tok-comment">//           {type: &quot;value&quot;, value: 10}]}</span></pre>

<p><a class="p_ident" id="p-l7ELJeshJs" href="#p-l7ELJeshJs" tabindex="-1" role="presentation"></a>¬°Funciona! No nos da informaci√≥n muy √∫til cuando falla y no almacena la l√≠nea y la columna en las que comienza cada expresi√≥n, lo cual podr√≠a ser √∫til al informar errores m√°s tarde, pero es suficiente para nuestros prop√≥sitos.</p>

<h2><a class="h_ident" id="h-lI3Fc6r+GN" href="#h-lI3Fc6r+GN" tabindex="-1" role="presentation"></a>El evaluador</h2>

<p><a class="p_ident" id="p-dhdWhScWHm" href="#p-dhdWhScWHm" tabindex="-1" role="presentation"></a>¬øQu√© podemos hacer con el √°rbol de sintaxis de un programa? ¬°Ejecutarlo, por supuesto! Y eso es lo que hace el evaluador. Le das un √°rbol de sintaxis y un objeto de √°mbito que asocia nombres con valores, y evaluar√° la expresi√≥n que representa el √°rbol y devolver√° el valor que esto produce.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-w34EbEGm2M" href="#c-w34EbEGm2M" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">specialForms</span> = Object.create(<span class="tok-keyword">null</span>);

<span class="tok-keyword">function</span> <span class="tok-definition">evaluate</span>(<span class="tok-definition">expr</span>, <span class="tok-definition">scope</span>) {
  <span class="tok-keyword">if</span> (expr.type == <span class="tok-string">&quot;value&quot;</span>) {
    <span class="tok-keyword">return</span> expr.value;
  } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (expr.type == <span class="tok-string">&quot;word&quot;</span>) {
    <span class="tok-keyword">if</span> (expr.name <span class="tok-keyword">in</span> scope) {
      <span class="tok-keyword">return</span> scope[expr.name];
    } <span class="tok-keyword">else</span> {
      <span class="tok-keyword">throw</span> <span class="tok-keyword">new</span> ReferenceError(
        <span class="tok-string2">`Vinculaci√≥n indefinida: </span>${expr.name}<span class="tok-string2">`</span>);
    }
  } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (expr.type == <span class="tok-string">&quot;apply&quot;</span>) {
    <span class="tok-keyword">let</span> {operator, args} = expr;
    <span class="tok-keyword">if</span> (operator.type == <span class="tok-string">&quot;word&quot;</span> &amp;&amp;
        operator.name <span class="tok-keyword">in</span> specialForms) {
      <span class="tok-keyword">return</span> specialForms[operator.name](expr.args, scope);
    } <span class="tok-keyword">else</span> {
      <span class="tok-keyword">let</span> <span class="tok-definition">op</span> = evaluate(operator, scope);
      <span class="tok-keyword">if</span> (<span class="tok-keyword">typeof</span> op == <span class="tok-string">&quot;function&quot;</span>) {
        <span class="tok-keyword">return</span> op(...args.map(<span class="tok-definition">arg</span> =&gt; evaluate(arg, scope)));
      } <span class="tok-keyword">else</span> {
        <span class="tok-keyword">throw</span> <span class="tok-keyword">new</span> TypeError(<span class="tok-string">&quot;Aplicando una no-funci√≥n.&quot;</span>);
      }
    }
  }
}</pre>

<p><a class="p_ident" id="p-HWNpAazEel" href="#p-HWNpAazEel" tabindex="-1" role="presentation"></a>El evaluador tiene c√≥digo para cada uno de los tipos de expresi√≥n. Una expresi√≥n de valor literal produce su valor. (Por ejemplo, la expresi√≥n <code>100</code> simplemente se eval√∫a como el n√∫mero 100.) Para un enlace, debemos verificar si est√° realmente definido en el √°mbito y, si lo est√°, obtener el valor del enlace.</p>

<p><a class="p_ident" id="p-NYz/C0Evfv" href="#p-NYz/C0Evfv" tabindex="-1" role="presentation"></a>Las aplicaciones son m√°s complicadas. Si son una forma especial, como <code>if</code>, no evaluamos nada y pasamos las expresiones de argumento, junto con el √°mbito, a la funci√≥n que maneja esta forma. Si es una llamada normal, evaluamos el operador, verificamos que sea una funci√≥n, y la llamamos con los argumentos evaluados.</p>

<p><a class="p_ident" id="p-/VWFz5tzb5" href="#p-/VWFz5tzb5" tabindex="-1" role="presentation"></a>Usamos valores de funci√≥n JavaScript simples para representar los valores de funci√≥n de Egg. Volveremos a esto <a href="12_language.html#egg_fun">m√°s tarde</a>, cuando se defina la forma especial llamada <code>fun</code>.</p>

<p><a class="p_ident" id="p-yBQx2/sKQH" href="#p-yBQx2/sKQH" tabindex="-1" role="presentation"></a>La estructura recursiva de <code>evaluate</code> se asemeja a la estructura similar del analizador sint√°ctico, y ambos reflejan la estructura del lenguaje en s√≠. Tambi√©n ser√≠a posible combinar el analizador sint√°ctico y el evaluador en una sola funci√≥n, y evaluar durante el an√°lisis sint√°ctico. Pero dividirlos de esta manera hace que el programa sea m√°s claro y flexible.</p>

<p><a class="p_ident" id="p-YL/SkpZx0H" href="#p-YL/SkpZx0H" tabindex="-1" role="presentation"></a>Esto es realmente todo lo que se necesita para interpretar Egg. Es as√≠ de simple. Pero sin definir algunas formas especiales y agregar algunos valores √∫tiles al entorno, todav√≠a no puedes hacer mucho con este lenguaje.</p>

<h2><a class="h_ident" id="h-okJU2Tz5zr" href="#h-okJU2Tz5zr" tabindex="-1" role="presentation"></a>Formas especiales</h2>

<p><a class="p_ident" id="p-4AQECo8zLD" href="#p-4AQECo8zLD" tabindex="-1" role="presentation"></a>El objeto <code>specialForms</code> se utiliza para definir sintaxis especial en Egg. Asocia palabras con funciones que eval√∫an dichas formas. Actualmente est√° vac√≠o. A√±adamos <code>if</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-zMj1xnykR3" href="#c-zMj1xnykR3" tabindex="-1" role="presentation"></a>specialForms.if = (<span class="tok-definition">args</span>, <span class="tok-definition">scope</span>) =&gt; {
  <span class="tok-keyword">if</span> (args.length != <span class="tok-number">3</span>) {
    <span class="tok-keyword">throw</span> <span class="tok-keyword">new</span> SyntaxError(<span class="tok-string">&quot;N√∫mero incorrecto de argumentos para if&quot;</span>);
  } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (evaluate(args[<span class="tok-number">0</span>], scope) !== false) {
    <span class="tok-keyword">return</span> evaluate(args[<span class="tok-number">1</span>], scope);
  } <span class="tok-keyword">else</span> {
    <span class="tok-keyword">return</span> evaluate(args[<span class="tok-number">2</span>], scope);
  }
};</pre>

<p><a class="p_ident" id="p-WeZ6L3damh" href="#p-WeZ6L3damh" tabindex="-1" role="presentation"></a>La construcci√≥n <code>if</code> de Egg espera exactamente tres argumentos. Evaluar√° el primero, y si el resultado no es el valor <code>false</code>, evaluar√° el segundo. De lo contrario, se evaluar√° el tercero. Esta forma <code>if</code> se asemeja m√°s al operador ternario <code>?:</code> de JavaScript que al <code>if</code> de JavaScript. Es una expresi√≥n, no una declaraci√≥n, y produce un valor, concretamente, el resultado del segundo o tercer argumento.</p>

<p><a class="p_ident" id="p-zLB8PMONce" href="#p-zLB8PMONce" tabindex="-1" role="presentation"></a>Egg tambi√©n difiere de JavaScript en c√≥mo maneja el valor de condici√≥n para <code>if</code>. No tratar√° cosas como cero o la cadena vac√≠a como falso, solo el valor preciso <code>false</code>.</p>

<p><a class="p_ident" id="p-q4X/kmv6pB" href="#p-q4X/kmv6pB" tabindex="-1" role="presentation"></a>La raz√≥n por la que necesitamos representar <code>if</code> como una forma especial, en lugar de una funci√≥n regular, es que todos los argumentos de las funciones se eval√∫an antes de llamar a la funci√≥n, mientras que <code>if</code> debe evaluar solo <em>uno</em> de sus segundos o terceros argumentos, dependiendo del valor del primero.</p>

<p><a class="p_ident" id="p-ThCmPNDU78" href="#p-ThCmPNDU78" tabindex="-1" role="presentation"></a>La forma <code>while</code> es similar.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-icmi3itpHq" href="#c-icmi3itpHq" tabindex="-1" role="presentation"></a>specialForms.while = (<span class="tok-definition">args</span>, <span class="tok-definition">scope</span>) =&gt; {
  <span class="tok-keyword">if</span> (args.length != <span class="tok-number">2</span>) {
    <span class="tok-keyword">throw</span> <span class="tok-keyword">new</span> SyntaxError(<span class="tok-string">&quot;N√∫mero incorrecto de argumentos para while&quot;</span>);
  }
  <span class="tok-keyword">while</span> (evaluate(args[<span class="tok-number">0</span>], scope) !== false) {
    evaluate(args[<span class="tok-number">1</span>], scope);
  }

  <span class="tok-comment">// Dado que undefined no existe en Egg, devolvemos false,</span>
  <span class="tok-comment">// por falta de un resultado significativo.</span>
  <span class="tok-keyword">return</span> false;
};</pre>

<p><a class="p_ident" id="p-Z/4xap75Q7" href="#p-Z/4xap75Q7" tabindex="-1" role="presentation"></a>Otro bloque b√°sico es <code>do</code>, que ejecuta todos sus argumentos de arriba abajo. Su valor es el valor producido por el √∫ltimo argumento.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-PsbGnrOVLi" href="#c-PsbGnrOVLi" tabindex="-1" role="presentation"></a>specialForms.do = (<span class="tok-definition">args</span>, <span class="tok-definition">scope</span>) =&gt; {
  <span class="tok-keyword">let</span> <span class="tok-definition">valor</span> = false;
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">arg</span> <span class="tok-keyword">of</span> args) {
    valor = evaluate(arg, scope);
  }
  <span class="tok-keyword">return</span> valor;
};</pre>

<p><a class="p_ident" id="p-p3K5iHWfUQ" href="#p-p3K5iHWfUQ" tabindex="-1" role="presentation"></a>Para poder crear vinculaciones y darles nuevos valores, tambi√©n creamos una forma llamada <code>define</code>. Espera una palabra como su primer argumento y una expresi√≥n que produzca el valor a asignar a esa palabra como su segundo argumento. Dado que <code>define</code>, al igual que todo, es una expresi√≥n, debe devolver un valor. Haremos que devuelva el valor que se asign√≥ (como el operador <code>=</code> de JavaScript).</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-9inONoYidA" href="#c-9inONoYidA" tabindex="-1" role="presentation"></a>specialForms.define = (<span class="tok-definition">args</span>, <span class="tok-definition">scope</span>) =&gt; {
  <span class="tok-keyword">if</span> (args.length != <span class="tok-number">2</span> || args[<span class="tok-number">0</span>].type != <span class="tok-string">&quot;word&quot;</span>) {
    <span class="tok-keyword">throw</span> <span class="tok-keyword">new</span> SyntaxError(<span class="tok-string">&quot;Uso incorrecto de define&quot;</span>);
  }
  <span class="tok-keyword">let</span> <span class="tok-definition">value</span> = evaluate(args[<span class="tok-number">1</span>], scope);
  scope[args[<span class="tok-number">0</span>].name] = value;
  <span class="tok-keyword">return</span> value;
};</pre>

<h2><a class="h_ident" id="h-QDYVZFuV/L" href="#h-QDYVZFuV/L" tabindex="-1" role="presentation"></a>El entorno</h2>

<p><a class="p_ident" id="p-t3Y1Pmfab7" href="#p-t3Y1Pmfab7" tabindex="-1" role="presentation"></a>El scope aceptado por <code>evaluate</code> es un objeto con propiedades cuyos nombres corresponden a los nombres de los bindings y cuyos valores corresponden a los valores a los que esos bindings est√°n ligados. Definamos un objeto para representar el scope global.</p>

<p><a class="p_ident" id="p-b3b8HuKUtZ" href="#p-b3b8HuKUtZ" tabindex="-1" role="presentation"></a>Para poder usar la construcci√≥n <code>if</code> que acabamos de definir, necesitamos tener acceso a valores Booleanos. Dado que solo hay dos valores Booleanos, no necesitamos una sintaxis especial para ellos. Simplemente asignamos dos nombres a los valores <code>true</code> y <code>false</code> y los usamos.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-vJ45zHlK0v" href="#c-vJ45zHlK0v" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">topScope</span> = Object.create(<span class="tok-keyword">null</span>);

topScope.true = true;
topScope.false = false;</pre>

<p><a class="p_ident" id="p-2qBpV6Yj9I" href="#p-2qBpV6Yj9I" tabindex="-1" role="presentation"></a>Ahora podemos evaluar una expresi√≥n simple que niega un valor Booleano.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-ynBEgrK+/h" href="#c-ynBEgrK+/h" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">prog</span> = parse(<span class="tok-string2">`if(true, false, true)`</span>);
console.log(evaluate(prog, topScope));
<span class="tok-comment">// ‚Üí false</span></pre>

<p><a class="p_ident" id="p-bkglU4hrcr" href="#p-bkglU4hrcr" tabindex="-1" role="presentation"></a>Para suministrar operadores b√°sicos de aritm√©tica y comparaci√≥n, tambi√©n agregaremos algunas funciones al scope. En aras de mantener el c√≥digo corto, usaremos <code>Function</code> para sintetizar un conjunto de funciones de operadores en un bucle, en lugar de definirlas individualmente.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-OTgmEw/s8v" href="#c-OTgmEw/s8v" tabindex="-1" role="presentation"></a><span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">op</span> <span class="tok-keyword">of</span> [<span class="tok-string">&quot;+&quot;</span>, <span class="tok-string">&quot;-&quot;</span>, <span class="tok-string">&quot;*&quot;</span>, <span class="tok-string">&quot;/&quot;</span>, <span class="tok-string">&quot;==&quot;</span>, <span class="tok-string">&quot;&lt;&quot;</span>, <span class="tok-string">&quot;&gt;&quot;</span>]) {
  topScope[op] = Function(<span class="tok-string">&quot;a, b&quot;</span>, <span class="tok-string2">`return a </span>${op}<span class="tok-string2"> b;`</span>);
}</pre>

<p><a class="p_ident" id="p-/LoFnlViDG" href="#p-/LoFnlViDG" tabindex="-1" role="presentation"></a>Tambi√©n es √∫til tener una forma de imprimir valores, por lo que envolveremos <code>console.log</code> en una funci√≥n y la llamaremos <code>print</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-XFrq8jIuQC" href="#c-XFrq8jIuQC" tabindex="-1" role="presentation"></a>topScope.print = <span class="tok-definition">value</span> =&gt; {
  console.log(value);
  <span class="tok-keyword">return</span> value;
};</pre>

<p><a class="p_ident" id="p-fwBjYvhI3d" href="#p-fwBjYvhI3d" tabindex="-1" role="presentation"></a>Esto nos proporciona suficientes herramientas elementales para escribir programas simples. La siguiente funci√≥n proporciona una forma conveniente de analizar un programa y ejecutarlo en un nuevo √°mbito:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-aPeJgSZPEO" href="#c-aPeJgSZPEO" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">run</span>(<span class="tok-definition">program</span>) {
  <span class="tok-keyword">return</span> evaluate(parse(program), Object.create(topScope));
}</pre>

<p><a class="p_ident" id="p-QlhCpeZ1rM" href="#p-QlhCpeZ1rM" tabindex="-1" role="presentation"></a>Utilizaremos las cadenas de prototipos de objetos para representar √°mbitos anidados para que el programa pueda agregar bindings a su √°mbito local sin modificar el √°mbito de nivel superior.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-uW/XtfVXMZ" href="#c-uW/XtfVXMZ" tabindex="-1" role="presentation"></a>run(<span class="tok-string2">`</span>
<span class="tok-string2">do(define(total, 0),</span>
<span class="tok-string2">   define(count, 1),</span>
<span class="tok-string2">   while(&lt;(count, 11),</span>
<span class="tok-string2">         do(define(total, +(total, count)),</span>
<span class="tok-string2">            define(count, +(count, 1)))),</span>
<span class="tok-string2">   print(total))</span>
<span class="tok-string2">`</span>);
<span class="tok-comment">// ‚Üí 55</span></pre>

<p><a class="p_ident" id="p-xNJMDZFJNP" href="#p-xNJMDZFJNP" tabindex="-1" role="presentation"></a>Este es el programa que hemos visto varias veces antes, que calcula la suma de los n√∫meros del 1 al 10, expresado en Egg. Es claramente m√°s feo que el equivalente programa en JavaScript, pero no est√° mal para un lenguaje implementado en menos de 150 l√≠neas de c√≥digo.</p>

<h2 id="egg_fun"><a class="h_ident" id="h-H0l5He7QIh" href="#h-H0l5He7QIh" tabindex="-1" role="presentation"></a>Funciones</h2>

<p><a class="p_ident" id="p-pxhz3ZokU1" href="#p-pxhz3ZokU1" tabindex="-1" role="presentation"></a>Un lenguaje de programaci√≥n sin funciones es un pobre lenguaje de programaci√≥n.</p>

<p><a class="p_ident" id="p-Knv8+HvQ29" href="#p-Knv8+HvQ29" tabindex="-1" role="presentation"></a>Afortunadamente, no es dif√≠cil agregar una construcci√≥n <code>fun</code>, que trata su √∫ltimo argumento como el cuerpo de la funci√≥n y utiliza todos los argumentos anteriores como los nombres de los par√°metros de la funci√≥n.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-nLlUjn7C0q" href="#c-nLlUjn7C0q" tabindex="-1" role="presentation"></a>specialForms.fun = (<span class="tok-definition">args</span>, <span class="tok-definition">scope</span>) =&gt; {
  <span class="tok-keyword">if</span> (!args.length) {
    <span class="tok-keyword">throw</span> <span class="tok-keyword">new</span> SyntaxError(<span class="tok-string">&quot;Las funciones necesitan un cuerpo&quot;</span>);
  }
  <span class="tok-keyword">let</span> <span class="tok-definition">body</span> = args[args.length - <span class="tok-number">1</span>];
  <span class="tok-keyword">let</span> <span class="tok-definition">params</span> = args.slice(<span class="tok-number">0</span>, args.length - <span class="tok-number">1</span>).map(<span class="tok-definition">expr</span> =&gt; {
    <span class="tok-keyword">if</span> (expr.type != <span class="tok-string">&quot;word&quot;</span>) {
      <span class="tok-keyword">throw</span> <span class="tok-keyword">new</span> SyntaxError(<span class="tok-string">&quot;Los nombres de los par√°metros deben ser palabras&quot;</span>);
    }
    <span class="tok-keyword">return</span> expr.name;
  });

  <span class="tok-keyword">return</span> <span class="tok-keyword">function</span>(...<span class="tok-definition">args</span>) {
    <span class="tok-keyword">if</span> (args.length != params.length) {
      <span class="tok-keyword">throw</span> <span class="tok-keyword">new</span> TypeError(<span class="tok-string">&quot;N√∫mero incorrecto de argumentos&quot;</span>);
    }
    <span class="tok-keyword">let</span> <span class="tok-definition">localScope</span> = Object.create(scope);
    <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">i</span> = <span class="tok-number">0</span>; i &lt; args.length; i++) {
      localScope[params[i]] = args[i];
    }
    <span class="tok-keyword">return</span> evaluate(body, localScope);
  };
};</pre>

<p><a class="p_ident" id="p-gjkoD3dPuc" href="#p-gjkoD3dPuc" tabindex="-1" role="presentation"></a>Las funciones en Egg tienen su propio √°mbito local. La funci√≥n producida por la forma <code>fun</code> crea este √°mbito local y a√±ade los enlaces de los argumentos a √©l. Luego eval√∫a el cuerpo de la funci√≥n en este √°mbito y devuelve el resultado.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-tn5DChGAkA" href="#c-tn5DChGAkA" tabindex="-1" role="presentation"></a>run(<span class="tok-string2">`</span>
<span class="tok-string2">do(define(plusOne, fun(a, +(a, 1))),</span>
<span class="tok-string2">   print(plusOne(10)))</span>
<span class="tok-string2">`</span>);
<span class="tok-comment">// ‚Üí 11</span>

run(<span class="tok-string2">`</span>
<span class="tok-string2">do(define(pow, fun(base, exp,</span>
<span class="tok-string2">     if(==(exp, 0),</span>
<span class="tok-string2">        1,</span>
<span class="tok-string2">        *(base, pow(base, -(exp, 1)))))),</span>
<span class="tok-string2">   print(pow(2, 10)))</span>
<span class="tok-string2">`</span>);
<span class="tok-comment">// ‚Üí 1024</span></pre>

<h2><a class="h_ident" id="h-QZp+1BKgLP" href="#h-QZp+1BKgLP" tabindex="-1" role="presentation"></a>Compilaci√≥n</h2>

<p><a class="p_ident" id="p-pYpmnQkmEE" href="#p-pYpmnQkmEE" tabindex="-1" role="presentation"></a>Lo que hemos construido es un int√©rprete. Durante la evaluaci√≥n, act√∫a directamente sobre la representaci√≥n del programa producido por el analizador sint√°ctico.</p>

<p><a class="p_ident" id="p-TqdaU5OIYq" href="#p-TqdaU5OIYq" tabindex="-1" role="presentation"></a><em>La compilaci√≥n</em> es el proceso de agregar otro paso entre el an√°lisis sint√°ctico y la ejecuci√≥n de un programa, que transforma el programa en algo que puede ser evaluado de manera m√°s eficiente al hacer la mayor cantidad de trabajo posible por adelantado. Por ejemplo, en lenguajes bien dise√±ados, es obvio, para cada uso de un enlace, a qu√© enlace se hace referencia, sin ejecutar realmente el programa. Esto se puede utilizar para evitar buscar el enlace por nombre cada vez que se accede, en su lugar, recuper√°ndolo directamente desde una ubicaci√≥n de memoria predeterminada.</p>

<p><a class="p_ident" id="p-MlvKWh44Ts" href="#p-MlvKWh44Ts" tabindex="-1" role="presentation"></a>Tradicionalmente, compilar implica convertir el programa a c√≥digo m√°quina, el formato en bruto que un procesador de computadora puede ejecutar. Pero cualquier proceso que convierta un programa a una representaci√≥n diferente se puede considerar como compilaci√≥n.</p>

<p><a class="p_ident" id="p-aM2KGsJ5pX" href="#p-aM2KGsJ5pX" tabindex="-1" role="presentation"></a>Ser√≠a posible escribir una estrategia de evaluaci√≥n alternativa para Egg, una que primero convierte el programa a un programa JavaScript, usa <code>Function</code> para invocar el compilador de JavaScript en √©l, y luego ejecuta el resultado. Cuando se hace correctamente, esto har√≠a que Egg se ejecutara muy r√°pido y a√∫n as√≠ fuera bastante simple de implementar.</p>

<p><a class="p_ident" id="p-41d+3GRIQp" href="#p-41d+3GRIQp" tabindex="-1" role="presentation"></a>Si te interesa este tema y est√°s dispuesto a dedicar tiempo a ello, te animo a intentar implementar ese compilador como ejercicio.</p>

<h2><a class="h_ident" id="h-cAD+YSu/Uu" href="#h-cAD+YSu/Uu" tabindex="-1" role="presentation"></a>Haciendo trampa</h2>

<p><a class="p_ident" id="p-VP1siqwk/B" href="#p-VP1siqwk/B" tabindex="-1" role="presentation"></a>Cuando definimos <code>if</code> y <code>while</code>, probablemente notaste que eran envoltorios m√°s o menos triviales alrededor del propio <code>if</code> y <code>while</code> de JavaScript. De manera similar, los valores en Egg son simplemente valores regulares de JavaScript. Cerrar la brecha hacia un sistema m√°s primitivo, como el c√≥digo m√°quina que entiende el procesador, requiere m√°s esfuerzo, pero la forma en que funciona se asemeja a lo que estamos haciendo aqu√≠.Aunque el lenguaje de juguete de este cap√≠tulo no hace nada que no se pudiera hacer mejor en JavaScript, <em>s√≠</em> hay situaciones donde escribir peque√±os lenguajes ayuda a realizar trabajos reales.</p>

<p><a class="p_ident" id="p-kbfQXnrr8R" href="#p-kbfQXnrr8R" tabindex="-1" role="presentation"></a>Tal lenguaje no tiene por qu√© parecerse a un lenguaje de programaci√≥n t√≠pico. Si JavaScript no viniera equipado con expresiones regulares, por ejemplo, podr√≠as escribir tu propio analizador sint√°ctico y evaluador para expresiones regulares.</p>

<p><a class="p_ident" id="p-UmyA5toIkN" href="#p-UmyA5toIkN" tabindex="-1" role="presentation"></a>O imagina que est√°s construyendo un programa que permite crear r√°pidamente analizadores sint√°cticos al proporcionar una descripci√≥n l√≥gica del lenguaje que necesitan analizar. Podr√≠as definir una notaci√≥n espec√≠fica para eso y un compilador que la convierta en un programa analizador.</p>

<pre class="snippet" data-language="null" ><a class="c_ident" id="c-ZLsfR3tk19" href="#c-ZLsfR3tk19" tabindex="-1" role="presentation"></a>expr = n√∫mero | cadena | nombre | aplicaci√≥n

number = d√≠gito+

name = letra+

string = '&quot;' (! '&quot;')* '&quot;'

application = expr '(' (expr (',' expr)*)? ')'</pre>

<p><a class="p_ident" id="p-C0dzBDL4SR" href="#p-C0dzBDL4SR" tabindex="-1" role="presentation"></a>Esto es lo que com√∫nmente se denomina un <em>lenguaje espec√≠fico de dominio</em>, un lenguaje dise√±ado para expresar un √°mbito estrecho de conocimiento. Tal lenguaje puede ser m√°s expresivo que un lenguaje de prop√≥sito general porque est√° dise√±ado para describir exactamente las cosas que necesitan ser descritas en su dominio, y nada m√°s.</p>

<h2><a class="h_ident" id="h-tkm7ntLto1" href="#h-tkm7ntLto1" tabindex="-1" role="presentation"></a>Ejercicios</h2>

<h3><a class="i_ident" id="i-uQzJv9I1Z6" href="#i-uQzJv9I1Z6" tabindex="-1" role="presentation"></a>Arrays</h3>

<p><a class="p_ident" id="p-t4E4CEaBzk" href="#p-t4E4CEaBzk" tabindex="-1" role="presentation"></a>Agrega soporte para arrays en Egg a√±adiendo las siguientes tres funciones al √°mbito superior: <code>array(.<wbr>.<wbr>.<wbr>valores)</code> para construir un array que contenga los valores de los argumentos, <code>length(array)</code> para obtener la longitud de un array y <code>element(array, n)</code> para obtener el n-√©simo elemento de un array.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-fh4cngpM93" href="#c-fh4cngpM93" tabindex="-1" role="presentation"></a><span class="tok-comment">// Modifica estas definiciones...</span>

topScope.array = <span class="tok-string">&quot;...&quot;</span>;

topScope.length = <span class="tok-string">&quot;...&quot;</span>;

topScope.element = <span class="tok-string">&quot;...&quot;</span>;

run(<span class="tok-string2">`</span>
<span class="tok-string2">do(define(sum, fun(array,</span>
<span class="tok-string2">     do(define(i, 0),</span>
<span class="tok-string2">        define(sum, 0),</span>
<span class="tok-string2">        while(&lt;(i, length(array)),</span>
<span class="tok-string2">          do(define(sum, +(sum, element(array, i))),</span>
<span class="tok-string2">             define(i, +(i, 1)))),</span>
<span class="tok-string2">        sum))),</span>
<span class="tok-string2">   print(sum(array(1, 2, 3))))</span>
<span class="tok-string2">`</span>);
<span class="tok-comment">// ‚Üí 6</span></pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-V6CA9sjtEY" href="#p-V6CA9sjtEY" tabindex="-1" role="presentation"></a>La forma m√°s sencilla de hacer esto es representar los arrays de Egg con arrays de JavaScript.</p>

<p><a class="p_ident" id="p-gKO9oQjczI" href="#p-gKO9oQjczI" tabindex="-1" role="presentation"></a>Los valores a√±adidos al √°mbito superior deben ser funciones. Al usar un argumento restante (con la notaci√≥n de triple punto), la definici√≥n de <code>array</code> puede ser <em>muy</em> simple.</p>

</div></details>

<h3><a class="i_ident" id="i-KU8YojAGul" href="#i-KU8YojAGul" tabindex="-1" role="presentation"></a>Clausura</h3>

<p><a class="p_ident" id="p-fppmSSGuOO" href="#p-fppmSSGuOO" tabindex="-1" role="presentation"></a>La forma en que hemos definido <code>fun</code> permite que las funciones en Egg hagan referencia al √°mbito circundante, lo que permite que el cuerpo de la funci√≥n use valores locales que eran visibles en el momento en que se defini√≥ la funci√≥n, al igual que lo hacen las funciones de JavaScript.</p>

<p><a class="p_ident" id="p-CGUDr6fRr0" href="#p-CGUDr6fRr0" tabindex="-1" role="presentation"></a>El siguiente programa ilustra esto: la funci√≥n <code>f</code> devuelve una funci√≥n que suma su argumento al argumento de <code>f</code>, lo que significa que necesita acceder al √°mbito local dentro de <code>f</code> para poder usar la vinculaci√≥n <code>a</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-zJ2x7sbWRv" href="#c-zJ2x7sbWRv" tabindex="-1" role="presentation"></a>run(<span class="tok-string2">`</span>
<span class="tok-string2">do(define(f, fun(a, fun(b, +(a, b)))),</span>
<span class="tok-string2">   print(f(4)(5)))</span>
<span class="tok-string2">`</span>);
<span class="tok-comment">// ‚Üí 9</span></pre>

<p><a class="p_ident" id="p-8Tn4o3XoK3" href="#p-8Tn4o3XoK3" tabindex="-1" role="presentation"></a>Vuelve a la definici√≥n del formulario <code>fun</code> y explica qu√© mecanismo hace que esto funcione.</p>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-+PSytzGvu7" href="#p-+PSytzGvu7" tabindex="-1" role="presentation"></a>Una vez m√°s, estamos montando un mecanismo en JavaScript para obtener la caracter√≠stica equivalente en Egg. Los formularios especiales reciben el √°mbito local en el que se eval√∫an para que puedan evaluar sus subformas en ese √°mbito. La funci√≥n devuelta por <code>fun</code> tiene acceso al argumento <code>scope</code> dado a su funci√≥n contenedora y lo utiliza para crear el √°mbito local de la funci√≥n cuando se llama.</p>

<p><a class="p_ident" id="p-ZUZpVdQzvJ" href="#p-ZUZpVdQzvJ" tabindex="-1" role="presentation"></a>Esto significa que el prototipo del √°mbito local ser√° el √°mbito en el cual la funci√≥n fue creada, lo que hace posible acceder a los enlaces en ese √°mbito desde la funci√≥n. Esto es todo lo que se necesita para implementar el cierre (aunque para compilarlo de una manera realmente eficiente, ser√≠a necesario hacer un poco m√°s de trabajo).</p>

</div></details>

<h3><a class="i_ident" id="i-BU3lBD6Cl5" href="#i-BU3lBD6Cl5" tabindex="-1" role="presentation"></a>Comentarios</h3>

<p><a class="p_ident" id="p-O8y2A3uI5s" href="#p-O8y2A3uI5s" tabindex="-1" role="presentation"></a>Ser√≠a bueno si pudi√©ramos escribir comentarios en Egg. Por ejemplo, siempre que encontremos un signo de almohadilla (<code>#</code>), podr√≠amos tratar el resto de la l√≠nea como un comentario y ignorarlo, similar a <code>//</code> en JavaScript.</p>

<p><a class="p_ident" id="p-ctRQbLAhSs" href="#p-ctRQbLAhSs" tabindex="-1" role="presentation"></a>No tenemos que hacer grandes cambios en el analizador para admitir esto. Simplemente podemos cambiar <code>skipSpace</code> para omitir comentarios como si fueran espacios en blanco de manera que todos los puntos donde se llama a <code>skipSpace</code> ahora tambi√©n omitir√°n comentarios. Realiza este cambio.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-mAy9RNedq5" href="#c-mAy9RNedq5" tabindex="-1" role="presentation"></a><span class="tok-comment">// Este es el skipSpace antiguo. Modif√≠calo...</span>
<span class="tok-keyword">function</span> <span class="tok-definition">skipSpace</span>(<span class="tok-definition">string</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">first</span> = string.search(<span class="tok-string2">/\S/</span>);
  <span class="tok-keyword">if</span> (first == -<span class="tok-number">1</span>) <span class="tok-keyword">return</span> <span class="tok-string">&quot;&quot;</span>;
  <span class="tok-keyword">return</span> string.slice(first);
}

console.log(parse(<span class="tok-string">&quot;# hola</span><span class="tok-string2">\n</span><span class="tok-string">x&quot;</span>));
<span class="tok-comment">// ‚Üí {type: &quot;word&quot;, name: &quot;x&quot;}</span>

console.log(parse(<span class="tok-string">&quot;a # uno</span><span class="tok-string2">\n</span><span class="tok-string">   # dos</span><span class="tok-string2">\n</span><span class="tok-string">()&quot;</span>));
<span class="tok-comment">// ‚Üí {type: &quot;apply&quot;,</span>
<span class="tok-comment">//    operator: {type: &quot;word&quot;, name: &quot;a&quot;},</span>
<span class="tok-comment">//    args: []}</span></pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-4pQ2RIUDPS" href="#p-4pQ2RIUDPS" tabindex="-1" role="presentation"></a>Aseg√∫rate de que tu soluci√≥n maneje m√∫ltiples comentarios seguidos, con posiblemente espacios en blanco entre ellos o despu√©s de ellos.</p>

<p><a class="p_ident" id="p-QQa8lWmHXT" href="#p-QQa8lWmHXT" tabindex="-1" role="presentation"></a>Una expresi√≥n regular es probablemente la forma m√°s sencilla de resolver esto. Escribe algo que coincida con ‚Äúespacio en blanco o un comentario, cero o m√°s veces‚Äù. Utiliza el m√©todo <code>exec</code> o <code>match</code> y observa la longitud del primer elemento en la matriz devuelta (la coincidencia completa) para averiguar cu√°ntos caracteres cortar.</p>

</div></details>

<h3><a class="i_ident" id="i-TJ4IOq9YIj" href="#i-TJ4IOq9YIj" tabindex="-1" role="presentation"></a>Corrigiendo el √°mbito</h3>

<p><a class="p_ident" id="p-OLjh9e6hGE" href="#p-OLjh9e6hGE" tabindex="-1" role="presentation"></a>Actualmente, la √∫nica forma de asignar un enlace un valor es <code>define</code>. Esta construcci√≥n act√∫a como una forma tanto de definir nuevos enlaces como de dar un nuevo valor a los existentes.</p>

<p><a class="p_ident" id="p-ssqoqtZ2fc" href="#p-ssqoqtZ2fc" tabindex="-1" role="presentation"></a>Esta ambig√ºedad causa un problema. Cuando intentas darle un nuevo valor a un enlace no local, terminar√°s definiendo uno local con el mismo nombre en su lugar. Algunos lenguajes funcionan de esta manera por dise√±o, pero siempre he encontrado que es una forma inc√≥moda de manejar el √°mbito.</p>

<p><a class="p_ident" id="p-bmER/dL8WQ" href="#p-bmER/dL8WQ" tabindex="-1" role="presentation"></a>Agrega una forma especial <code>set</code>, similar a <code>define</code>, que da un nuevo valor a un enlace, actualizando el enlace en un √°mbito exterior si a√∫n no existe en el √°mbito interior. Si el enlace no est√° definido en absoluto, lanza un <code>ReferenceError</code> (otro tipo de error est√°ndar).</p>

<p><a class="p_ident" id="p-sX9Cu8BPn/" href="#p-sX9Cu8BPn/" tabindex="-1" role="presentation"></a>La t√©cnica de representar los √°mbitos como objetos simples, que hasta ahora ha sido conveniente, te causar√° un peque√±o problema en este punto. Es posible que desees usar la funci√≥n <code>Object.<wbr>getPrototypeOf</code>, la cual devuelve el prototipo de un objeto. Tambi√©n recuerda que puedes utilizar <code>Object.hasOwn</code> para verificar si un objeto dado tiene una propiedad.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-kGrfbWJiix" href="#c-kGrfbWJiix" tabindex="-1" role="presentation"></a>specialForms.set = (<span class="tok-definition">args</span>, <span class="tok-definition">scope</span>) =&gt; {
  <span class="tok-comment">// Tu c√≥digo aqu√≠.</span>
};

run(<span class="tok-string2">`</span>
<span class="tok-string2">do(define(x, 4),</span>
<span class="tok-string2">   define(setx, fun(val, set(x, val))),</span>
<span class="tok-string2">   setx(50),</span>
<span class="tok-string2">   print(x))</span>
<span class="tok-string2">`</span>);
<span class="tok-comment">// ‚Üí 50</span>
run(<span class="tok-string2">`set(quux, true)`</span>);
<span class="tok-comment">// ‚Üí Alg√∫n tipo de ReferenceError</span></pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-3GnB2HNK88" href="#p-3GnB2HNK88" tabindex="-1" role="presentation"></a>Tendr√°s que iterar a trav√©s de un scope a la vez, utilizando <code>Object.<wbr>getPrototypeOf</code> para ir al siguiente √°mbito exterior. Para cada √°mbito, utiliza <code>Object.hasOwn</code> para determinar si el enlace, indicado por la propiedad <code>name</code> del primer argumento de <code>set</code>, existe en ese √°mbito. Si existe, establ√©celo en el resultado de evaluar el segundo argumento de <code>set</code> y luego devuelve ese valor.</p>

<p><a class="p_ident" id="p-oVYMm2onb4" href="#p-oVYMm2onb4" tabindex="-1" role="presentation"></a>Si se alcanza el √°mbito m√°s externo (<code>Object.<wbr>getPrototypeOf</code> devuelve null) y a√∫n no hemos encontrado el enlace, significa que no existe y se debe lanzar un error.</p>

</div></details><nav><a href="11_async.html" title="previous chapter" aria-label="previous chapter">‚óÇ</a>¬†<a href="index.html" title="cover" aria-label="cover">‚óè</a>¬†<a href="13_browser.html" title="next chapter" aria-label="next chapter">‚ñ∏</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>&nbsp;<button class="dark-mode-toggle">üåô</button>
</nav>
</article>

<script src="ejs.js"></script>
