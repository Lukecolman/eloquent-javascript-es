<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Proyecto: Un Robot :: Eloquent JavaScript</title>
  <link rel=stylesheet href="css/ejs.css"><script>
      var page = {"type":"chapter","number":7,"load_files":["code/chapter/07_robot.js","code/animatevillage.js"]}</script></head>

<article>
<nav><a href="06_object.html" title="previous chapter" aria-label="previous chapter">‚óÇ</a>¬†<a href="index.html" title="cover" aria-label="cover">‚óè</a>¬†<a href="08_error.html" title="next chapter" aria-label="next chapter">‚ñ∏</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>&nbsp;<button class="dark-mode-toggle">üåô</button>
</nav>

<h1>Proyecto: Un Robot</h1>

<blockquote>

<p><a class="p_ident" id="p-/Oc+pQbX3S" href="#p-/Oc+pQbX3S" tabindex="-1" role="presentation"></a>[...] la pregunta de si las M√°quinas Pueden Pensar [...] es tan relevante como la pregunta de si los Submarinos Pueden Nadar.</p>

<footer>Edsger Dijkstra, <cite>Las amenazas a la ciencia inform√°tica</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_7.jpg" alt="Ilustraci√≥n de un robot sosteniendo una pila de paquetes"></figure>

<p><a class="p_ident" id="p-0PBWKq6GYO" href="#p-0PBWKq6GYO" tabindex="-1" role="presentation"></a>En los cap√≠tulos del ‚Äúproyecto‚Äù, dejar√© de golpearte con nueva teor√≠a por un breve momento, y en su lugar trabajaremos en un programa juntos. La teor√≠a es necesaria para aprender a programar, pero leer y entender programas reales es igual de importante.</p>

<p><a class="p_ident" id="p-1ftX4jVXFE" href="#p-1ftX4jVXFE" tabindex="-1" role="presentation"></a>Nuestro proyecto en este cap√≠tulo es construir un aut√≥mata, un peque√±o programa que realiza una tarea en un mundo virtual. Nuestro aut√≥mata ser√° un robot de entrega de correo que recoge y deja paquetes.</p>

<h2><a class="h_ident" id="h-UmFK5fYed8" href="#h-UmFK5fYed8" tabindex="-1" role="presentation"></a>Meadowfield</h2>

<p><a class="p_ident" id="p-CoFPYYp5Q2" href="#p-CoFPYYp5Q2" tabindex="-1" role="presentation"></a>El pueblo de Meadowfield no es muy grande. Consiste en 11 lugares con 14 carreteras entre ellos. Se puede describir con este array de carreteras:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-NplCaNzuvn" href="#c-NplCaNzuvn" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">roads</span> = [
  <span class="tok-string">&quot;Casa de Alice-Casa de Bob&quot;</span>,<span class="tok-string">&quot;Casa de Alice-Caba√±a&quot;</span>,
  <span class="tok-string">&quot;Casa de Alice-Oficina de Correos&quot;</span>,<span class="tok-string">&quot;Casa de Bob-Ayuntamiento&quot;</span>,
  <span class="tok-string">&quot;Casa de Daria-Casa de Ernie&quot;</span>,<span class="tok-string">&quot;Casa de Daria-Ayuntamiento&quot;</span>,
  <span class="tok-string">&quot;Casa de Ernie-Casa de Grete&quot;</span>,<span class="tok-string">&quot;Casa de Grete-Granja&quot;</span>,
  <span class="tok-string">&quot;Casa de Grete-Tienda&quot;</span>,<span class="tok-string">&quot;Plaza del Mercado-Granja&quot;</span>,
  <span class="tok-string">&quot;Plaza del Mercado-Oficina de Correos&quot;</span>,<span class="tok-string">&quot;Plaza del Mercado-Tienda&quot;</span>,
  <span class="tok-string">&quot;Plaza del Mercado-Ayuntamiento&quot;</span>,<span class="tok-string">&quot;Tienda-Ayuntamiento&quot;</span>
];</pre><figure><img src="img/village2x.png" alt="Ilustraci√≥n de arte pixelado de un peque√±o pueblo con 11 ubicaciones, etiquetadas con letras, y carreteras entre ellas"></figure>

<p><a class="p_ident" id="p-z97coTX23j" href="#p-z97coTX23j" tabindex="-1" role="presentation"></a>La red de carreteras en el pueblo forma un <em>gr√°fico</em>. Un gr√°fico es una colecci√≥n de puntos (lugares en el pueblo) con l√≠neas entre ellos (carreteras). Este gr√°fico ser√° el mundo por el que se mover√° nuestro robot.</p>

<p><a class="p_ident" id="p-Hw3WY9bviH" href="#p-Hw3WY9bviH" tabindex="-1" role="presentation"></a>El array de cadenas no es muy f√°cil de trabajar. Lo que nos interesa son los destinos a los que podemos llegar desde un lugar dado. Vamos a convertir la lista de carreteras en una estructura de datos que, para cada lugar, nos diga qu√© se puede alcanzar desde all√≠.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-k8seJpRr5W" href="#c-k8seJpRr5W" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">buildGraph</span>(<span class="tok-definition">edges</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">graph</span> = Object.create(<span class="tok-keyword">null</span>);
  <span class="tok-keyword">function</span> <span class="tok-definition">addEdge</span>(<span class="tok-definition">from</span>, <span class="tok-definition">to</span>) {
    <span class="tok-keyword">if</span> (from <span class="tok-keyword">in</span> graph) {
      graph[from].push(to);
    } <span class="tok-keyword">else</span> {
      graph[from] = [to];
    }
  }
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> [<span class="tok-definition">from</span>, <span class="tok-definition">to</span>] <span class="tok-keyword">of</span> edges.map(<span class="tok-definition">r</span> =&gt; r.split(<span class="tok-string">&quot;-&quot;</span>))) {
    addEdge(from, to);
    addEdge(to, from);
  }
  <span class="tok-keyword">return</span> graph;
}

<span class="tok-keyword">const</span> <span class="tok-definition">roadGraph</span> = buildGraph(roads);</pre>

<p><a class="p_ident" id="p-jL6/RvPMt+" href="#p-jL6/RvPMt+" tabindex="-1" role="presentation"></a>Dado un array de aristas, <code>buildGraph</code> crea un objeto de mapa que, para cada nodo, almacena un array de nodos conectados.</p>

<p><a class="p_ident" id="p-ibN0Rbh4w2" href="#p-ibN0Rbh4w2" tabindex="-1" role="presentation"></a>Utiliza el m√©todo <code>split</code> para pasar de las cadenas de carreteras, que tienen la forma <code>&quot;Inicio-Fin&quot;</code>, a arrays de dos elementos que contienen el inicio y el fin como cadenas separadas.</p>

<h2><a class="h_ident" id="h-ZcNPR9BKaF" href="#h-ZcNPR9BKaF" tabindex="-1" role="presentation"></a>La tarea</h2>

<p><a class="p_ident" id="p-XsakbvETgS" href="#p-XsakbvETgS" tabindex="-1" role="presentation"></a>Nuestro robot se mover√° por el pueblo. Hay paquetes en varios lugares, cada uno dirigido a alg√∫n otro lugar. El robot recoge los paquetes cuando llega a ellos y los entrega cuando llega a sus destinos.</p>

<p><a class="p_ident" id="p-Qlp0SuVjri" href="#p-Qlp0SuVjri" tabindex="-1" role="presentation"></a>El aut√≥mata debe decidir, en cada punto, hacia d√≥nde ir a continuaci√≥n. Habr√° terminado su tarea cuando todos los paquetes hayan sido entregados.</p>

<p><a class="p_ident" id="p-KwKhwC7IzT" href="#p-KwKhwC7IzT" tabindex="-1" role="presentation"></a>Para poder simular este proceso, debemos definir un mundo virtual que pueda describirlo. Este modelo nos dice d√≥nde est√° el robot y d√≥nde est√°n los paquetes. Cuando el robot decide moverse a alg√∫n lugar, necesitamos actualizar el modelo para reflejar la nueva situaci√≥n.</p>

<p><a class="p_ident" id="p-ImUqv6bngP" href="#p-ImUqv6bngP" tabindex="-1" role="presentation"></a>Si est√°s pensando en t√©rminos de programaci√≥n orientada a objetos, tu primer impulso podr√≠a ser empezar a definir objetos para los diferentes elementos en el mundo: una clase para el robot, una para un paquete, tal vez una para lugares. Estos podr√≠an tener propiedades que describen su estado actual, como la pila de paquetes en un lugar, que podr√≠amos cambiar al actualizar el mundo.</p>

<p><a class="p_ident" id="p-C/Z3QwwroQ" href="#p-C/Z3QwwroQ" tabindex="-1" role="presentation"></a>Esto es incorrecto. Al menos, usualmente lo es. El hecho de que algo suene como un objeto no significa autom√°ticamente que deba ser un objeto en tu programa. Escribir reflexivamente clases para cada concepto en tu aplicaci√≥n tiende a dejarte con una colecci√≥n de objetos interconectados que tienen su propio estado interno cambiable. Estos programas a menudo son dif√≠ciles de entender y, por lo tanto, f√°ciles de romper.</p>

<p><a class="p_ident" id="p-5099+VupJV" href="#p-5099+VupJV" tabindex="-1" role="presentation"></a>En lugar de eso, vamos a condensar el estado del pueblo en el conjunto m√≠nimo de valores que lo define. Est√° la ubicaci√≥n actual del robot y la colecci√≥n de paquetes no entregados, cada uno de los cuales tiene una ubicaci√≥n actual y una direcci√≥n de destino. Eso es todo.</p>

<p><a class="p_ident" id="p-P5OPIi9FfW" href="#p-P5OPIi9FfW" tabindex="-1" role="presentation"></a>Y mientras lo hacemos, hagamos que no <em>cambiemos</em> este estado cuando el robot se mueve, sino que calculemos un <em>nuevo</em> estado para la situaci√≥n despu√©s del movimiento.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-VcDNIi1lcV" href="#c-VcDNIi1lcV" tabindex="-1" role="presentation"></a><span class="tok-keyword">class</span> VillageState {
  <span class="tok-definition">constructor</span>(<span class="tok-definition">place</span>, <span class="tok-definition">parcels</span>) {
    <span class="tok-keyword">this</span>.place = place;
    <span class="tok-keyword">this</span>.parcels = parcels;
  }

  <span class="tok-definition">move</span>(<span class="tok-definition">destination</span>) {
    <span class="tok-keyword">if</span> (!roadGraph[<span class="tok-keyword">this</span>.place].includes(destination)) {
      <span class="tok-keyword">return</span> <span class="tok-keyword">this</span>;
    } <span class="tok-keyword">else</span> {
      <span class="tok-keyword">let</span> <span class="tok-definition">parcels</span> = <span class="tok-keyword">this</span>.parcels.map(<span class="tok-definition">p</span> =&gt; {
        <span class="tok-keyword">if</span> (p.place != <span class="tok-keyword">this</span>.place) <span class="tok-keyword">return</span> p;
        <span class="tok-keyword">return</span> {<span class="tok-definition">place</span>: destination, <span class="tok-definition">address</span>: p.address};
      }).filter(<span class="tok-definition">p</span> =&gt; p.place != p.address);
      <span class="tok-keyword">return</span> <span class="tok-keyword">new</span> VillageState(destination, parcels);
    }
  }
}</pre>

<p><a class="p_ident" id="p-dEEiTFRt0X" href="#p-dEEiTFRt0X" tabindex="-1" role="presentation"></a>El m√©todo <code>move</code> es donde ocurre la acci√≥n. Primero verifica si hay un camino desde el lugar actual hasta el destino, y si no lo hay, devuelve el estado anterior ya que este no es un movimiento v√°lido.</p>

<p><a class="p_ident" id="p-YeKbjqCqtC" href="#p-YeKbjqCqtC" tabindex="-1" role="presentation"></a>Luego crea un nuevo estado con el destino como el nuevo lugar del robot. Pero tambi√©n necesita crear un nuevo conjunto de paquetes: los paquetes que lleva el robot (que est√°n en el lugar actual del robot) deben ser trasladados al nuevo lugar. Y los paquetes dirigidos al nuevo lugar deben ser entregados, es decir, deben ser eliminados del conjunto de paquetes no entregados. La llamada a <code>map</code> se encarga del traslado y la llamada a <code>filter</code> de la entrega.</p>

<p><a class="p_ident" id="p-3lMuPCNKYP" href="#p-3lMuPCNKYP" tabindex="-1" role="presentation"></a>Los objetos de parcela no se modifican cuando se mueven, sino que se vuelven a crear. El m√©todo <code>move</code> nos proporciona un nuevo estado de aldea pero deja intacto por completo el anterior.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-rRgQCtG7hr" href="#c-rRgQCtG7hr" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">first</span> = <span class="tok-keyword">new</span> VillageState(
  <span class="tok-string">&quot;Oficina de Correos&quot;</span>,
  [{<span class="tok-definition">place</span>: <span class="tok-string">&quot;Oficina de Correos&quot;</span>, <span class="tok-definition">address</span>: <span class="tok-string">&quot;Casa de Alice&quot;</span>}]
);
<span class="tok-keyword">let</span> <span class="tok-definition">next</span> = first.move(<span class="tok-string">&quot;Casa de Alice&quot;</span>);

console.log(next.place);
<span class="tok-comment">// ‚Üí Casa de Alice</span>
console.log(next.parcels);
<span class="tok-comment">// ‚Üí []</span>
console.log(first.place);
<span class="tok-comment">// ‚Üí Oficina de Correos</span></pre>

<p><a class="p_ident" id="p-Myxbdg6oBC" href="#p-Myxbdg6oBC" tabindex="-1" role="presentation"></a>El movimiento hace que la parcela se entregue, y esto se refleja en el siguiente estado. Pero el estado inicial sigue describiendo la situaci√≥n en la que el robot est√° en la oficina de correos y la parcela no se ha entregado.</p>

<h2><a class="h_ident" id="h-TZqUeD/4Kg" href="#h-TZqUeD/4Kg" tabindex="-1" role="presentation"></a>Datos persistentes</h2>

<p><a class="p_ident" id="p-FhP/ZMbXxd" href="#p-FhP/ZMbXxd" tabindex="-1" role="presentation"></a>Las estructuras de datos que no cambian se llaman <em>inmutables</em> o <em>persistentes</em>. Se comportan de manera similar a las cadenas de texto y los n√∫meros en el sentido de que son lo que son y se mantienen as√≠, en lugar de contener cosas diferentes en momentos diferentes.</p>

<p><a class="p_ident" id="p-jM2h5YhXld" href="#p-jM2h5YhXld" tabindex="-1" role="presentation"></a>En JavaScript, casi todo <em>puede</em> cambiarse, por lo que trabajar con valores que se supone que son persistentes requiere cierta moderaci√≥n. Existe una funci√≥n llamada <code>Object.freeze</code> que cambia un objeto para que la escritura en sus propiedades sea ignorada. Podr√≠as usar esto para asegurarte de que tus objetos no se modifiquen, si as√≠ lo deseas. Congelar requiere que la computadora realice un trabajo adicional, y que las actualizaciones se ignoren es casi tan propenso a confundir a alguien como hacer que hagan lo incorrecto. Por lo tanto, suelo preferir simplemente decirle a las personas que un objeto dado no debe ser modificado y esperar que lo recuerden.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-tzmey+74SE" href="#c-tzmey+74SE" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">object</span> = Object.freeze({<span class="tok-definition">value</span>: <span class="tok-number">5</span>});
object.value = <span class="tok-number">10</span>;
console.log(object.value);
<span class="tok-comment">// ‚Üí 5</span></pre>

<p><a class="p_ident" id="p-3ZcXSzHegg" href="#p-3ZcXSzHegg" tabindex="-1" role="presentation"></a>¬øPor qu√© me estoy esforzando tanto en no cambiar los objetos cuando el lenguaje obviamente espera que lo haga?</p>

<p><a class="p_ident" id="p-1ihsgYZ82c" href="#p-1ihsgYZ82c" tabindex="-1" role="presentation"></a>Porque me ayuda a entender mis programas. Una vez m√°s, esto se trata de gestionar la complejidad. Cuando los objetos en mi sistema son cosas fijas y estables, puedo considerar operaciones sobre ellos de forma aislada: moverse a la casa de Alice desde un estado inicial dado siempre produce el mismo nuevo estado. Cuando los objetos cambian con el tiempo, eso a√±ade toda una nueva dimensi√≥n de complejidad a este tipo de razonamiento.</p>

<p><a class="p_ident" id="p-FW5kl43Zwa" href="#p-FW5kl43Zwa" tabindex="-1" role="presentation"></a>Para un sistema peque√±o como el que estamos construyendo en este cap√≠tulo, podr√≠amos manejar ese poco de complejidad extra. Pero el l√≠mite m√°s importante respecto a qu√© tipo de sistemas podemos construir es cu√°nto podemos entender. Cualquier cosa que haga que tu c√≥digo sea m√°s f√°cil de entender te permite construir un sistema m√°s ambicioso.</p>

<p><a class="p_ident" id="p-T1HGdD5GjP" href="#p-T1HGdD5GjP" tabindex="-1" role="presentation"></a>Desafortunadamente, aunque entender un sistema construido sobre estructuras de datos persistentes es m√°s f√°cil, <em>dise√±ar</em> uno, especialmente cuando tu lenguaje de programaci√≥n no ayuda, puede ser un poco m√°s dif√≠cil. Buscaremos oportunidades para usar estructuras de datos persistentes en este libro, pero tambi√©n usaremos aquellas que pueden cambiar.</p>

<h2><a class="h_ident" id="h-NngWObDYaj" href="#h-NngWObDYaj" tabindex="-1" role="presentation"></a>Simulaci√≥n</h2>

<p><a class="p_ident" id="p-Lt1p8txGDL" href="#p-Lt1p8txGDL" tabindex="-1" role="presentation"></a>Un robot de entrega observa el mundo y decide en qu√© direcci√≥n quiere moverse. Como tal, podr√≠amos decir que un robot es una funci√≥n que toma un objeto <code>VillageState</code> y devuelve el nombre de un lugar cercano.</p>

<p><a class="p_ident" id="p-pbn2tWD1Al" href="#p-pbn2tWD1Al" tabindex="-1" role="presentation"></a>Dado que queremos que los robots puedan recordar cosas, para que puedan hacer y ejecutar planes, tambi√©n les pasamos su memoria y les permitimos devolver una nueva memoria. Por lo tanto, lo que un robot devuelve es un objeto que contiene tanto la direcci√≥n en la que quiere moverse como un valor de memoria que se le dar√° la pr√≥xima vez que se llame.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-M0YJHfzoXC" href="#c-M0YJHfzoXC" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">runRobot</span>(<span class="tok-definition">state</span>, <span class="tok-definition">robot</span>, <span class="tok-definition">memory</span>) {
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">turn</span> = <span class="tok-number">0</span>;; turn++) {
    <span class="tok-keyword">if</span> (state.parcels.length == <span class="tok-number">0</span>) {
      console.log(<span class="tok-string2">`Terminado en </span>${turn}<span class="tok-string2"> turnos`</span>);
      <span class="tok-keyword">break</span>;
    }
    <span class="tok-keyword">let</span> <span class="tok-definition">action</span> = robot(state, memory);
    state = state.move(action.direction);
    memory = action.memory;
    console.log(<span class="tok-string2">`Movido a </span>${action.direction}<span class="tok-string2">`</span>);
  }
}</pre>

<p><a class="p_ident" id="p-UhOLqafDmo" href="#p-UhOLqafDmo" tabindex="-1" role="presentation"></a>Consideremos lo que un robot tiene que hacer para ‚Äúresolver‚Äù un estado dado. Debe recoger todos los paquetes visitando cada ubicaci√≥n que tenga un paquete y entregarlos visitando cada ubicaci√≥n a la que est√© dirigido un paquete, pero solo despu√©s de recoger el paquete.</p>

<p><a class="p_ident" id="p-5bsdqun/8W" href="#p-5bsdqun/8W" tabindex="-1" role="presentation"></a>¬øCu√°l es la estrategia m√°s tonta que podr√≠a funcionar? El robot podr√≠a simplemente caminar en una direcci√≥n aleatoria en cada turno. Eso significa que, con gran probabilidad, eventualmente se topar√° con todos los paquetes y en alg√∫n momento tambi√©n llegar√° al lugar donde deben ser entregados.</p>

<p><a class="p_ident" id="p-SlxnfWOsG9" href="#p-SlxnfWOsG9" tabindex="-1" role="presentation"></a>Esto es c√≥mo podr√≠a lucir eso:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-eldzpwzhOB" href="#c-eldzpwzhOB" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">randomPick</span>(<span class="tok-definition">array</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">choice</span> = Math.floor(Math.random() * array.length);
  <span class="tok-keyword">return</span> array[choice];
}

<span class="tok-keyword">function</span> <span class="tok-definition">randomRobot</span>(<span class="tok-definition">state</span>) {
  <span class="tok-keyword">return</span> {<span class="tok-definition">direction</span>: randomPick(roadGraph[state.place])};
}</pre>

<p><a class="p_ident" id="p-iGtbW23NAf" href="#p-iGtbW23NAf" tabindex="-1" role="presentation"></a>Recuerda que <code>Math.random()</code> devuelve un n√∫mero entre cero y uno, pero siempre por debajo de uno. Multiplicar dicho n√∫mero por la longitud de un array y luego aplicarle <code>Math.floor</code> nos da un √≠ndice aleatorio para el array.</p>

<p><a class="p_ident" id="p-/n/qSIuoNM" href="#p-/n/qSIuoNM" tabindex="-1" role="presentation"></a>Dado que este robot no necesita recordar nada, ignora su segundo argumento (recuerda que las funciones de JavaScript pueden ser llamadas con argumentos adicionales sin efectos adversos) y omite la propiedad <code>memory</code> en su objeto devuelto.</p>

<p><a class="p_ident" id="p-TMVPaShA18" href="#p-TMVPaShA18" tabindex="-1" role="presentation"></a>Para poner a trabajar a este sofisticado robot, primero necesitaremos una forma de crear un nuevo estado con algunos paquetes. Un m√©todo est√°tico (escrito aqu√≠ a√±adiendo directamente una propiedad al constructor) es un buen lugar para poner esa funcionalidad.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-SEyJ7YaifO" href="#c-SEyJ7YaifO" tabindex="-1" role="presentation"></a>VillageState.random = <span class="tok-keyword">function</span>(<span class="tok-definition">parcelCount</span> = <span class="tok-number">5</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">parcels</span> = [];
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">i</span> = <span class="tok-number">0</span>; i &lt; parcelCount; i++) {
    <span class="tok-keyword">let</span> <span class="tok-definition">address</span> = randomPick(Object.keys(roadGraph));
    <span class="tok-keyword">let</span> <span class="tok-definition">place</span>;
    <span class="tok-keyword">do</span> {
      place = randomPick(Object.keys(roadGraph));
    } <span class="tok-keyword">while</span> (place == address);
    parcels.push({<span class="tok-definition">place</span>, <span class="tok-definition">address</span>});
  }
  <span class="tok-keyword">return</span> <span class="tok-keyword">new</span> VillageState(<span class="tok-string">&quot;Oficina de Correos&quot;</span>, parcels);
};</pre>

<p><a class="p_ident" id="p-sT2UJuipJb" href="#p-sT2UJuipJb" tabindex="-1" role="presentation"></a>No queremos ning√∫n paquete que sea enviado desde el mismo lugar al que est√° dirigido. Por esta raz√≥n, el bucle <code>do</code> sigue eligiendo nuevos lugares cuando obtiene uno que es igual a la direcci√≥n.</p>

<p><a class="p_ident" id="p-3CXgjiC8tx" href="#p-3CXgjiC8tx" tabindex="-1" role="presentation"></a>Vamos a iniciar un mundo virtual.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Ibn5l8fm0j" href="#c-Ibn5l8fm0j" tabindex="-1" role="presentation"></a>runRobot(VillageState.random(), randomRobot);
<span class="tok-comment">// ‚Üí Movido a Mercado</span>
<span class="tok-comment">// ‚Üí Movido a Ayuntamiento</span>
<span class="tok-comment">// ‚Üí ‚Ä¶</span>
<span class="tok-comment">// ‚Üí Terminado en 63 turnos</span></pre>

<p><a class="p_ident" id="p-VLRaDqy2QY" href="#p-VLRaDqy2QY" tabindex="-1" role="presentation"></a>Al robot le lleva muchas vueltas entregar los paquetes porque no est√° planificando muy bien. Abordaremos eso pronto.</p>

<p><a class="p_ident" id="p-LTO+75V071" href="#p-LTO+75V071" tabindex="-1" role="presentation"></a>Para tener una perspectiva m√°s agradable de la simulaci√≥n, puedes usar la funci√≥n <code>runRobotAnimation</code> que est√° disponible en <a href="https://eloquentjavascript.net/code/#7">el entorno de programaci√≥n de este cap√≠tulo</a>. Esto ejecuta la simulaci√≥n, pero en lugar de mostrar texto, te muestra al robot movi√©ndose por el mapa del pueblo.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-jWQlJ73x2Z" href="#c-jWQlJ73x2Z" tabindex="-1" role="presentation"></a>runRobotAnimation(VillageState.random(), randomRobot);</pre>

<p><a class="p_ident" id="p-wTfPDt+D+s" href="#p-wTfPDt+D+s" tabindex="-1" role="presentation"></a>La forma en que <code>runRobotAnimation</code> est√° implementada permanecer√° como un misterio por ahora, pero despu√©s de que hayas le√≠do los <a href="14_dom.html">cap√≠tulos posteriores</a> de este libro, que tratan sobre la integraci√≥n de JavaScript en los navegadores web, podr√°s adivinar c√≥mo funciona.</p>

<h2><a class="h_ident" id="h-Gn9gM3o6mE" href="#h-Gn9gM3o6mE" tabindex="-1" role="presentation"></a>Ruta del cami√≥n de correo</h2>

<p><a class="p_ident" id="p-MP2rZBcQkl" href="#p-MP2rZBcQkl" tabindex="-1" role="presentation"></a>Deber√≠amos poder hacerlo mucho mejor que el robot aleatorio. Una mejora sencilla ser√≠a inspirarnos en la forma en que funciona la entrega de correo en el mundo real. Si encontramos una ruta que pase por todos los lugares del pueblo, el robot podr√≠a recorrer esa ruta dos veces, momento en que se garantizar√≠a que ha terminado. Aqu√≠ tienes una de esas rutas (comenzando desde la oficina de correos):</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-yxJq9tnQ+4" href="#c-yxJq9tnQ+4" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">mailRoute</span> = [
  <span class="tok-string">&quot;Casa de Alice&quot;</span>, <span class="tok-string">&quot;Caba√±a&quot;</span>, <span class="tok-string">&quot;Casa de Alice&quot;</span>, <span class="tok-string">&quot;Casa de Bob&quot;</span>,
  <span class="tok-string">&quot;Ayuntamiento&quot;</span>, <span class="tok-string">&quot;Casa de Daria&quot;</span>, <span class="tok-string">&quot;Casa de Ernie&quot;</span>,
  <span class="tok-string">&quot;Casa de Grete&quot;</span>, <span class="tok-string">&quot;Tienda&quot;</span>, <span class="tok-string">&quot;Casa de Grete&quot;</span>, <span class="tok-string">&quot;Granja&quot;</span>,
  <span class="tok-string">&quot;Plaza del Mercado&quot;</span>, <span class="tok-string">&quot;Oficina de Correos&quot;</span>
];</pre>

<p><a class="p_ident" id="p-NuQQdtHsp+" href="#p-NuQQdtHsp+" tabindex="-1" role="presentation"></a>Para implementar el robot que sigue la ruta, necesitaremos hacer uso de la memoria del robot. El robot guarda el resto de su ruta en su memoria y deja caer el primer elemento en cada turno.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-FlV5rBgCYM" href="#c-FlV5rBgCYM" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">routeRobot</span>(<span class="tok-definition">state</span>, <span class="tok-definition">memory</span>) {
  <span class="tok-keyword">if</span> (memory.length == <span class="tok-number">0</span>) {
    memory = mailRoute;
  }
  <span class="tok-keyword">return</span> {<span class="tok-definition">direction</span>: memory[<span class="tok-number">0</span>], <span class="tok-definition">memory</span>: memory.slice(<span class="tok-number">1</span>)};
}</pre>

<p><a class="p_ident" id="p-UTRfqLt//8" href="#p-UTRfqLt//8" tabindex="-1" role="presentation"></a>Este robot es mucho m√°s r√°pido ya. Tomar√° un m√°ximo de 26 vueltas (el doble de la ruta de 13 pasos) pero generalmente menos.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-EkwtJVsUrQ" href="#c-EkwtJVsUrQ" tabindex="-1" role="presentation"></a>runRobotAnimation(VillageState.random(), routeRobot, []);</pre>

<h2><a class="h_ident" id="h-Qr/SzElzir" href="#h-Qr/SzElzir" tabindex="-1" role="presentation"></a>B√∫squeda de caminos</h2>

<p><a class="p_ident" id="p-+h0jpYRuOH" href="#p-+h0jpYRuOH" tabindex="-1" role="presentation"></a>A√∫n as√≠, no llamar√≠a a seguir ciegamente una ruta fija un comportamiento inteligente. Ser√≠a m√°s eficiente si el robot ajustara su comportamiento a la tarea real que debe realizarse.</p>

<p><a class="p_ident" id="p-Qq4JUaMcE0" href="#p-Qq4JUaMcE0" tabindex="-1" role="presentation"></a>Para hacer eso, tiene que poder moverse deliberadamente hacia un paquete dado o hacia la ubicaci√≥n donde se debe entregar un paquete. Hacer eso, incluso cuando el objetivo est√° a m√°s de un movimiento de distancia, requerir√° alg√∫n tipo de funci√≥n de b√∫squeda de ruta.</p>

<p><a class="p_ident" id="p-PxJJwn/RDt" href="#p-PxJJwn/RDt" tabindex="-1" role="presentation"></a>El problema de encontrar una ruta a trav√©s de un grafo es un <em>problema de b√∫squeda</em> t√≠pico. Podemos determinar si una soluci√≥n dada (una ruta) es una soluci√≥n v√°lida, pero no podemos calcular directamente la soluci√≥n como podr√≠amos hacerlo para 2 + 2. En su lugar, debemos seguir creando soluciones potenciales hasta encontrar una que funcione.</p>

<p><a class="p_ident" id="p-shDyhu90T5" href="#p-shDyhu90T5" tabindex="-1" role="presentation"></a>El n√∫mero de rutas posibles a trav√©s de un grafo es infinito. Pero al buscar una ruta de <em>A</em> a <em>B</em>, solo estamos interesados en aquellas que comienzan en <em>A</em>. Adem√°s, no nos importan las rutas que visiten el mismo lugar dos veces, esas definitivamente no son las rutas m√°s eficientes en ning√∫n lugar. As√≠ que eso reduce la cantidad de rutas que el buscador de rutas debe considerar.De hecho, estamos mayormente interesados en la ruta <em>m√°s corta</em>. Por lo tanto, queremos asegurarnos de buscar rutas cortas antes de mirar las m√°s largas. Un buen enfoque ser√≠a ‚Äúexpandir‚Äù rutas desde el punto de inicio, explorando cada lugar alcanzable que a√∫n no haya sido visitado, hasta que una ruta llegue al objetivo. De esta manera, solo exploraremos rutas que sean potencialmente interesantes, y sabremos que la primera ruta que encontremos es la ruta m√°s corta (o una de las rutas m√°s cortas, si hay m√°s de una).</p>

<p id="findRoute"><a class="p_ident" id="p-HzB02WYPFY" href="#p-HzB02WYPFY" tabindex="-1" role="presentation"></a>Aqu√≠ hay una funci√≥n que hace esto:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-qT/+IETEgM" href="#c-qT/+IETEgM" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">findRoute</span>(<span class="tok-definition">graph</span>, <span class="tok-definition">from</span>, <span class="tok-definition">to</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">work</span> = [{<span class="tok-definition">at</span>: from, <span class="tok-definition">route</span>: []}];
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">i</span> = <span class="tok-number">0</span>; i &lt; work.length; i++) {
    <span class="tok-keyword">let</span> {at, route} = work[i];
    <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">place</span> <span class="tok-keyword">of</span> graph[at]) {
      <span class="tok-keyword">if</span> (place == to) <span class="tok-keyword">return</span> route.concat(place);
      <span class="tok-keyword">if</span> (!work.some(<span class="tok-definition">w</span> =&gt; w.at == place)) {
        work.push({<span class="tok-definition">at</span>: place, <span class="tok-definition">route</span>: route.concat(place)});
      }
    }
  }
}</pre>

<p><a class="p_ident" id="p-xVUWEP9k6b" href="#p-xVUWEP9k6b" tabindex="-1" role="presentation"></a>La exploraci√≥n debe realizarse en el orden correcto: los lugares que se alcanzaron primero deben explorarse primero. No podemos explorar de inmediato un lugar tan pronto como lleguemos a √©l porque eso significar√≠a que los lugares alcanzados <em>desde all√≠</em> tambi√©n se explorar√≠an de inmediato, y as√≠ sucesivamente, incluso si puede haber otros caminos m√°s cortos que a√∫n no se han explorado.</p>

<p><a class="p_ident" id="p-9iy0XgVHaG" href="#p-9iy0XgVHaG" tabindex="-1" role="presentation"></a>Por lo tanto, la funci√≥n mantiene una <em>lista de trabajo</em>. Esta es una matriz de lugares que deben ser explorados a continuaci√≥n, junto con la ruta que nos llev√≥ all√≠. Comienza con solo la posici√≥n de inicio y una ruta vac√≠a.</p>

<p><a class="p_ident" id="p-vY5At+m4ct" href="#p-vY5At+m4ct" tabindex="-1" role="presentation"></a>La b√∫squeda luego opera tomando el siguiente elemento en la lista y explor√°ndolo, lo que significa que se ven todas las rutas que salen de ese lugar. Si una de ellas es el objetivo, se puede devolver una ruta terminada. De lo contrario, si no hemos mirado este lugar antes, se agrega un nuevo elemento a la lista. Si lo hemos mirado antes, dado que estamos buscando rutas cortas primero, hemos encontrado o bien una ruta m√°s larga a ese lugar o una exactamente tan larga como la existente, y no necesitamos explorarla.</p>

<p><a class="p_ident" id="p-nSmvyFJjX5" href="#p-nSmvyFJjX5" tabindex="-1" role="presentation"></a>Puedes imaginar visualmente esto como una red de rutas conocidas que se extienden desde la ubicaci√≥n de inicio, creciendo de manera uniforme en todos los lados (pero nunca enred√°ndose de nuevo en s√≠ misma). Tan pronto como el primer hilo alcance la ubicaci√≥n objetivo, ese hilo se rastrea de vuelta al inicio, d√°ndonos nuestra ruta.</p>

<p><a class="p_ident" id="p-8xtuFs30lw" href="#p-8xtuFs30lw" tabindex="-1" role="presentation"></a>Nuestro c√≥digo no maneja la situaci√≥n en la que no hay m√°s elementos de trabajo en la lista de trabajo porque sabemos que nuestro gr√°fico est√° <em>conectado</em>, lo que significa que se puede llegar a cada ubicaci√≥n desde todas las dem√°s ubicaciones. Siempre podremos encontrar una ruta entre dos puntos, y la b√∫squeda no puede fallar.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-RJgvG9cgxq" href="#c-RJgvG9cgxq" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">goalOrientedRobot</span>({place, parcels}, <span class="tok-definition">route</span>) {
  <span class="tok-keyword">if</span> (route.length == <span class="tok-number">0</span>) {
    <span class="tok-keyword">let</span> <span class="tok-definition">parcel</span> = parcels[<span class="tok-number">0</span>];
    <span class="tok-keyword">if</span> (parcel.place != place) {
      route = findRoute(roadGraph, place, parcel.place);
    } <span class="tok-keyword">else</span> {
      route = findRoute(roadGraph, place, parcel.address);
    }
  }
  <span class="tok-keyword">return</span> {<span class="tok-definition">direction</span>: route[<span class="tok-number">0</span>], <span class="tok-definition">memory</span>: route.slice(<span class="tok-number">1</span>)};
}</pre>

<p><a class="p_ident" id="p-SgSFCewRHC" href="#p-SgSFCewRHC" tabindex="-1" role="presentation"></a>Este robot utiliza el valor de su memoria como una lista de direcciones en las que moverse, al igual que el robot que sigue la ruta. Cuando esa lista est√° vac√≠a, debe averiguar qu√© hacer a continuaci√≥n. Toma el primer paquete no entregado del conjunto y, si ese paquete a√∫n no ha sido recogido, traza una ruta hacia √©l. Si el paquete ya ha sido recogido, todav√≠a necesita ser entregado, por lo que el robot crea una ruta hacia la direcci√≥n de entrega.</p>

<p><a class="p_ident" id="p-HSmURF+mCI" href="#p-HSmURF+mCI" tabindex="-1" role="presentation"></a>Veamos c√≥mo lo hace.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-yYuNlgXLX9" href="#c-yYuNlgXLX9" tabindex="-1" role="presentation"></a>runRobotAnimation(VillageState.random(),
                  goalOrientedRobot, []);</pre>

<p><a class="p_ident" id="p-+YpJ1wVO73" href="#p-+YpJ1wVO73" tabindex="-1" role="presentation"></a>Este robot suele terminar la tarea de entregar 5 paquetes en aproximadamente 16 turnos. Eso es ligeramente mejor que <code>routeRobot</code> pero definitivamente no es √≥ptimo.</p>

<h2><a class="h_ident" id="h-tkm7ntLto1" href="#h-tkm7ntLto1" tabindex="-1" role="presentation"></a>Ejercicios</h2>

<h3><a class="i_ident" id="i-nSYnmkjC8T" href="#i-nSYnmkjC8T" tabindex="-1" role="presentation"></a>Medici√≥n de un robot</h3>

<p><a class="p_ident" id="p-lyukeUuD6v" href="#p-lyukeUuD6v" tabindex="-1" role="presentation"></a>Es dif√≠cil comparar de manera objetiva los robots solo dejando que resuelvan algunos escenarios. Tal vez un robot simplemente tuvo tareas m√°s f√°ciles o el tipo de tareas en las que es bueno, mientras que el otro no.</p>

<p><a class="p_ident" id="p-vvltSTdEem" href="#p-vvltSTdEem" tabindex="-1" role="presentation"></a>Escribe una funci√≥n <code>compareRobots</code> que tome dos robots (y su memoria inicial). Deber√≠a generar 100 tareas y permitir que cada uno de los robots resuelva cada una de estas tareas. Cuando termine, deber√≠a mostrar el n√∫mero promedio de pasos que cada robot dio por tarea.</p>

<p><a class="p_ident" id="p-Y+3Np8UuLO" href="#p-Y+3Np8UuLO" tabindex="-1" role="presentation"></a>Por el bien de la equidad, aseg√∫rate de darle a cada tarea a ambos robots, en lugar de generar tareas diferentes por robot.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-kWSW2DNAYZ" href="#c-kWSW2DNAYZ" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">compareRobots</span>(<span class="tok-definition">robot1</span>, <span class="tok-definition">memory1</span>, <span class="tok-definition">robot2</span>, <span class="tok-definition">memory2</span>) {
  <span class="tok-comment">// Tu c√≥digo aqu√≠</span>
}

compareRobots(routeRobot, [], goalOrientedRobot, []);</pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-kcCXvCKFts" href="#p-kcCXvCKFts" tabindex="-1" role="presentation"></a>Tendr√°s que escribir una variante de la funci√≥n <code>runRobot</code> que, en lugar de registrar los eventos en la consola, devuelva el n√∫mero de pasos que el robot tom√≥ para completar la tarea.</p>

<p><a class="p_ident" id="p-Xr248zBbAN" href="#p-Xr248zBbAN" tabindex="-1" role="presentation"></a>Tu funci√≥n de medici√≥n puede, entonces, en un bucle, generar nuevos estados y contar los pasos que toma cada uno de los robots. Cuando haya generado suficientes mediciones, puede usar <code>console.log</code> para mostrar el promedio de cada robot, que es el n√∫mero total de pasos tomados dividido por el n√∫mero de mediciones.</p>

</div></details>

<h3><a class="i_ident" id="i-XtZPo4zIj3" href="#i-XtZPo4zIj3" tabindex="-1" role="presentation"></a>Eficiencia del robot</h3>

<p><a class="p_ident" id="p-ekiPq8jgZ7" href="#p-ekiPq8jgZ7" tabindex="-1" role="presentation"></a>¬øPuedes escribir un robot que termine la tarea de entrega m√°s r√°pido que <code>goalOrientedRobot</code>? Si observas el comportamiento de ese robot, ¬øqu√© cosas claramente absurdas hace? ¬øC√≥mo podr√≠an mejorarse?</p>

<p><a class="p_ident" id="p-WHsjtdy1wY" href="#p-WHsjtdy1wY" tabindex="-1" role="presentation"></a>Si resolviste el ejercicio anterior, es posible que desees utilizar tu funci√≥n <code>compareRobots</code> para verificar si mejoraste el robot.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-20FhVkI8K3" href="#c-20FhVkI8K3" tabindex="-1" role="presentation"></a><span class="tok-comment">// Tu c√≥digo aqu√≠</span>

runRobotAnimation(VillageState.random(), tuRobot, memoria);</pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-sRXTWyzdOx" href="#p-sRXTWyzdOx" tabindex="-1" role="presentation"></a>La principal limitaci√≥n de <code>goalOrientedRobot</code> es que solo considera un paquete a la vez. A menudo caminar√° de un lado a otro del pueblo porque el paquete en el que est√° centrando su atenci√≥n sucede que est√° en el otro lado del mapa, incluso si hay otros mucho m√°s cerca.</p>

<p><a class="p_ident" id="p-h8Mq8+DtKj" href="#p-h8Mq8+DtKj" tabindex="-1" role="presentation"></a>Una posible soluci√≥n ser√≠a calcular rutas para todos paquetes y luego tomar la m√°s corta. Se pueden obtener resultados a√∫n mejores, si hay m√∫ltiples rutas m√°s cortas, al preferir aquellas que van a recoger un paquete en lugar de entregarlo.</p>

</div></details>

<h3><a class="i_ident" id="i-4PUyGyQ+OK" href="#i-4PUyGyQ+OK" tabindex="-1" role="presentation"></a>Grupo persistente</h3>

<p><a class="p_ident" id="p-m/Epe5YFy9" href="#p-m/Epe5YFy9" tabindex="-1" role="presentation"></a>La mayor√≠a de las estructuras de datos proporcionadas en un entorno est√°ndar de JavaScript no son muy adecuadas para un uso persistente. Los Arrays tienen m√©todos <code>slice</code> y <code>concat</code>, que nos permiten crear f√°cilmente nuevos arrays sin da√±ar el antiguo. Pero <code>Set</code>, por ejemplo, no tiene m√©todos para crear un nuevo conjunto con un elemento a√±adido o eliminado.</p>

<p><a class="p_ident" id="p-b4vxX/99GB" href="#p-b4vxX/99GB" tabindex="-1" role="presentation"></a>Escribe una nueva clase <code>PGroup</code>, similar a la clase <code>Grupo</code> del <a href="06_object.html#groups">Cap√≠tulo 6</a>, que almacena un conjunto de valores. Al igual que <code>Grupo</code>, tiene m√©todos <code>add</code>, <code>delete</code>, y <code>has</code>.</p>

<p><a class="p_ident" id="p-3XYr611b0/" href="#p-3XYr611b0/" tabindex="-1" role="presentation"></a>Sin embargo, su m√©todo <code>add</code> deber√≠a devolver una <em>nueva</em> instancia de <code>PGroup</code> con el miembro dado a√±adido y dejar la anterior sin cambios. De manera similar, <code>delete</code> crea una nueva instancia sin un miembro dado.</p>

<p><a class="p_ident" id="p-OqTz+KTGUf" href="#p-OqTz+KTGUf" tabindex="-1" role="presentation"></a>La clase deber√≠a funcionar para valores de cualquier tipo, no solo para strings. No tiene que ser eficiente cuando se utiliza con grandes cantidades de valores.</p>

<p><a class="p_ident" id="p-xZHWaBEuTQ" href="#p-xZHWaBEuTQ" tabindex="-1" role="presentation"></a>El constructor no deber√≠a ser parte de la interfaz de la clase (aunque definitivamente querr√°s usarlo internamente). En su lugar, hay una instancia vac√≠a, <code>PGroup.empty</code>, que se puede usar como valor inicial.</p>

<p><a class="p_ident" id="p-G0rIQr0dv6" href="#p-G0rIQr0dv6" tabindex="-1" role="presentation"></a>¬øPor qu√© necesitas solo un valor <code>PGroup.empty</code>, en lugar de tener una funci√≥n que cree un nuevo mapa vac√≠o cada vez?</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-3WddMCmfM4" href="#c-3WddMCmfM4" tabindex="-1" role="presentation"></a><span class="tok-keyword">class</span> PGroup {
  <span class="tok-comment">// Tu c√≥digo aqu√≠</span>
}

<span class="tok-keyword">let</span> <span class="tok-definition">a</span> = PGroup.empty.add(<span class="tok-string">&quot;a&quot;</span>);
<span class="tok-keyword">let</span> <span class="tok-definition">ab</span> = a.add(<span class="tok-string">&quot;b&quot;</span>);
<span class="tok-keyword">let</span> <span class="tok-definition">b</span> = ab.delete(<span class="tok-string">&quot;a&quot;</span>);

console.log(b.has(<span class="tok-string">&quot;b&quot;</span>));
<span class="tok-comment">// ‚Üí true</span>
console.log(a.has(<span class="tok-string">&quot;b&quot;</span>));
<span class="tok-comment">// ‚Üí false</span>
console.log(b.has(<span class="tok-string">&quot;a&quot;</span>));
<span class="tok-comment">// ‚Üí false</span></pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-8KXK9HpVPD" href="#p-8KXK9HpVPD" tabindex="-1" role="presentation"></a>La forma m√°s conveniente de representar el conjunto de valores miembro sigue siendo como un array, ya que los arrays son f√°ciles de copiar.</p>

<p><a class="p_ident" id="p-5syhZ/mTkb" href="#p-5syhZ/mTkb" tabindex="-1" role="presentation"></a>Cuando se a√±ade un valor al grupo, puedes crear un nuevo grupo con una copia del array original que tenga el valor a√±adido (por ejemplo, usando <code>concat</code>). Cuando se elimina un valor, puedes filtrarlo del array.</p>

<p><a class="p_ident" id="p-8sn5vlOB4z" href="#p-8sn5vlOB4z" tabindex="-1" role="presentation"></a>El constructor de la clase puede tomar dicho array como argumento y almacenarlo como propiedad √∫nica de la instancia. Este array nunca se actualiza.</p>

<p><a class="p_ident" id="p-2Pl6kVkkBf" href="#p-2Pl6kVkkBf" tabindex="-1" role="presentation"></a>Para a√±adir la propiedad <code>empty</code> al constructor, puedes declararla como una propiedad est√°tica.</p>

<p><a class="p_ident" id="p-ELnDcpRm2E" href="#p-ELnDcpRm2E" tabindex="-1" role="presentation"></a>Solo necesitas una instancia <code>empty</code> porque todos los grupos vac√≠os son iguales y las instancias de la clase no cambian. Puedes crear muchos grupos diferentes a partir de ese √∫nico grupo vac√≠o sin afectarlo.</p>

</div></details><nav><a href="06_object.html" title="previous chapter" aria-label="previous chapter">‚óÇ</a>¬†<a href="index.html" title="cover" aria-label="cover">‚óè</a>¬†<a href="08_error.html" title="next chapter" aria-label="next chapter">‚ñ∏</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>&nbsp;<button class="dark-mode-toggle">üåô</button>
</nav>
</article>

<script src="ejs.js"></script>
