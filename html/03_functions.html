<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Funciones :: Eloquent JavaScript</title>
  <link rel=stylesheet href="css/ejs.css"><script>
      var page = {"type":"chapter","number":3}</script></head>

<article>
<nav><a href="02_program_structure.html" title="previous chapter" aria-label="previous chapter">‚óÇ</a>¬†<a href="index.html" title="cover" aria-label="cover">‚óè</a>¬†<a href="04_data.html" title="next chapter" aria-label="next chapter">‚ñ∏</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>&nbsp;<button class="dark-mode-toggle">üåô</button>
</nav>

<h1>Funciones</h1>

<blockquote>

<p><a class="p_ident" id="p-SZ6RJ5C7yk" href="#p-SZ6RJ5C7yk" tabindex="-1" role="presentation"></a>La gente piensa que la inform√°tica es el arte de los genios, pero la realidad actual es la opuesta, simplemente muchas personas haciendo cosas que se construyen unas sobre otras, como un muro de mini piedras.</p>

<footer>Donald Knuth</footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_3.jpg" alt="Ilustraci√≥n de hojas de helecho con una forma fractal, abejas en el fondo"></figure>

<p><a class="p_ident" id="p-CgSvbtVPMF" href="#p-CgSvbtVPMF" tabindex="-1" role="presentation"></a>Las funciones son una de las herramientas m√°s centrales en la programaci√≥n en JavaScript. El concepto de envolver un fragmento de programa en un valor tiene muchos usos. Nos proporciona una manera de estructurar programas m√°s grandes, de reducir la repetici√≥n, de asociar nombres con subprogramas y de aislar estos subprogramas entre s√≠.</p>

<p><a class="p_ident" id="p-5S1r7LDeWB" href="#p-5S1r7LDeWB" tabindex="-1" role="presentation"></a>La aplicaci√≥n m√°s evidente de las funciones es definir nuevo vocabulario. Crear palabras nuevas en el lenguaje escrito suele ser de mal gusto, pero en programaci√≥n es indispensable.</p>

<p><a class="p_ident" id="p-9hTHeO/PZx" href="#p-9hTHeO/PZx" tabindex="-1" role="presentation"></a>Los hablantes de ingl√©s adultos t√≠picos tienen alrededor de 20,000 palabras en su vocabulario. Pocos lenguajes de programaci√≥n vienen con 20,000 comandos incorporados. Y el vocabulario que <em>est√°</em> disponible tiende a estar m√°s precisamente definido, y por lo tanto menos flexible, que en el lenguaje humano. Por lo tanto, <em>tenemos</em> que introducir nuevas palabras para evitar la verbosidad excesiva.</p>

<h2><a class="h_ident" id="h-eHXd+T1Ezs" href="#h-eHXd+T1Ezs" tabindex="-1" role="presentation"></a>Definir una funci√≥n</h2>

<p><a class="p_ident" id="p-5jo0JygqfX" href="#p-5jo0JygqfX" tabindex="-1" role="presentation"></a>Una definici√≥n de funci√≥n es un enlace habitual donde el valor del enlace es una funci√≥n. Por ejemplo, este c√≥digo define <code>square</code> para que se refiera a una funci√≥n que produce el cuadrado de un n√∫mero dado:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-JW7vLBZMWv" href="#c-JW7vLBZMWv" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">square</span> = <span class="tok-keyword">function</span>(<span class="tok-definition">x</span>) {
  <span class="tok-keyword">return</span> x * x;
};

console.log(square(<span class="tok-number">12</span>));
<span class="tok-comment">// ‚Üí 144</span></pre>

<p><a class="p_ident" id="p-Wttl/7EpwM" href="#p-Wttl/7EpwM" tabindex="-1" role="presentation"></a>Una funci√≥n se crea con una expresi√≥n que comienza con la palabra clave <code>function</code>. Las funciones tienen un conjunto de <em>par√°metros</em> (en este caso, solo <code>x</code>) y un <em>cuerpo</em>, que contiene las declaraciones que se ejecutar√°n cuando se llame a la funci√≥n. El cuerpo de una funci√≥n creada de esta manera siempre debe estar envuelto entre llaves, incluso cuando consiste en una √∫nica declaraci√≥n.</p>

<p><a class="p_ident" id="p-vrjpkACz/x" href="#p-vrjpkACz/x" tabindex="-1" role="presentation"></a>Una funci√≥n puede tener varios par√°metros o ninguno en absoluto. En el siguiente ejemplo, <code>makeNoise</code> no enumera nombres de par√°metros, mientras que <code>roundTo</code> (que redondea <code>n</code> al m√∫ltiplo m√°s cercano de <code>step</code>) enumera dos:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-vbZSOJZXVS" href="#c-vbZSOJZXVS" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">makeNoise</span> = <span class="tok-keyword">function</span>() {
  console.log(<span class="tok-string">&quot;¬°Pling!&quot;</span>);
};

makeNoise();
<span class="tok-comment">// ‚Üí ¬°Pling!</span>

<span class="tok-keyword">const</span> <span class="tok-definition">roundTo</span> = <span class="tok-keyword">function</span>(<span class="tok-definition">n</span>, <span class="tok-definition">step</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">resto</span> = n % step;
  <span class="tok-keyword">return</span> n - resto + (resto &lt; step / <span class="tok-number">2</span> ? <span class="tok-number">0</span> : step);
};

console.log(roundTo(<span class="tok-number">23</span>, <span class="tok-number">10</span>));
<span class="tok-comment">// ‚Üí 20</span></pre>

<p><a class="p_ident" id="p-1DcRwWewzX" href="#p-1DcRwWewzX" tabindex="-1" role="presentation"></a>Algunas funciones, como <code>roundTo</code> y <code>square</code>, producen un valor, y otras no, como <code>makeNoise</code>, cuyo √∫nico resultado es un efecto secundario. Una instrucci√≥n <code>return</code> determina el valor que devuelve la funci√≥n. Cuando el control llega a una instrucci√≥n de ese tipo, salta inmediatamente fuera de la funci√≥n actual y le da el valor devuelto al c√≥digo que llam√≥ a la funci√≥n. Una palabra clave <code>return</code> sin una expresi√≥n despu√©s de ella har√° que la funci√≥n devuelva <code>undefined</code>. Las funciones que no tienen ninguna instrucci√≥n <code>return</code> en absoluto, como <code>makeNoise</code>, devuelven igualmente <code>undefined</code>.</p>

<p><a class="p_ident" id="p-skIegUpOjB" href="#p-skIegUpOjB" tabindex="-1" role="presentation"></a>Los par√°metros de una funci√≥n se comportan como enlaces habituales, pero sus valores iniciales son dados por el <em>llamador</em> de la funci√≥n, no por el c√≥digo en la funci√≥n en s√≠ misma.</p>

<h2><a class="h_ident" id="h-wxzpzC5WZf" href="#h-wxzpzC5WZf" tabindex="-1" role="presentation"></a>Enlaces y √°mbitos</h2>

<p><a class="p_ident" id="p-whOg6+ORvy" href="#p-whOg6+ORvy" tabindex="-1" role="presentation"></a>Cada enlace tiene un <em>√°mbito</em>, que es la parte del programa en la que el enlace es visible. Para los enlaces definidos fuera de cualquier funci√≥n, bloque o m√≥dulo (ver <a href="10_modules.html">Cap√≠tulo 10</a>), el √°mbito es todo el programa‚Äîpuedes hacer referencia a esos enlaces donde quieras. Estos se llaman <em>globales</em>.</p>

<p><a class="p_ident" id="p-Otbmqgy70v" href="#p-Otbmqgy70v" tabindex="-1" role="presentation"></a>Los enlaces creados para los par√°metros de una funci√≥n o declarados dentro de una funci√≥n solo pueden ser referenciados en esa funci√≥n, por lo que se conocen como enlaces <em>locales</em>. Cada vez que se llama a la funci√≥n, se crean nuevas instancias de estos enlaces. Esto proporciona cierto aislamiento entre funciones‚Äîcada llamada a funci√≥n act√∫a en su propio peque√±o mundo (su entorno local) y a menudo se puede entender sin saber mucho sobre lo que est√° sucediendo en el entorno global.</p>

<p><a class="p_ident" id="p-a0Kzjls2fD" href="#p-a0Kzjls2fD" tabindex="-1" role="presentation"></a>Los enlaces declarados con <code>let</code> y <code>const</code> en realidad son locales al <em>bloque</em> en el que se declaran, por lo que si creas uno de ellos dentro de un bucle, el c√≥digo antes y despu√©s del bucle no puede ‚Äúverlo‚Äù. En JavaScript anterior a 2015, solo las funciones creaban nuevos √°mbitos, por lo que los enlaces de estilo antiguo, creados con la palabra clave <code>var</code>, son visibles en toda funci√≥n en la que aparecen‚Äîo en todo el √°mbito global, si no est√°n dentro de una funci√≥n.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-IoDSUUCl/U" href="#c-IoDSUUCl/U" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">x</span> = <span class="tok-number">10</span>;   <span class="tok-comment">// global</span>
<span class="tok-keyword">if</span> (true) {
  <span class="tok-keyword">let</span> <span class="tok-definition">y</span> = <span class="tok-number">20</span>; <span class="tok-comment">// local al bloque</span>
  <span class="tok-keyword">var</span> <span class="tok-definition">z</span> = <span class="tok-number">30</span>; <span class="tok-comment">// tambi√©n global</span>
}</pre>

<p><a class="p_ident" id="p-9qwZVGX4rL" href="#p-9qwZVGX4rL" tabindex="-1" role="presentation"></a>Cada √°mbito puede ‚Äúmirar hacia afuera‚Äù al √°mbito que lo rodea, por lo que <code>x</code> es visible dentro del bloque en el ejemplo. La excepci√≥n es cuando m√∫ltiples enlaces tienen el mismo nombre‚Äîen ese caso, el c√≥digo solo puede ver el m√°s interno. Por ejemplo, cuando el c√≥digo dentro de la funci√≥n <code>halve</code> hace referencia a <code>n</code>, est√° viendo su <em>propio</em> <code>n</code>, no el <code>n</code> global.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-5g6POeoiQv" href="#c-5g6POeoiQv" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">halve</span> = <span class="tok-keyword">function</span>(<span class="tok-definition">n</span>) {
  <span class="tok-keyword">return</span> n / <span class="tok-number">2</span>;
};

<span class="tok-keyword">let</span> <span class="tok-definition">n</span> = <span class="tok-number">10</span>;
console.log(halve(<span class="tok-number">100</span>));
<span class="tok-comment">// ‚Üí 50</span>
console.log(n);
<span class="tok-comment">// ‚Üí 10</span></pre>

<h2 id="alcance"><a class="h_ident" id="h-Bb1XV2UFNf" href="#h-Bb1XV2UFNf" tabindex="-1" role="presentation"></a>√Åmbito anidado</h2>

<p><a class="p_ident" id="p-WQPriPynnr" href="#p-WQPriPynnr" tabindex="-1" role="presentation"></a>JavaScript distingue no solo entre enlaces globales y locales. Bloques y funciones pueden ser creados dentro de otros bloques y funciones, produciendo m√∫ltiples grados de localidad.</p>

<p><a class="p_ident" id="p-ET4L8vHq9N" href="#p-ET4L8vHq9N" tabindex="-1" role="presentation"></a>Por ejemplo, esta funci√≥n‚Äîque muestra los ingredientes necesarios para hacer un lote de hummus‚Äîtiene otra funci√≥n dentro de ella:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-o16pCCxu1S" href="#c-o16pCCxu1S" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">hummus</span> = <span class="tok-keyword">function</span>(<span class="tok-definition">factor</span>) {
  <span class="tok-keyword">const</span> <span class="tok-definition">ingredient</span> = <span class="tok-keyword">function</span>(<span class="tok-definition">amount</span>, <span class="tok-definition">unit</span>, <span class="tok-definition">name</span>) {
    <span class="tok-keyword">let</span> <span class="tok-definition">ingredientAmount</span> = amount * factor;
    <span class="tok-keyword">if</span> (ingredientAmount &gt; <span class="tok-number">1</span>) {
      unit += <span class="tok-string">&quot;s&quot;</span>;
    }
    console.log(<span class="tok-string2">`</span>${ingredientAmount}<span class="tok-string2"> </span>${unit}<span class="tok-string2"> </span>${name}<span class="tok-string2">`</span>);
  };
  ingredient(<span class="tok-number">1</span>, <span class="tok-string">&quot;lata&quot;</span>, <span class="tok-string">&quot;garbanzos&quot;</span>);
  ingredient(<span class="tok-number">0.25</span>, <span class="tok-string">&quot;taza&quot;</span>, <span class="tok-string">&quot;tahini&quot;</span>);
  ingredient(<span class="tok-number">0.25</span>, <span class="tok-string">&quot;taza&quot;</span>, <span class="tok-string">&quot;jugo de lim√≥n&quot;</span>);
  ingredient(<span class="tok-number">1</span>, <span class="tok-string">&quot;diente&quot;</span>, <span class="tok-string">&quot;ajo&quot;</span>);
  ingredient(<span class="tok-number">2</span>, <span class="tok-string">&quot;cucharada&quot;</span>, <span class="tok-string">&quot;aceite de oliva&quot;</span>);
  ingredient(<span class="tok-number">0.5</span>, <span class="tok-string">&quot;cucharadita&quot;</span>, <span class="tok-string">&quot;comino&quot;</span>);
};</pre>

<p><a class="p_ident" id="p-Rmy1dhc5eP" href="#p-Rmy1dhc5eP" tabindex="-1" role="presentation"></a>El c√≥digo dentro de la funci√≥n <code>ingredient</code> puede ver el enlace <code>factor</code> de la funci√≥n exterior, pero sus enlaces locales, como <code>unit</code> o <code>ingredientAmount</code>, no son visibles en la funci√≥n exterior.</p>

<p><a class="p_ident" id="p-DoPmP2HGVl" href="#p-DoPmP2HGVl" tabindex="-1" role="presentation"></a>El conjunto de enlaces visibles dentro de un bloque est√° determinado por el lugar de ese bloque en el texto del programa. Cada bloque local tambi√©n puede ver todos los bloques locales que lo contienen, y todos los bloques pueden ver el bloque global. Este enfoque de visibilidad de enlaces se llama <em>√°mbito l√©xico</em>.</p>

<h2><a class="h_ident" id="h-3mNEhIfF61" href="#h-3mNEhIfF61" tabindex="-1" role="presentation"></a>Funciones como valores</h2>

<p><a class="p_ident" id="p-9SOeUnXtuP" href="#p-9SOeUnXtuP" tabindex="-1" role="presentation"></a>Generalmente un enlace de funci√≥n simplemente act√∫a como un nombre para una parte espec√≠fica del programa. Este enlace se define una vez y nunca se cambia. Esto hace que sea f√°cil confundir la funci√≥n y su nombre.</p>

<p><a class="p_ident" id="p-Z3YsDzJ9JG" href="#p-Z3YsDzJ9JG" tabindex="-1" role="presentation"></a>Pero los dos son diferentes. Un valor de funci√≥n puede hacer todas las cosas que pueden hacer otros valores: se puede utilizar en expresiones arbitrarias, no solo llamarlo. Es posible almacenar un valor de funci√≥n en un nuevo enlace, pasarlo como argumento a una funci√≥n, etc. De manera similar, un enlace que contiene una funci√≥n sigue siendo solo un enlace habitual y, si no es constante, se le puede asignar un nuevo valor, as√≠:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-lz0sp2Utto" href="#c-lz0sp2Utto" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">launchMissiles</span> = <span class="tok-keyword">function</span>() {
  missileSystem.launch(<span class="tok-string">&quot;now&quot;</span>);
};
<span class="tok-keyword">if</span> (safeMode) {
  launchMissiles = <span class="tok-keyword">function</span>() {<span class="tok-comment">/* no hacer nada */</span>};
}</pre>

<p><a class="p_ident" id="p-mYurbU9/K8" href="#p-mYurbU9/K8" tabindex="-1" role="presentation"></a>En el <a href="05_higher_order.html">Cap√≠tulo 5</a>, discutiremos las cosas interesantes que podemos hacer al pasar valores de funci√≥n a otras funciones.</p>

<h2><a class="h_ident" id="h-tewMxJao9I" href="#h-tewMxJao9I" tabindex="-1" role="presentation"></a>Notaci√≥n de declaraci√≥n</h2>

<p><a class="p_ident" id="p-8B3Xt7iB35" href="#p-8B3Xt7iB35" tabindex="-1" role="presentation"></a>Hay una manera ligeramente m√°s corta de crear un enlace de funci√≥n. Cuando se utiliza la palabra clave <code>function</code> al inicio de una declaraci√≥n, funciona de manera diferente:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-4uHhsg+h7S" href="#c-4uHhsg+h7S" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">square</span>(<span class="tok-definition">x</span>) {
  <span class="tok-keyword">return</span> x * x;
}</pre>

<p><a class="p_ident" id="p-VyKvVyRYQV" href="#p-VyKvVyRYQV" tabindex="-1" role="presentation"></a>Esta es una funci√≥n <em>declarativa</em>. La declaraci√≥n define el enlace <code>square</code> y lo apunta a la funci√≥n dada. Es un poco m√°s f√°cil de escribir y no requiere un punto y coma despu√©s de la funci√≥n.</p>

<p><a class="p_ident" id="p-xfJkZVJQEh" href="#p-xfJkZVJQEh" tabindex="-1" role="presentation"></a>Hay una sutileza con esta forma de definici√≥n de funci√≥n.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Uq3EWZNFOJ" href="#c-Uq3EWZNFOJ" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">&quot;El futuro dice:&quot;</span>, future());

<span class="tok-keyword">function</span> <span class="tok-definition">future</span>() {
  <span class="tok-keyword">return</span> <span class="tok-string">&quot;Nunca tendr√°s autos voladores&quot;</span>;
}</pre>

<p><a class="p_ident" id="p-4dZZ8ocV0I" href="#p-4dZZ8ocV0I" tabindex="-1" role="presentation"></a>El c√≥digo anterior funciona, incluso aunque la funci√≥n est√© definida <em>debajo</em> del c√≥digo que la usa. Las declaraciones de funci√≥n no forman parte del flujo de control regular de arriba hacia abajo. Conceptualmente se mueven al principio de su alcance y pueden ser utilizadas por todo el c√≥digo en ese alcance. A veces esto es √∫til porque ofrece la libertad de ordenar el c√≥digo de una manera que parezca m√°s clara, sin tener que preocuparse por definir todas las funciones antes de que se utilicen.</p>

<h2><a class="h_ident" id="h-7gP0M6nUCF" href="#h-7gP0M6nUCF" tabindex="-1" role="presentation"></a>Funciones de flecha</h2>

<p><a class="p_ident" id="p-qp+SShPV+r" href="#p-qp+SShPV+r" tabindex="-1" role="presentation"></a>Hay una tercera notaci√≥n para funciones, que se ve muy diferente de las otras. En lugar de la palabra clave <code>function</code>, utiliza una flecha (<code>=&gt;</code>) compuesta por un signo igual y un caracter mayor que (no confundir con el operador mayor o igual, que se escribe <code>&gt;=</code>):</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-5zMRAvLyub" href="#c-5zMRAvLyub" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">roundTo</span> = (<span class="tok-definition">n</span>, <span class="tok-definition">step</span>) =&gt; {
  <span class="tok-keyword">let</span> <span class="tok-definition">remainder</span> = n % step;
  <span class="tok-keyword">return</span> n - remainder + (remainder &lt; step / <span class="tok-number">2</span> ? <span class="tok-number">0</span> : step);
};</pre>

<p><a class="p_ident" id="p-4wRZ32fVtv" href="#p-4wRZ32fVtv" tabindex="-1" role="presentation"></a>La flecha viene <em>despu√©s</em> de la lista de par√°metros y es seguida por el cuerpo de la funci√≥n. Expresa algo as√≠ como ‚Äúesta entrada (los par√°metros) produce este resultado (el cuerpo)‚Äù.</p>

<p><a class="p_ident" id="p-B2W8hY/asG" href="#p-B2W8hY/asG" tabindex="-1" role="presentation"></a>Cuando solo hay un nombre de par√°metro, puedes omitir los par√©ntesis alrededor de la lista de par√°metros. Si el cuerpo es una sola expresi√≥n, en lugar de un bloque entre llaves, esa expresi√≥n ser√° devuelta por la funci√≥n. Por lo tanto, estas dos definiciones de <code>exponente</code> hacen lo mismo:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-yDV8N1C3lB" href="#c-yDV8N1C3lB" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">exponente1</span> = (<span class="tok-definition">x</span>) =&gt; { <span class="tok-keyword">return</span> x * x; };
<span class="tok-keyword">const</span> <span class="tok-definition">exponente2</span> = <span class="tok-definition">x</span> =&gt; x * x;</pre>

<p><a class="p_ident" id="p-PvxM25s0zB" href="#p-PvxM25s0zB" tabindex="-1" role="presentation"></a>Cuando una funci√≥n de flecha no tiene par√°metros en absoluto, su lista de par√°metros es simplemente un conjunto vac√≠o de par√©ntesis.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-WTImn5yQuM" href="#c-WTImn5yQuM" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">cuerno</span> = () =&gt; {
  console.log(<span class="tok-string">&quot;Toot&quot;</span>);
};</pre>

<p><a class="p_ident" id="p-q9uDkTN2Zd" href="#p-q9uDkTN2Zd" tabindex="-1" role="presentation"></a>No hay una raz√≥n profunda para tener tanto funciones de flecha como expresiones <code>function</code> en el lenguaje. Aparte de un detalle menor, que discutiremos en el <a href="06_object.html">Cap√≠tulo 6</a>, hacen lo mismo. Las funciones de flecha se agregaron en 2015, principalmente para hacer posible escribir expresiones de funci√≥n peque√±as de una manera menos verbosa. Las usaremos a menudo en el <a href="05_higher_order.html">Cap√≠tulo 5</a> .</p>

<h2 id="pila"><a class="h_ident" id="h-nePB5S+L1Q" href="#h-nePB5S+L1Q" tabindex="-1" role="presentation"></a>La pila de llamadas</h2>

<p><a class="p_ident" id="p-aMmoKkJUw3" href="#p-aMmoKkJUw3" tabindex="-1" role="presentation"></a>La forma en que el control fluye a trav√©s de las funciones es un tanto complicada. Echemos un vistazo m√°s de cerca. Aqu√≠ hay un programa simple que realiza algunas llamadas de funci√≥n:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-qJyPTKyGmO" href="#c-qJyPTKyGmO" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">saludar</span>(<span class="tok-definition">quien</span>) {
  console.log(<span class="tok-string">&quot;Hola &quot;</span> + quien);
}
saludar(<span class="tok-string">&quot;Harry&quot;</span>);
console.log(<span class="tok-string">&quot;Adi√≥s&quot;</span>);</pre>

<p><a class="p_ident" id="p-Dn5Off5HVf" href="#p-Dn5Off5HVf" tabindex="-1" role="presentation"></a>Una ejecuci√≥n de este programa va m√°s o menos as√≠: la llamada a <code>saludar</code> hace que el control salte al inicio de esa funci√≥n (l√≠nea 2). La funci√≥n llama a <code>console.log</code>, que toma el control, hace su trabajo, y luego devuelve el control a la l√≠nea 2. All√≠, llega al final de la funci√≥n <code>saludar</code>, por lo que regresa al lugar que la llam√≥, l√≠nea 4. La l√≠nea siguiente llama a <code>console.log</code> nuevamente. Despu√©s de ese retorno, el programa llega a su fin.</p>

<p><a class="p_ident" id="p-EhJguRxP1B" href="#p-EhJguRxP1B" tabindex="-1" role="presentation"></a>Podr√≠amos mostrar el flujo de control esquem√°ticamente de esta manera:</p>

<pre class="snippet" data-language="null" ><a class="c_ident" id="c-P67GeEPWC+" href="#c-P67GeEPWC+" tabindex="-1" role="presentation"></a>no en funci√≥n
   en saludar
        en console.log
   en saludar
no en funci√≥n
   en console.log
no en funci√≥n</pre>

<p><a class="p_ident" id="p-M5sgy1Ouv/" href="#p-M5sgy1Ouv/" tabindex="-1" role="presentation"></a>Dado que una funci√≥n tiene que regresar al lugar que la llam√≥ cuando termina, la computadora debe recordar el contexto desde el cual se realiz√≥ la llamada. En un caso, <code>console.log</code> tiene que regresar a la funci√≥n <code>saludar</code> cuando haya terminado. En el otro caso, regresa al final del programa.</p>

<p><a class="p_ident" id="p-xHR55l4E6j" href="#p-xHR55l4E6j" tabindex="-1" role="presentation"></a>El lugar donde la computadora almacena este contexto es la <em>pila de llamadas</em>. Cada vez que se llama a una funci√≥n, el contexto actual se almacena en la parte superior de esta pila. Cuando una funci√≥n devuelve, elimina el contexto superior de la pila y usa ese contexto para continuar la ejecuci√≥n.</p>

<p><a class="p_ident" id="p-SB1hzp8Fcw" href="#p-SB1hzp8Fcw" tabindex="-1" role="presentation"></a>Almacenar esta pila requiere espacio en la memoria de la computadora. Cuando la pila crece demasiado, la computadora fallar√° con un mensaje como ‚Äúsin espacio en la pila‚Äù o ‚Äúdemasiada recursividad‚Äù. El siguiente c√≥digo ilustra esto al hacerle a la computadora una pregunta realmente dif√≠cil que causa un vaiv√©n infinito entre dos funciones. O m√°s bien, <em>ser√≠a</em> infinito, si la computadora tuviera una pila infinita. Como no la tiene, nos quedaremos sin espacio o ‚Äúreventaremos la pila‚Äù.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-u9bb1xDgwe" href="#c-u9bb1xDgwe" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">chicken</span>() {
  <span class="tok-keyword">return</span> egg();
}
<span class="tok-keyword">function</span> <span class="tok-definition">egg</span>() {
  <span class="tok-keyword">return</span> chicken();
}
console.log(chicken() + <span class="tok-string">&quot; sali√≥ primero.&quot;</span>);
<span class="tok-comment">// ‚Üí ??</span></pre>

<h2><a class="h_ident" id="h-jNCGCF3rFb" href="#h-jNCGCF3rFb" tabindex="-1" role="presentation"></a>Argumentos Opcionales</h2>

<p><a class="p_ident" id="p-H9TL95isqo" href="#p-H9TL95isqo" tabindex="-1" role="presentation"></a>El siguiente c√≥digo est√° permitido y se ejecuta sin ning√∫n problema:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-T8m5axnp1h" href="#c-T8m5axnp1h" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">square</span>(<span class="tok-definition">x</span>) { <span class="tok-keyword">return</span> x * x; }
console.log(square(<span class="tok-number">4</span>, true, <span class="tok-string">&quot;erizo&quot;</span>));
<span class="tok-comment">// ‚Üí 16</span></pre>

<p><a class="p_ident" id="p-qSFz2Cu3MP" href="#p-qSFz2Cu3MP" tabindex="-1" role="presentation"></a>Hemos definido <code>square</code> con solo un par√°metro. Sin embargo, cuando lo llamamos con tres, el lenguaje no se queja. Ignora los argumentos adicionales y calcula el cuadrado del primero.</p>

<p><a class="p_ident" id="p-xQJ7gf7nbn" href="#p-xQJ7gf7nbn" tabindex="-1" role="presentation"></a>JavaScript es extremadamente flexible en cuanto al n√∫mero de argumentos que puedes pasar a una funci√≥n. Si pasas demasiados, los extras son ignorados. Si pasas muy pocos, los par√°metros faltantes se les asigna el valor <code>undefined</code>.</p>

<p><a class="p_ident" id="p-+8VZwoywj9" href="#p-+8VZwoywj9" tabindex="-1" role="presentation"></a>El inconveniente de esto es que es posible ‚Äîincluso probable‚Äî que pases accidentalmente el n√∫mero incorrecto de argumentos a las funciones. Y nadie te dir√° nada al respecto. La ventaja es que puedes utilizar este comportamiento para permitir que una funci√≥n sea llamada con diferentes n√∫meros de argumentos. Por ejemplo, esta funci√≥n <code>minus</code> intenta imitar al operador <code>-</code> actuando sobre uno o dos argumentos:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-8zGcY0SKdo" href="#c-8zGcY0SKdo" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">minus</span>(<span class="tok-definition">a</span>, <span class="tok-definition">b</span>) {
  <span class="tok-keyword">if</span> (b === undefined) <span class="tok-keyword">return</span> -a;
  <span class="tok-keyword">else</span> <span class="tok-keyword">return</span> a - b;
}

console.log(minus(<span class="tok-number">10</span>));
<span class="tok-comment">// ‚Üí -10</span>
console.log(minus(<span class="tok-number">10</span>, <span class="tok-number">5</span>));
<span class="tok-comment">// ‚Üí 5</span></pre>

<p id="roundTo"><a class="p_ident" id="p-tcju9YOu56" href="#p-tcju9YOu56" tabindex="-1" role="presentation"></a>Si escribes un operador <code>=</code> despu√©s de un par√°metro, seguido de una expresi√≥n, el valor de esa expresi√≥n reemplazar√° al argumento cuando no se le d√©. Por ejemplo, esta versi√≥n de <code>roundTo</code> hace que su segundo argumento sea opcional. Si no lo proporcionas o pasas el valor <code>undefined</code>, por defecto ser√° uno:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-lf5l9+817Y" href="#c-lf5l9+817Y" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">roundTo</span>(<span class="tok-definition">n</span>, <span class="tok-definition">step</span> = <span class="tok-number">1</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">remainder</span> = n % step;
  <span class="tok-keyword">return</span> n - remainder + (remainder &lt; step / <span class="tok-number">2</span> ? <span class="tok-number">0</span> : step);
};

console.log(roundTo(<span class="tok-number">4.5</span>));
<span class="tok-comment">// ‚Üí 5</span>
console.log(roundTo(<span class="tok-number">4.5</span>, <span class="tok-number">2</span>));
<span class="tok-comment">// ‚Üí 4</span></pre>

<p><a class="p_ident" id="p-0QAhU0olKv" href="#p-0QAhU0olKv" tabindex="-1" role="presentation"></a><a href="04_data.html#rest_parameters">El pr√≥ximo cap√≠tulo</a> introducir√° una forma en que un cuerpo de funci√≥n puede acceder a la lista completa de argumentos que se le pasaron. Esto es √∫til porque le permite a una funci√≥n aceptar cualquier n√∫mero de argumentos. Por ejemplo, <code>console.log</code> lo hace, mostrando todos los valores que se le dan:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-RvkwVkcUZ7" href="#c-RvkwVkcUZ7" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">&quot;C&quot;</span>, <span class="tok-string">&quot;O&quot;</span>, <span class="tok-number">2</span>);
<span class="tok-comment">// ‚Üí C O 2</span></pre>

<h2><a class="h_ident" id="h-KU8YojAGul" href="#h-KU8YojAGul" tabindex="-1" role="presentation"></a>Clausura</h2>

<p><a class="p_ident" id="p-hi0pjIyB2g" href="#p-hi0pjIyB2g" tabindex="-1" role="presentation"></a>La capacidad de tratar las funciones como valores, combinada con el hecho de que los enlaces locales se recrean cada vez que se llama a una funci√≥n, plantea una pregunta interesante: ¬øqu√© sucede con los enlaces locales cuando la llamada a la funci√≥n que los cre√≥ ya no est√° activa?El siguiente c√≥digo muestra un ejemplo de esto. Define una funci√≥n, <code>wrapValue</code>, que crea un enlace local. Luego devuelve una funci√≥n que accede a este enlace local y lo devuelve:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-DF70h3opbx" href="#c-DF70h3opbx" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">wrapValue</span>(<span class="tok-definition">n</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">local</span> = n;
  <span class="tok-keyword">return</span> () =&gt; local;
}

<span class="tok-keyword">let</span> <span class="tok-definition">wrap1</span> = wrapValue(<span class="tok-number">1</span>);
<span class="tok-keyword">let</span> <span class="tok-definition">wrap2</span> = wrapValue(<span class="tok-number">2</span>);
console.log(wrap1());
<span class="tok-comment">// ‚Üí 1</span>
console.log(wrap2());
<span class="tok-comment">// ‚Üí 2</span></pre>

<p><a class="p_ident" id="p-YU/l50hrdL" href="#p-YU/l50hrdL" tabindex="-1" role="presentation"></a>Esto est√° permitido y funciona como esperar√≠as: ambas instancias del enlace a√∫n pueden accederse. Esta situaci√≥n es una buena demostraci√≥n de que los enlaces locales se crean nuevamente para cada llamada, y las diferentes llamadas no afectan los enlaces locales de los dem√°s.</p>

<p><a class="p_ident" id="p-HTFaO7CfSD" href="#p-HTFaO7CfSD" tabindex="-1" role="presentation"></a>Esta caracter√≠stica, poder hacer referencia a una instancia espec√≠fica de un enlace local en un √°mbito superior, se llama <em>clausura</em>. Una funci√≥n que hace referencia a enlaces de √°mbitos locales a su alrededor se llama <em>una</em> clausura. Este comportamiento no solo te libera de tener que preocuparte por la vida √∫til de los enlaces, sino que tambi√©n hace posible usar valores de funci√≥n de formas creativas.</p>

<p><a class="p_ident" id="p-dqvi9Q/A+9" href="#p-dqvi9Q/A+9" tabindex="-1" role="presentation"></a>Con un ligero cambio, podemos convertir el ejemplo anterior en una forma de crear funciones que multiplican por una cantidad arbitraria:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-iIlCVmvMSs" href="#c-iIlCVmvMSs" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">multiplier</span>(<span class="tok-definition">factor</span>) {
  <span class="tok-keyword">return</span> <span class="tok-definition">number</span> =&gt; number * factor;
}

<span class="tok-keyword">let</span> <span class="tok-definition">twice</span> = multiplier(<span class="tok-number">2</span>);
console.log(twice(<span class="tok-number">5</span>));
<span class="tok-comment">// ‚Üí 10</span></pre>

<p><a class="p_ident" id="p-W9UeLQ7s8n" href="#p-W9UeLQ7s8n" tabindex="-1" role="presentation"></a>El enlace expl√≠cito <code>local</code> del ejemplo <code>wrapValue</code> realmente no es necesario, ya que un par√°metro es en s√≠ mismo un enlace local.</p>

<p><a class="p_ident" id="p-xoKKzht2cB" href="#p-xoKKzht2cB" tabindex="-1" role="presentation"></a>Pensar en programas de esta manera requiere algo de pr√°ctica. Un buen modelo mental es pensar en los valores de funci√≥n como que contienen tanto el c√≥digo en su cuerpo como el entorno en el que fueron creados. Cuando se llama, el cuerpo de la funci√≥n ve el entorno en el que fue creado, no el entorno en el que se llama.</p>

<p><a class="p_ident" id="p-FbEnVK1PeW" href="#p-FbEnVK1PeW" tabindex="-1" role="presentation"></a>En el ejemplo anterior, se llama a <code>multiplier</code> y crea un entorno en el que su par√°metro <code>factor</code> est√° vinculado a 2. El valor de funci√≥n que devuelve, que se almacena en <code>twice</code>, recuerda este entorno para que cuando se llame, multiplique su argumento por 2.</p>

<h2><a class="h_ident" id="h-ge3a45K3m3" href="#h-ge3a45K3m3" tabindex="-1" role="presentation"></a>Recursi√≥n</h2>

<p><a class="p_ident" id="p-OGtTx+fur4" href="#p-OGtTx+fur4" tabindex="-1" role="presentation"></a>Es perfectamente v√°lido que una funci√≥n se llame a s√≠ misma, siempre y cuando no lo haga tan a menudo que desborde la pila. Una funci√≥n que se llama a s√≠ misma se llama <em>recursiva</em>. La recursi√≥n permite que algunas funciones se escriban de una manera diferente. Toma, por ejemplo, esta funci√≥n <code>power</code>, que hace lo mismo que el operador <code>**</code> (potenciaci√≥n):</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-agdELfiRGm" href="#c-agdELfiRGm" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">power</span>(<span class="tok-definition">base</span>, <span class="tok-definition">exponent</span>) {
  <span class="tok-keyword">if</span> (exponent == <span class="tok-number">0</span>) {
    <span class="tok-keyword">return</span> <span class="tok-number">1</span>;
  } <span class="tok-keyword">else</span> {
    <span class="tok-keyword">return</span> base * power(base, exponent - <span class="tok-number">1</span>);
  }
}

console.log(power(<span class="tok-number">2</span>, <span class="tok-number">3</span>));
<span class="tok-comment">// ‚Üí 8</span></pre>

<p><a class="p_ident" id="p-ZH6kc3lXYd" href="#p-ZH6kc3lXYd" tabindex="-1" role="presentation"></a>Esto se asemeja bastante a la forma en que los matem√°ticos definen la potenciaci√≥n y describe el concepto de manera m√°s clara que el bucle que usamos en el <a href="02_program_structure.html">Cap√≠tulo 2</a>. La funci√≥n se llama a s√≠ misma varias veces con exponentes cada vez m√°s peque√±os para lograr la multiplicaci√≥n repetida.</p>

<p><a class="p_ident" id="p-vuRF5znTGo" href="#p-vuRF5znTGo" tabindex="-1" role="presentation"></a>Sin embargo, esta implementaci√≥n tiene un problema: en implementaciones t√≠picas de JavaScript, es aproximadamente tres veces m√°s lenta que una versi√≥n que utiliza un bucle <code>for</code>. Recorrer un simple bucle suele ser m√°s econ√≥mico que llamar a una funci√≥n m√∫ltiples veces.</p>

<p><a class="p_ident" id="p-HyK1Oztn84" href="#p-HyK1Oztn84" tabindex="-1" role="presentation"></a>El dilema de velocidad versus elegancia es interesante. Se puede ver como una especie de continuo entre la compatibilidad con los humanos y las m√°quinas. Casi cualquier programa puede ser acelerado haciendo que sea m√°s extenso y complicado. El programador debe encontrar un equilibrio apropiado.</p>

<p><a class="p_ident" id="p-UUCfSx41Ze" href="#p-UUCfSx41Ze" tabindex="-1" role="presentation"></a>En el caso de la funci√≥n <code>power</code>, una versi√≥n poco elegante (con bucles) sigue siendo bastante simple y f√°cil de leer. No tiene mucho sentido reemplazarla con una funci√≥n recursiva. Sin embargo, a menudo un programa trata con conceptos tan complejos que es √∫til renunciar a algo de eficiencia para hacer que el programa sea m√°s sencillo.</p>

<p><a class="p_ident" id="p-qQ0sf4nZdt" href="#p-qQ0sf4nZdt" tabindex="-1" role="presentation"></a>Preocuparse por la eficiencia puede ser una distracci√≥n. Es otro factor que complica el dise√±o del programa y cuando est√°s haciendo algo que ya es dif√≠cil, ese extra en lo que preocuparse puede llegar a ser paralizante.</p>

<p><a class="p_ident" id="p-W1/mlcain4" href="#p-W1/mlcain4" tabindex="-1" role="presentation"></a>Por lo tanto, generalmente deber√≠as comenzar escribiendo algo que sea correcto y f√°cil de entender. Si te preocupa que sea demasiado lento‚Äîlo cual suele ser raro, ya que la mayor√≠a del c√≥digo simplemente no se ejecuta lo suficiente como para tomar una cantidad significativa de tiempo‚Äîpuedes medir despu√©s y mejorarlo si es necesario.</p>

<p><a class="p_ident" id="p-oNzYWF+2hF" href="#p-oNzYWF+2hF" tabindex="-1" role="presentation"></a>La recursi√≥n no siempre es simplemente una alternativa ineficiente a los bucles. Algunos problemas realmente son m√°s f√°ciles de resolver con recursi√≥n que con bucles. Con mayor frecuencia, estos son problemas que requieren explorar o procesar varias ‚Äúramas‚Äù, cada una de las cuales podr√≠a ramificarse nuevamente en a√∫n m√°s ramas.</p>

<p id="rompecabezas_recursivo"><a class="p_ident" id="p-z8AgKvwZXc" href="#p-z8AgKvwZXc" tabindex="-1" role="presentation"></a>Considera este rompecabezas: al comenzar desde el n√∫mero 1 y repetidamente sumar 5 o multiplicar por 3, se puede producir un conjunto infinito de n√∫meros. ¬øC√≥mo escribir√≠as una funci√≥n que, dado un n√∫mero, intente encontrar una secuencia de tales sumas y multiplicaciones que produzcan ese n√∫mero? Por ejemplo, el n√∫mero 13 podr√≠a alcanzarse al multiplicar por 3 y luego sumar 5 dos veces, mientras que el n√∫mero 15 no podr√≠a alcanzarse en absoluto.</p>

<p><a class="p_ident" id="p-HOoTgs7o63" href="#p-HOoTgs7o63" tabindex="-1" role="presentation"></a>Aqu√≠ tienes una soluci√≥n recursiva:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-g4e2T0l3Uf" href="#c-g4e2T0l3Uf" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">encontrarSolucion</span>(<span class="tok-definition">objetivo</span>) {
  <span class="tok-keyword">function</span> <span class="tok-definition">encontrar</span>(<span class="tok-definition">actual</span>, <span class="tok-definition">historial</span>) {
    <span class="tok-keyword">if</span> (actual === objetivo) {
      <span class="tok-keyword">return</span> historial;
    } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (actual &gt; objetivo) {
      <span class="tok-keyword">return</span> <span class="tok-keyword">null</span>;
    } <span class="tok-keyword">else</span> {
      <span class="tok-keyword">return</span> encontrar(actual + <span class="tok-number">5</span>, <span class="tok-string2">`(</span>${historial}<span class="tok-string2"> + 5)`</span>) ??
             encontrar(actual * <span class="tok-number">3</span>, <span class="tok-string2">`(</span>${historial}<span class="tok-string2"> * 3)`</span>);
    }
  }
  <span class="tok-keyword">return</span> encontrar(<span class="tok-number">1</span>, <span class="tok-string">&quot;1&quot;</span>);
}

console.log(encontrarSolucion(<span class="tok-number">24</span>));
<span class="tok-comment">// ‚Üí (((1 * 3) + 5) * 3)</span></pre>

<p><a class="p_ident" id="p-pHOyC25qCR" href="#p-pHOyC25qCR" tabindex="-1" role="presentation"></a>Ten en cuenta que este programa no necesariamente encuentra la secuencia de operaciones m√°s <em>corta</em>. Se conforma con encontrar cualquier secuencia.</p>

<p><a class="p_ident" id="p-j6YcJ9M71I" href="#p-j6YcJ9M71I" tabindex="-1" role="presentation"></a>No te preocupes si no ves c√≥mo funciona este c√≥digo de inmediato. Vamos a trabajar juntos, ya que es un gran ejercicio de pensamiento recursivo. La funci√≥n interna <code>encontrar</code> es la que realiza la recursi√≥n real. Toma dos argumentos: el n√∫mero actual y una cadena que registra c√≥mo llegamos a este n√∫mero. Si encuentra una soluci√≥n, devuelve una cadena que muestra c√≥mo llegar al objetivo. Si no puede encontrar una soluci√≥n comenzando desde este n√∫mero, devuelve <code>null</code>.</p>

<p><a class="p_ident" id="p-bRYy2wuEMy" href="#p-bRYy2wuEMy" tabindex="-1" role="presentation"></a>Para hacer esto, la funci√≥n realiza una de tres acciones. Si el n√∫mero actual es el n√∫mero objetivo, el historial actual es una forma de alcanzar ese objetivo, por lo que se devuelve. Si el n√∫mero actual es mayor que el objetivo, no tiene sentido explorar m√°s esta rama porque tanto la suma como la multiplicaci√≥n solo har√°n que el n√∫mero sea m√°s grande, por lo que devuelve <code>null</code>. Finalmente, si a√∫n estamos por debajo del n√∫mero objetivo, la funci√≥n prueba ambas rutas posibles que parten del n√∫mero actual llam√°ndose a s√≠ misma dos veces, una vez para la suma y otra vez para la multiplicaci√≥n. Si la primera llamada devuelve algo que no es <code>null</code>, se devuelve. De lo contrario, se devuelve la segunda llamada, independientemente de si produce una cadena o <code>null</code>.</p>

<p><a class="p_ident" id="p-87C75eNTfr" href="#p-87C75eNTfr" tabindex="-1" role="presentation"></a>Para entender mejor c√≥mo esta funci√≥n produce el efecto que estamos buscando, veamos todas las llamadas a <code>encontrar</code> que se hacen al buscar una soluci√≥n para el n√∫mero 13:</p>

<pre class="snippet" data-language="null" ><a class="c_ident" id="c-S7wN3j0XMZ" href="#c-S7wN3j0XMZ" tabindex="-1" role="presentation"></a>encontrar(1, &quot;1&quot;)
  encontrar(6, &quot;(1 + 5)&quot;)
    encontrar(11, &quot;((1 + 5) + 5)&quot;)
      encontrar(16, &quot;(((1 + 5) + 5) + 5)&quot;)
        demasiado grande
      encontrar(33, &quot;(((1 + 5) + 5) * 3)&quot;)
        demasiado grande
    encontrar(18, &quot;((1 + 5) * 3)&quot;)
      demasiado grande
  encontrar(3, &quot;(1 * 3)&quot;)
    encontrar(8, &quot;((1 * 3) + 5)&quot;)
      encontrar(13, &quot;(((1 * 3) + 5) + 5)&quot;)
        ¬°encontrado!</pre>

<p><a class="p_ident" id="p-DHJBtGEOXF" href="#p-DHJBtGEOXF" tabindex="-1" role="presentation"></a>La sangr√≠a indica la profundidad de la pila de llamadas. La primera vez que se llama a <code>encontrar</code>, la funci√≥n comienza llam√°ndose a s√≠ misma para explorar la soluci√≥n que comienza con <code>(1 + 5)</code>. Esa llamada seguir√° recursivamente para explorar <em>cada</em> soluci√≥n a continuaci√≥n que produzca un n√∫mero menor o igual al n√∫mero objetivo. Como no encuentra uno que alcance el objetivo, devuelve <code>null</code> a la primera llamada. All√≠, el operador <code>??</code> hace que ocurra la llamada que explora <code>(1 * 3)</code>. Esta b√∫squeda tiene m√°s suerte: su primera llamada recursiva, a trav√©s de otra llamada recursiva, alcanza el n√∫mero objetivo. Esa llamada m√°s interna devuelve una cadena, y cada uno de los operadores <code>??</code> en las llamadas intermedias pasa esa cadena, devolviendo en √∫ltima instancia la soluci√≥n.</p>

<h2><a class="h_ident" id="h-uZ0juDUWOs" href="#h-uZ0juDUWOs" tabindex="-1" role="presentation"></a>Crecimiento de funciones</h2>

<p><a class="p_ident" id="p-n9cGqWi0db" href="#p-n9cGqWi0db" tabindex="-1" role="presentation"></a>Hay dos formas m√°s o menos naturales de introducir funciones en los programas.</p>

<p><a class="p_ident" id="p-B8XV+CLjOF" href="#p-B8XV+CLjOF" tabindex="-1" role="presentation"></a>La primera ocurre cuando te encuentras escribiendo c√≥digo similar varias veces. Preferir√≠as no hacer eso, ya que tener m√°s c√≥digo significa m√°s espacio para que se escondan los errores y m√°s material para que las personas que intentan entender el programa lo lean. Por lo tanto, tomas la funcionalidad repetida, encuentras un buen nombre para ella y la colocas en una funci√≥n.</p>

<p><a class="p_ident" id="p-cOAhBy6EBv" href="#p-cOAhBy6EBv" tabindex="-1" role="presentation"></a>La segunda forma es que te das cuenta de que necesitas alguna funcionalidad que a√∫n no has escrito y que suena como si mereciera su propia funci√≥n. Comienzas por nombrar la funci√≥n, luego escribes su cuerpo. Incluso podr√≠as comenzar a escribir c√≥digo que use la funci√≥n antes de definir la funci√≥n en s√≠.</p>

<p><a class="p_ident" id="p-YZ4JKo/kXS" href="#p-YZ4JKo/kXS" tabindex="-1" role="presentation"></a>Lo dif√≠cil que es encontrar un buen nombre para una funci√≥n es una buena indicaci√≥n de lo claro que es el concepto que est√°s tratando de envolver con ella. Vamos a trav√©s de un ejemplo.</p>

<p><a class="p_ident" id="p-eV6abyHMYu" href="#p-eV6abyHMYu" tabindex="-1" role="presentation"></a>Queremos escribir un programa que imprima dos n√∫meros: el n√∫mero de vacas y de pollos en una granja, con las palabras <code>Vacas</code> y <code>Pollos</code> despu√©s de ellos y ceros rellenados antes de ambos n√∫meros para que siempre tengan tres d√≠gitos:</p>

<pre class="snippet" data-language="null" ><a class="c_ident" id="c-XuqI7+Jck5" href="#c-XuqI7+Jck5" tabindex="-1" role="presentation"></a>007 Vacas
011 Pollos</pre>

<p><a class="p_ident" id="p-SWekUgpMBV" href="#p-SWekUgpMBV" tabindex="-1" role="presentation"></a>Esto pide una funci√≥n con dos argumentos: el n√∫mero de vacas y el n√∫mero de pollos. ¬°Vamos a programar!</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-/gtNyE5+K6" href="#c-/gtNyE5+K6" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">imprimirInventarioGranja</span>(<span class="tok-definition">vacas</span>, <span class="tok-definition">pollos</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">cadenaVaca</span> = String(vacas);
  <span class="tok-keyword">while</span> (cadenaVaca.length &lt; <span class="tok-number">3</span>) {
    cadenaVaca = <span class="tok-string">&quot;0&quot;</span> + cadenaVaca;
  }
  console.log(<span class="tok-string2">`</span>${cadenaVaca}<span class="tok-string2"> Vacas`</span>);
  <span class="tok-keyword">let</span> <span class="tok-definition">cadenaPollo</span> = String(pollos);
  <span class="tok-keyword">while</span> (cadenaPollo.length &lt; <span class="tok-number">3</span>) {
    cadenaPollo = <span class="tok-string">&quot;0&quot;</span> + cadenaPollo;
  }
  console.log(<span class="tok-string2">`</span>${cadenaPollo}<span class="tok-string2"> Pollos`</span>);
}
imprimirInventarioGranja(<span class="tok-number">7</span>, <span class="tok-number">11</span>);</pre>

<p><a class="p_ident" id="p-WwhdZ7dyBy" href="#p-WwhdZ7dyBy" tabindex="-1" role="presentation"></a>Escribir <code>.length</code> despu√©s de una expresi√≥n de cadena nos dar√° la longitud de esa cadena. Por lo tanto, los bucles <code>while</code> siguen a√±adiendo ceros delante de las cadenas de n√∫meros hasta que tengan al menos tres caracteres de longitud.</p>

<p><a class="p_ident" id="p-/FAYGLBZga" href="#p-/FAYGLBZga" tabindex="-1" role="presentation"></a>¬°Misi√≥n cumplida! Pero justo cuando estamos a punto de enviarle a la granjera el c√≥digo (junto con una jugosa factura), ella llama y nos dice que tambi√©n ha comenzado a criar cerdos, ¬øpodr√≠amos extender el software para imprimir tambi√©n los cerdos?</p>

<p><a class="p_ident" id="p-lZT8zKVcfS" href="#p-lZT8zKVcfS" tabindex="-1" role="presentation"></a>¬°Claro que podemos! Pero justo cuando estamos en el proceso de copiar y pegar esas cuatro l√≠neas una vez m√°s, nos detenemos y reconsideramos. Tiene que haber una mejor manera. Aqu√≠ est√° un primer intento:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-dq2WbXrkyX" href="#c-dq2WbXrkyX" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">imprimirConRellenoYEtiqueta</span>(<span class="tok-definition">numero</span>, <span class="tok-definition">etiqueta</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">cadenaNumero</span> = String(numero);
  <span class="tok-keyword">while</span> (cadenaNumero.length &lt; <span class="tok-number">3</span>) {
    cadenaNumero = <span class="tok-string">&quot;0&quot;</span> + cadenaNumero;
  }
  console.log(<span class="tok-string2">`</span>${cadenaNumero}<span class="tok-string2"> </span>${etiqueta}<span class="tok-string2">`</span>);
}

<span class="tok-keyword">function</span> <span class="tok-definition">imprimirInventarioGranja</span>(<span class="tok-definition">vacas</span>, <span class="tok-definition">pollos</span>, <span class="tok-definition">cerdos</span>) {
  imprimirConRellenoYEtiqueta(vacas, <span class="tok-string">&quot;Vacas&quot;</span>);
  imprimirConRellenoYEtiqueta(pollos, <span class="tok-string">&quot;Pollos&quot;</span>);
  imprimirConRellenoYEtiqueta(cerdos, <span class="tok-string">&quot;Cerdos&quot;</span>);
}

imprimirInventarioGranja(<span class="tok-number">7</span>, <span class="tok-number">11</span>, <span class="tok-number">3</span>);</pre>

<p><a class="p_ident" id="p-t15OmMTGO1" href="#p-t15OmMTGO1" tabindex="-1" role="presentation"></a>¬°Funciona! Pero ese nombre, <code>imprimirConRellenoYEtiqueta</code>, es un poco inc√≥modo. Confluye tres cosas: imprimir, rellenar con ceros y a√±adir una etiqueta, en una sola funci√≥n.</p>

<p><a class="p_ident" id="p-86HqtiCBvL" href="#p-86HqtiCBvL" tabindex="-1" role="presentation"></a>En lugar de sacar la parte repetida de nuestro programa completamente, intentemos sacar un solo <em>concepto</em>:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-2LDxPR7isA" href="#c-2LDxPR7isA" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">rellenarConCeros</span>(<span class="tok-definition">numero</span>, <span class="tok-definition">ancho</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">cadena</span> = String(numero);
  <span class="tok-keyword">while</span> (cadena.length &lt; ancho) {
    cadena = <span class="tok-string">&quot;0&quot;</span> + cadena;
  }
  <span class="tok-keyword">return</span> cadena;
}

<span class="tok-keyword">function</span> <span class="tok-definition">imprimirInventarioGranja</span>(<span class="tok-definition">vacas</span>, <span class="tok-definition">pollos</span>, <span class="tok-definition">cerdos</span>) {
  console.log(<span class="tok-string2">`</span>${rellenarConCeros(vacas, <span class="tok-number">3</span>)}<span class="tok-string2"> Vacas`</span>);
  console.log(<span class="tok-string2">`</span>${rellenarConCeros(pollos, <span class="tok-number">3</span>)}<span class="tok-string2"> Pollos`</span>);
  console.log(<span class="tok-string2">`</span>${rellenarConCeros(cerdos, <span class="tok-number">3</span>)}<span class="tok-string2"> Cerdos`</span>);
}

imprimirInventarioGranja(<span class="tok-number">7</span>, <span class="tok-number">16</span>, <span class="tok-number">3</span>);</pre>

<p><a class="p_ident" id="p-Pp4JWQb2Da" href="#p-Pp4JWQb2Da" tabindex="-1" role="presentation"></a>Una funci√≥n con un nombre claro y obvio como <code>rellenarConCeros</code> hace que sea m√°s f√°cil para alguien que lee el c√≥digo entender qu√© hace. Adem√°s, una funci√≥n as√≠ es √∫til en m√°s situaciones que solo este programa espec√≠fico. Por ejemplo, podr√≠as usarla para ayudar a imprimir tablas de n√∫meros alineadas correctamente.</p>

<p><a class="p_ident" id="p-Pe3o8sCfTl" href="#p-Pe3o8sCfTl" tabindex="-1" role="presentation"></a>¬øQu√© tan inteligente y vers√°til <em>deber√≠a</em> ser nuestra funci√≥n? Podr√≠amos escribir cualquier cosa, desde una funci√≥n terriblemente simple que solo puede rellenar un n√∫mero para que tenga tres caracteres de ancho hasta un sistema complejo de formato de n√∫meros general que maneje n√∫meros fraccionarios, n√∫meros negativos, alineaci√≥n de puntos decimales, relleno con diferentes caracteres y m√°s.</p>

<p><a class="p_ident" id="p-CvP+uxDh/X" href="#p-CvP+uxDh/X" tabindex="-1" role="presentation"></a>Un principio √∫til es abstenerse de agregar ingenio a menos que est√©s absolutamente seguro de que lo vas a necesitar. Puede ser tentador escribir ‚Äúframeworks‚Äù gen√©ricos para cada trozo de funcionalidad que te encuentres. Resiste esa tentaci√≥n. No lograr√°s hacer ning√∫n trabajo real: estar√°s demasiado ocupado escribiendo c√≥digo que nunca usar√°s.</p>

<h2 id="puro"><a class="h_ident" id="h-FYE5dPFb4a" href="#h-FYE5dPFb4a" tabindex="-1" role="presentation"></a>Funciones y efectos secundarios</h2>

<p><a class="p_ident" id="p-WDphrqGwmP" href="#p-WDphrqGwmP" tabindex="-1" role="presentation"></a>Las funciones pueden dividirse aproximadamente en aquellas que se llaman por sus efectos secundarios y aquellas que se llaman por su valor de retorno (aunque tambi√©n es posible tener efectos secundarios y devolver un valor).</p>

<p><a class="p_ident" id="p-HhXOUWHo2Y" href="#p-HhXOUWHo2Y" tabindex="-1" role="presentation"></a>La primera funci√≥n auxiliar en el ejemplo de la granja, <code>imprimirConRellenoYEtiqueta</code>, se llama por su efecto secundario: imprime una l√≠nea. La segunda versi√≥n, <code>rellenarConCeros</code>, se llama por su valor de retorno. No es casualidad que la segunda sea √∫til en m√°s situaciones que la primera. Las funciones que crean valores son m√°s f√°ciles de combinar de nuevas formas que las funciones que realizan efectos secundarios directamente.</p>

<p><a class="p_ident" id="p-ZQPtksrZZc" href="#p-ZQPtksrZZc" tabindex="-1" role="presentation"></a>Una funci√≥n <em>pura</em> es un tipo espec√≠fico de funci√≥n productora de valor que no solo no tiene efectos secundarios, sino que tampoco depende de efectos secundarios de otro c√≥digo, por ejemplo, no lee enlaces globales cuyo valor podr√≠a cambiar. Una funci√≥n pura tiene la agradable propiedad de que, al llamarla con los mismos argumentos, siempre produce el mismo valor (y no hace nada m√°s). Una llamada a tal funci√≥n puede sustituirse por su valor de retorno sin cambiar el significado del c√≥digo. Cuando no est√°s seguro de si una funci√≥n pura est√° funcionando correctamente, puedes probarla llam√°ndola y saber que si funciona en ese contexto, funcionar√° en cualquier otro. Las funciones no puras tienden a requerir m√°s andamiaje para probarlas.</p>

<p><a class="p_ident" id="p-3s9sqQnXFN" href="#p-3s9sqQnXFN" tabindex="-1" role="presentation"></a>A√∫n as√≠, no hay necesidad de sentirse mal al escribir funciones que no son puras. Los efectos secundarios a menudo son √∫tiles. No hay forma de escribir una versi√≥n pura de <code>console.log</code>, por ejemplo, y es bueno tener <code>console.log</code>. Algunas operaciones tambi√©n son m√°s f√°ciles de expresar de manera eficiente cuando usamos efectos secundarios.</p>

<h2><a class="h_ident" id="h-NUFOUyK+lw" href="#h-NUFOUyK+lw" tabindex="-1" role="presentation"></a>Resumen</h2>

<p><a class="p_ident" id="p-/BH7LujdnN" href="#p-/BH7LujdnN" tabindex="-1" role="presentation"></a>Este cap√≠tulo te ense√±√≥ c√≥mo escribir tus propias funciones. La palabra clave <code>function</code>, cuando se usa como expresi√≥n, puede crear un valor de funci√≥n. Cuando se usa como una declaraci√≥n, puede usarse para declarar un enlace y darle una funci√≥n como su valor. Las funciones de flecha son otra forma de crear funciones.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-nraStLDxcy" href="#c-nraStLDxcy" tabindex="-1" role="presentation"></a><span class="tok-comment">// Definir f para contener un valor de funci√≥n</span>
<span class="tok-keyword">const</span> <span class="tok-definition">f</span> = <span class="tok-keyword">function</span>(<span class="tok-definition">a</span>) {
  console.log(a + <span class="tok-number">2</span>);
};

<span class="tok-comment">// Declarar g como una funci√≥n</span>
<span class="tok-keyword">function</span> <span class="tok-definition">g</span>(<span class="tok-definition">a</span>, <span class="tok-definition">b</span>) {
  <span class="tok-keyword">return</span> a * b * <span class="tok-number">3.5</span>;
}

<span class="tok-comment">// Un valor de funci√≥n menos verboso</span>
<span class="tok-keyword">let</span> <span class="tok-definition">h</span> = <span class="tok-definition">a</span> =&gt; a % <span class="tok-number">3</span>;</pre>

<p><a class="p_ident" id="p-0ZGPiC9ulA" href="#p-0ZGPiC9ulA" tabindex="-1" role="presentation"></a>Una parte clave para entender las funciones es comprender los √°mbitos (scopes). Cada bloque crea un nuevo √°mbito. Los par√°metros y los enlaces declarados en un √°mbito dado son locales y no son visibles desde el exterior. Los enlaces declarados con <code>var</code> se comportan de manera diferente: terminan en el √°mbito de la funci√≥n m√°s cercana o en el √°mbito global.</p>

<p><a class="p_ident" id="p-rUVLw2xd6X" href="#p-rUVLw2xd6X" tabindex="-1" role="presentation"></a>Separar las tareas que realiza tu programa en diferentes funciones es √∫til. No tendr√°s que repetirte tanto, y las funciones pueden ayudar a organizar un programa agrupando el c√≥digo en piezas que hacen cosas espec√≠ficas.</p>

<h2><a class="h_ident" id="h-tkm7ntLto1" href="#h-tkm7ntLto1" tabindex="-1" role="presentation"></a>Ejercicios</h2>

<h3><a class="i_ident" id="i-mzHH/MSSBA" href="#i-mzHH/MSSBA" tabindex="-1" role="presentation"></a>M√≠nimo</h3>

<p><a class="p_ident" id="p-F1St/b+Tyk" href="#p-F1St/b+Tyk" tabindex="-1" role="presentation"></a>El <a href="02_program_structure.html#return_values">cap√≠tulo previo</a> present√≥ la funci√≥n est√°ndar <code>Math.min</code> que devuelve su menor argumento. Ahora podemos escribir una funci√≥n como esa nosotros mismos. Define la funci√≥n <code>min</code> que toma dos argumentos y devuelve su m√≠nimo.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-YPzD49JsIQ" href="#c-YPzD49JsIQ" tabindex="-1" role="presentation"></a><span class="tok-comment">// Tu c√≥digo aqu√≠.</span>

console.log(min(<span class="tok-number">0</span>, <span class="tok-number">10</span>));
<span class="tok-comment">// ‚Üí 0</span>
console.log(min(<span class="tok-number">0</span>, -<span class="tok-number">10</span>));
<span class="tok-comment">// ‚Üí -10</span></pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-/a3wyCwq6P" href="#p-/a3wyCwq6P" tabindex="-1" role="presentation"></a>Si tienes problemas para colocar llaves y par√©ntesis en el lugar correcto para obtener una definici√≥n de funci√≥n v√°lida, comienza copiando uno de los ejemplos de este cap√≠tulo y modif√≠calo.</p>

<p><a class="p_ident" id="p-lcSp8UwPFN" href="#p-lcSp8UwPFN" tabindex="-1" role="presentation"></a>Una funci√≥n puede contener m√∫ltiples declaraciones <code>return</code>.</p>

</div></details>

<h3><a class="i_ident" id="i-ge3a45K3m3" href="#i-ge3a45K3m3" tabindex="-1" role="presentation"></a>Recursi√≥n</h3>

<p><a class="p_ident" id="p-BzLEOgMptN" href="#p-BzLEOgMptN" tabindex="-1" role="presentation"></a>Hemos visto que podemos usar <code>%</code> (el operador de resto) para verificar si un n√∫mero es par o impar al usar <code>% 2</code> para ver si es divisible por dos. Aqu√≠ hay otra forma de definir si un n√∫mero entero positivo es par o impar:</p>

<ul>

<li>

<p><a class="p_ident" id="p-ba/fxNiN56" href="#p-ba/fxNiN56" tabindex="-1" role="presentation"></a>El cero es par.</p></li>

<li>

<p><a class="p_ident" id="p-A5rVPAWrHm" href="#p-A5rVPAWrHm" tabindex="-1" role="presentation"></a>El uno es impar.</p></li>

<li>

<p><a class="p_ident" id="p-7c1vmInqwj" href="#p-7c1vmInqwj" tabindex="-1" role="presentation"></a>Para cualquier otro n√∫mero <em>N</em>, su paridad es la misma que <em>N</em> - 2.</p></li></ul>

<p><a class="p_ident" id="p-1AgC7/UeM8" href="#p-1AgC7/UeM8" tabindex="-1" role="presentation"></a>Define una funci√≥n recursiva <code>isEven</code> que corresponda a esta descripci√≥n. La funci√≥n debe aceptar un solo par√°metro (un n√∫mero entero positivo) y devolver un booleano.</p>

<p><a class="p_ident" id="p-31CyWM+ggI" href="#p-31CyWM+ggI" tabindex="-1" role="presentation"></a>Pru√©balo con 50 y 75. Observa c√≥mo se comporta con -1. ¬øPor qu√©? ¬øPuedes pensar en una forma de solucionarlo?</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-C/0z/P0DFi" href="#c-C/0z/P0DFi" tabindex="-1" role="presentation"></a><span class="tok-comment">// Tu c√≥digo aqu√≠.</span>

console.log(isEven(<span class="tok-number">50</span>));
<span class="tok-comment">// ‚Üí true</span>
console.log(isEven(<span class="tok-number">75</span>));
<span class="tok-comment">// ‚Üí false</span>
console.log(isEven(-<span class="tok-number">1</span>));
<span class="tok-comment">// ‚Üí ??</span></pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-9dAuiITSNm" href="#p-9dAuiITSNm" tabindex="-1" role="presentation"></a>Es probable que tu funci√≥n se parezca en cierta medida a la funci√≥n interna <code>encontrar</code> en el ejemplo recursivo <code>encontrarSolucion</code> <a href="03_functions.html#recursive_puzzle">ejemplo</a> de este cap√≠tulo, con una cadena <code>if</code>/<code>else if</code>/<code>else</code> que prueba cu√°l de los tres casos aplica. El <code>else</code> final, correspondiente al tercer caso, realiza la llamada recursiva. Cada una de las ramas debe contener una declaraci√≥n <code>return</code> o de alguna otra manera asegurarse de que se devuelva un valor espec√≠fico.</p>

<p><a class="p_ident" id="p-GSq+lWAHif" href="#p-GSq+lWAHif" tabindex="-1" role="presentation"></a>Cuando se le da un n√∫mero negativo, la funci√≥n se llamar√° recursivamente una y otra vez, pas√°ndose a s√≠ misma un n√∫mero cada vez m√°s negativo, alej√°ndose as√≠ m√°s y m√°s de devolver un resultado. Eventualmente se quedar√° sin espacio en la pila y se abortar√°.</p>

</div></details>

<h3><a class="i_ident" id="i-zSH1twIVoz" href="#i-zSH1twIVoz" tabindex="-1" role="presentation"></a>Contando frijoles</h3>

<p><a class="p_ident" id="p-oTwY6Ez8Oj" href="#p-oTwY6Ez8Oj" tabindex="-1" role="presentation"></a>Puedes obtener el *√©simo car√°cter, o letra, de una cadena escribiendo <code>[N]</code> despu√©s de la cadena (por ejemplo, <code>cadena[2]</code>). El valor resultante ser√° una cadena que contiene solo un car√°cter (por ejemplo, <code>&quot;b&quot;</code>). El primer car√°cter tiene la posici√≥n 0, lo que hace que el √∫ltimo se encuentre en la posici√≥n <code>cadena.<wbr>length - 1</code>. En otras palabras, una cadena de dos caracteres tiene longitud 2, y sus caracteres tienen posiciones 0 y 1.</p>

<p><a class="p_ident" id="p-w7W3kFYAvT" href="#p-w7W3kFYAvT" tabindex="-1" role="presentation"></a>Escribe una funci√≥n <code>contarBs</code> que tome una cadena como √∫nico argumento y devuelva un n√∫mero que indique cu√°ntos caracteres B en may√∫scula hay en la cadena.</p>

<p><a class="p_ident" id="p-ogbJyesqnN" href="#p-ogbJyesqnN" tabindex="-1" role="presentation"></a>A continuaci√≥n, escribe una funci√≥n llamada <code>contarCaracter</code> que se comporte como <code>contarBs</code>, excepto que toma un segundo argumento que indica el car√°cter que se va a contar (en lugar de contar solo caracteres B en may√∫scula). Reescribe <code>contarBs</code> para hacer uso de esta nueva funci√≥n.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-fTMxwrQQBV" href="#c-fTMxwrQQBV" tabindex="-1" role="presentation"></a><span class="tok-comment">// Your code here.</span>

console.log(countBs(<span class="tok-string">&quot;BOB&quot;</span>));
<span class="tok-comment">// ‚Üí 2</span>
console.log(countChar(<span class="tok-string">&quot;kakkerlak&quot;</span>, <span class="tok-string">&quot;k&quot;</span>));
<span class="tok-comment">// ‚Üí 4</span></pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-N+elrvhLar" href="#p-N+elrvhLar" tabindex="-1" role="presentation"></a>Tu funci√≥n necesida un bucle que mire cada car√°cter en la cadena. Puede ejecutar un √≠ndice desde cero hasta uno menos que su longitud (<code>&lt; string.<wbr>length</code>). Si el car√°cter en la posici√≥n actual es el mismo que el que la funci√≥n est√° buscando, agrega 1 a una variable de contador. Una vez que el bucle ha terminado, el contador puede ser devuelto.</p>

<p><a class="p_ident" id="p-DijC5CkxO1" href="#p-DijC5CkxO1" tabindex="-1" role="presentation"></a>Ten cuidado de que todas las vinculaciones utilizadas en la funci√≥n sean <em>locales</em> a la funci√≥n, declar√°ndolas correctamente con la palabra clave <code>let</code> o <code>const</code>.</p>

</div></details><nav><a href="02_program_structure.html" title="previous chapter" aria-label="previous chapter">‚óÇ</a>¬†<a href="index.html" title="cover" aria-label="cover">‚óè</a>¬†<a href="04_data.html" title="next chapter" aria-label="next chapter">‚ñ∏</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>&nbsp;<button class="dark-mode-toggle">üåô</button>
</nav>
</article>

<script src="ejs.js"></script>
