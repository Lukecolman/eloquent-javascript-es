<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Valores, Tipos y Operadores :: Eloquent JavaScript</title>
  <link rel=stylesheet href="css/ejs.css"><script>
      var page = {"type":"chapter","number":1}</script></head>

<article>
<nav><a href="00_intro.html" title="previous chapter" aria-label="previous chapter">‚óÇ</a>¬†<a href="index.html" title="cover" aria-label="cover">‚óè</a>¬†<a href="02_program_structure.html" title="next chapter" aria-label="next chapter">‚ñ∏</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>&nbsp;<button class="dark-mode-toggle">üåô</button>
</nav>

<h1>Valores, Tipos y Operadores</h1>

<blockquote>

<p><a class="p_ident" id="p-bpaGsABGGJ" href="#p-bpaGsABGGJ" tabindex="-1" role="presentation"></a>Debajo de la superficie de la m√°quina, el programa se mueve. Sin esfuerzo, se expande y contrae. En gran armon√≠a, los electrones se dispersan y se reagrupan. Las formas en el monitor no son m√°s que ondas en el agua. La esencia permanece invisible debajo.</p>

<footer>Master Yuan-Ma, <cite>El Libro de la Programaci√≥n</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_1.jpg" alt="Una foto de un mar de bits"></figure>

<p><a class="p_ident" id="p-5q3V1d0pX9" href="#p-5q3V1d0pX9" tabindex="-1" role="presentation"></a>En el mundo de la computadora, solo existe data. Puedes leer data, modificar data, crear nueva data, pero aquello que no es data no puede ser mencionado. Toda esta data se almacena como largas secuencias de bits y, por lo tanto, es fundamentalmente similar.</p>

<p><a class="p_ident" id="p-ufYtysiybY" href="#p-ufYtysiybY" tabindex="-1" role="presentation"></a><em>Los bits</em> son cualquier tipo de cosas de dos valores, generalmente descritos como ceros y unos. Dentro de la computadora, toman formas como una carga el√©ctrica alta o baja, una se√±al fuerte o d√©bil, o un punto brillante u opaco en la superficie de un CD. Cualquier pieza de informaci√≥n discreta puede reducirse a una secuencia de ceros y unos y por lo tanto representarse en bits.</p>

<p><a class="p_ident" id="p-e7UmOUc3PL" href="#p-e7UmOUc3PL" tabindex="-1" role="presentation"></a>Por ejemplo, podemos expresar el n√∫mero 13 en bits. Esto funciona de la misma manera que un n√∫mero decimal, pero en lugar de diez d√≠gitos diferentes, tenemos solo 2, y el peso de cada uno aumenta por un factor de 2 de derecha a izquierda. Aqu√≠ est√°n los bits que componen el n√∫mero 13, con los pesos de los d√≠gitos mostrados debajo de ellos:</p>

<pre class="snippet" data-language="null" ><a class="c_ident" id="c-+fMMNc3yUt" href="#c-+fMMNc3yUt" tabindex="-1" role="presentation"></a>   0   0   0   0   1   1   0   1
 128  64  32  16   8   4   2   1</pre>

<p><a class="p_ident" id="p-jb21kV7NPC" href="#p-jb21kV7NPC" tabindex="-1" role="presentation"></a>Ese es el n√∫mero binario 00001101. Sus d√≠gitos no nulos representan 8, 4 y 1, y suman 13.</p>

<h2><a class="h_ident" id="h-U9F8ZU147i" href="#h-U9F8ZU147i" tabindex="-1" role="presentation"></a>Valores</h2>

<p><a class="p_ident" id="p-ueMEhoC62i" href="#p-ueMEhoC62i" tabindex="-1" role="presentation"></a>Imagina una mar de bits‚Äîun oc√©ano de ellos. Una computadora moderna t√≠pica tiene m√°s de 100 mil millones de bits en su almacenamiento de datos vol√°til (memoria de trabajo). El almacenamiento no vol√°til (el disco duro o equivalente) tiende a tener a√∫n unos cuantos √≥rdenes de magnitud m√°s.</p>

<p><a class="p_ident" id="p-f1AoXKYSbn" href="#p-f1AoXKYSbn" tabindex="-1" role="presentation"></a>Para poder trabajar con tales cantidades de bits sin perderse, los separamos en trozos que representan piezas de informaci√≥n. En un entorno de JavaScript, esos trozos se llaman <em>valores</em>. Aunque todos los valores est√°n hechos de bits, desempe√±an roles diferentes. Cada valor tiene un tipo que determina su funci√≥n. Algunos valores son n√∫meros, otros son fragmentos de texto, otros son funciones, y as√≠ sucesivamente.</p>

<p><a class="p_ident" id="p-mJiLbj24GZ" href="#p-mJiLbj24GZ" tabindex="-1" role="presentation"></a>Para crear un valor, simplemente debes invocar su nombre. Esto es conveniente. No tienes que recolectar material de construcci√≥n para tus valores ni pagar por ellos. Solo solicitas uno, y ¬°zas!, lo tienes. Por supuesto, los valores no se crean realmente de la nada. Cada uno tiene que almacenarse en alg√∫n lugar, y si deseas usar gigantescas cantidades de ellos al mismo tiempo, podr√≠as quedarte sin memoria de computadora. Afortunadamente, este es un problema solo si los necesitas todos simult√°neamente. Tan pronto como dejes de usar un valor, se disipar√°, dejando atr√°s sus bits para ser reciclados como material de construcci√≥n para la pr√≥xima generaci√≥n de valores. El resto de este cap√≠tulo presenta los elementos at√≥micos de los programas de JavaScript, es decir, los tipos de valores simples y los operadores que pueden actuar sobre dichos valores.</p>

<h2><a class="h_ident" id="h-2eDSr4FTTr" href="#h-2eDSr4FTTr" tabindex="-1" role="presentation"></a>N√∫meros</h2>

<p><a class="p_ident" id="p-bOZDjE7yem" href="#p-bOZDjE7yem" tabindex="-1" role="presentation"></a>Los valores del tipo <em>number</em> son, como era de esperar, valores num√©ricos. En un programa de JavaScript, se escriben de la siguiente manera:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-/u5ErTZbax" href="#c-/u5ErTZbax" tabindex="-1" role="presentation"></a><span class="tok-number">13</span></pre>

<p><a class="p_ident" id="p-2b0WdUMWiY" href="#p-2b0WdUMWiY" tabindex="-1" role="presentation"></a>Usar esto en un programa har√° que el patr√≥n de bits para el n√∫mero 13 exista en la memoria del ordenador.</p>

<p><a class="p_ident" id="p-iNSri5YZBd" href="#p-iNSri5YZBd" tabindex="-1" role="presentation"></a>JavaScript utiliza un n√∫mero fijo de bits, 64 de ellos, para almacenar un √∫nico valor num√©rico. Hay un n√∫mero limitado de patrones que puedes hacer con 64 bits, lo que limita la cantidad de n√∫meros diferentes que se pueden representar. Con <em>N</em> d√≠gitos decimales, puedes representar 10<sup>N</sup> n√∫meros. De manera similar, dada una cifra de 64 d√≠gitos binarios, puedes representar 2<sup>64</sup> n√∫meros diferentes, que son alrededor de 18 mil trillones (un 18 seguido de 18 ceros). Eso es mucho.</p>

<p><a class="p_ident" id="p-zoQfMGsjpS" href="#p-zoQfMGsjpS" tabindex="-1" role="presentation"></a>La memoria de la computadora sol√≠a ser mucho m√°s peque√±a, y la gente sol√≠a utilizar grupos de 8 o 16 bits para representar sus n√∫meros. Era f√°cil tener un <em>desbordamiento</em> accidental con n√∫meros tan peque√±os, terminando con un n√∫mero que no encajaba en la cantidad dada de bits. Hoy en d√≠a, incluso las computadoras que caben en tu bolsillo tienen mucha memoria, por lo que puedes utilizar trozos de 64 bits y solo necesitas preocuparte por el desbordamiento cuando lidias con n√∫meros realmente astron√≥micos.</p>

<p><a class="p_ident" id="p-g9ZdolZbnN" href="#p-g9ZdolZbnN" tabindex="-1" role="presentation"></a>Sin embargo, no todos los n√∫meros enteros menores que 18 mil trillones encajan en un n√∫mero de JavaScript. Esos bits tambi√©n almacenan n√∫meros negativos, por lo que un bit indica el signo del n√∫mero. Un problema m√°s grande es representar n√∫meros no enteros. Para hacer esto, algunos de los bits se utilizan para almacenar la posici√≥n del punto decimal. El n√∫mero entero m√°ximo real que se puede almacenar est√° m√°s en el rango de 9 cuatrillones (15 ceros), que sigue siendo incre√≠blemente grande.</p>

<p><a class="p_ident" id="p-QuaxCY0XYg" href="#p-QuaxCY0XYg" tabindex="-1" role="presentation"></a>Los n√∫meros fraccionarios se escriben usando un punto:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-tM8nqv41Gp" href="#c-tM8nqv41Gp" tabindex="-1" role="presentation"></a><span class="tok-number">9.81</span></pre>

<p><a class="p_ident" id="p-swGkw2BgKN" href="#p-swGkw2BgKN" tabindex="-1" role="presentation"></a>Para n√∫meros muy grandes o muy peque√±os, tambi√©n puedes usar notaci√≥n cient√≠fica agregando una <em>e</em> (de <em>exponente</em>), seguida del exponente del n√∫mero:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-6ew5w+VhSM" href="#c-6ew5w+VhSM" tabindex="-1" role="presentation"></a><span class="tok-number">2.998e8</span></pre>

<p><a class="p_ident" id="p-vx7ox7vlBw" href="#p-vx7ox7vlBw" tabindex="-1" role="presentation"></a>Eso es 2.998 √ó 10<sup>8</sup> = 299,800,000.</p>

<p><a class="p_ident" id="p-At4IfW0/+5" href="#p-At4IfW0/+5" tabindex="-1" role="presentation"></a>Los c√°lculos con n√∫meros enteros (tambi√©n llamados <em>enteros</em>) que son m√°s peque√±os que los mencionados 9 cuatrillones siempre ser√°n precisos. Desafortunadamente, los c√°lculos con n√∫meros fraccionarios generalmente no lo son. As√≠ como œÄ (pi) no puede expresarse con precisi√≥n mediante un n√∫mero finito de d√≠gitos decimales, muchos n√∫meros pierden algo de precisi√≥n cuando solo est√°n disponibles 64 bits para almacenarlos. Es una l√°stima, pero solo causa problemas pr√°cticos en situaciones espec√≠ficas. Lo importante es ser consciente de esto y tratar los n√∫meros digitales fraccionarios como aproximaciones, no como valores precisos.</p>

<h3><a class="i_ident" id="i-aIf95z3S0d" href="#i-aIf95z3S0d" tabindex="-1" role="presentation"></a>Aritm√©tica</h3>

<p><a class="p_ident" id="p-fEl5oInJjs" href="#p-fEl5oInJjs" tabindex="-1" role="presentation"></a>Lo principal que se puede hacer con los n√∫meros es la aritm√©tica. Operaciones aritm√©ticas como la suma o la multiplicaci√≥n toman dos valores num√©ricos y producen un nuevo n√∫mero a partir de ellos. As√≠ es como se ven en JavaScript:</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-meta="expr"><a class="c_ident" id="c-bSU4Vtv/mt" href="#c-bSU4Vtv/mt" tabindex="-1" role="presentation"></a><span class="tok-number">100</span> + <span class="tok-number">4</span> * <span class="tok-number">11</span></pre>

<p><a class="p_ident" id="p-PNPKgKWrHK" href="#p-PNPKgKWrHK" tabindex="-1" role="presentation"></a>Los s√≠mbolos <code>+</code> y <code>*</code> se llaman <em>operadores</em>. El primero representa la suma y el segundo representa la multiplicaci√≥n. Colocar un operador entre dos valores aplicar√° ese operador a esos valores y producir√° un nuevo valor.</p>

<p><a class="p_ident" id="p-rbQOL3GnYq" href="#p-rbQOL3GnYq" tabindex="-1" role="presentation"></a>¬øSignifica este ejemplo ‚ÄúSumar 4 y 100, y luego multiplicar el resultado por 11‚Äù, o se realiza primero la multiplicaci√≥n antes de la suma? Como habr√°s adivinado, la multiplicaci√≥n se realiza primero. Como en matem√°ticas, puedes cambiar esto envolviendo la suma entre par√©ntesis:</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-meta="expr"><a class="c_ident" id="c-ij6V90ZZBQ" href="#c-ij6V90ZZBQ" tabindex="-1" role="presentation"></a>(<span class="tok-number">100</span> + <span class="tok-number">4</span>) * <span class="tok-number">11</span></pre>

<p><a class="p_ident" id="p-e9lhSXZbdW" href="#p-e9lhSXZbdW" tabindex="-1" role="presentation"></a>Para la resta, est√° el operador <code>-</code>. La divisi√≥n se puede hacer con el operador <code>/</code>.</p>

<p><a class="p_ident" id="p-OJONCWoI1T" href="#p-OJONCWoI1T" tabindex="-1" role="presentation"></a>Cuando los operadores aparecen juntos sin par√©ntesis, el orden en que se aplican se determina por la <em>precedencia</em> de los operadores. El ejemplo muestra que la multiplicaci√≥n se realiza antes que la suma. El operador <code>/</code> tiene la misma precedencia que <code>*</code>. Igualmente, <code>+</code> y <code>-</code> tienen la misma precedencia. Cuando varios operadores con la misma precedencia aparecen uno al lado del otro, como en <code>1 - 2 + 1</code>, se aplican de izquierda a derecha: <code>(1 - 2) + 1</code>.</p>

<p><a class="p_ident" id="p-icq/wIw6Tp" href="#p-icq/wIw6Tp" tabindex="-1" role="presentation"></a>No te preocupes demasiado por estas reglas de precedencia. Cuando tengas dudas, simplemente agrega par√©ntesis.</p>

<p><a class="p_ident" id="p-6mDQ8afNaM" href="#p-6mDQ8afNaM" tabindex="-1" role="presentation"></a>Hay un operador aritm√©tico m√°s, que quiz√°s no reconozcas de inmediato. El s√≠mbolo <code>%</code> se utiliza para representar la operaci√≥n de <em>residuo</em>. <code>X % Y</code> es el residuo de dividir <code>X</code> por <code>Y</code>. Por ejemplo, <code>314 % 100</code> produce <code>14</code>, y <code>144 % 12</code> da <code>0</code>. La precedencia del operador de residuo es la misma que la de multiplicaci√≥n y divisi√≥n. Tambi√©n ver√°s a menudo a este operador referido como <em>m√≥dulo</em>.</p>

<h3><a class="i_ident" id="i-zFIgofBZed" href="#i-zFIgofBZed" tabindex="-1" role="presentation"></a>N√∫meros especiales</h3>

<p><a class="p_ident" id="p-Yzdmqjc9np" href="#p-Yzdmqjc9np" tabindex="-1" role="presentation"></a>Hay tres valores especiales en JavaScript que se consideran n√∫meros pero no se comportan como n√∫meros normales. Los dos primeros son <code>Infinity</code> y <code>-Infinity</code>, que representan el infinito positivo y negativo. <code>Infinity - 1</code> sigue siendo <code>Infinity</code>, y as√≠ sucesivamente. Sin embargo, no conf√≠es demasiado en los c√°lculos basados en infinito. No es matem√°ticamente s√≥lido y r√°pidamente te llevar√° al siguiente n√∫mero especial: <code>NaN</code>.</p>

<p><a class="p_ident" id="p-FTEAETPV0R" href="#p-FTEAETPV0R" tabindex="-1" role="presentation"></a><code>NaN</code> significa ‚Äúno es un n√∫mero‚Äù, aunque <em>es</em> un valor del tipo num√©rico. Obtendr√°s este resultado cuando, por ejemplo, intentes calcular <code>0 / 0</code> (cero dividido por cero), <code>Infinity - Infinity</code>, u cualquier otra operaci√≥n num√©rica que no produzca un resultado significativo.</p>

<h2><a class="h_ident" id="h-J4o1MED4vw" href="#h-J4o1MED4vw" tabindex="-1" role="presentation"></a>Cadenas</h2>

<p><a class="p_ident" id="p-LSngdQYH80" href="#p-LSngdQYH80" tabindex="-1" role="presentation"></a>El siguiente tipo de dato b√°sico es la <em>cadena</em>. Las cadenas se utilizan para representar texto. Se escriben encerrando su contenido entre comillas.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-qjwe3Dgr5R" href="#c-qjwe3Dgr5R" tabindex="-1" role="presentation"></a><span class="tok-string2">`En el mar`</span>
<span class="tok-string">&quot;Acostado en el oc√©ano&quot;</span>
<span class="tok-string">'Flotando en el oc√©ano'</span></pre>

<p><a class="p_ident" id="p-IHr2y937ks" href="#p-IHr2y937ks" tabindex="-1" role="presentation"></a>Puedes usar comillas simples, comillas dobles o acentos graves para marcar las cadenas, siempre y cuando las comillas al principio y al final de la cadena coincidan.</p>

<p><a class="p_ident" id="p-FbJ7LdbtTG" href="#p-FbJ7LdbtTG" tabindex="-1" role="presentation"></a>Puedes poner casi cualquier cosa entre comillas para que JavaScript genere un valor de cadena a partir de ello. Pero algunos caracteres son m√°s dif√≠ciles. Puedes imaginar lo complicado que ser√≠a poner comillas entre comillas, ya que parecer√≠an el final de la cadena. <em>Saltos de l√≠nea</em> (los caracteres que obtienes al presionar <span class="keyname">enter</span>) solo se pueden incluir cuando la cadena est√° entre acentos graves (<code>`</code>).</p>

<p><a class="p_ident" id="p-EcZzTv5ywl" href="#p-EcZzTv5ywl" tabindex="-1" role="presentation"></a>Para poder incluir dichos caracteres en una cadena, se utiliza la siguiente notaci√≥n: una barra invertida (<code>\</code>) dentro de un texto entre comillas indica que el car√°cter posterior tiene un significado especial. Esto se llama <em>escapar</em> el car√°cter. Una comilla que va precedida por una barra invertida no finalizar√° la cadena, sino que formar√° parte de ella. Cuando un car√°cter <code>n</code> aparece despu√©s de una barra invertida, se interpreta como un salto de l√≠nea. De manera similar, un <code>t</code> despu√©s de una barra invertida significa un car√°cter de tabulaci√≥n. Toma la siguiente cadena:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-3CI2v7hMPn" href="#c-3CI2v7hMPn" tabindex="-1" role="presentation"></a><span class="tok-string">&quot;Esta es la primera l√≠nea</span><span class="tok-string2">\n</span><span class="tok-string">Y esta es la segunda&quot;</span></pre>

<p><a class="p_ident" id="p-WlFCbJE05Z" href="#p-WlFCbJE05Z" tabindex="-1" role="presentation"></a>Este es el texto real de esa cadena:</p>

<pre class="snippet" data-language="null" ><a class="c_ident" id="c-fV5QN7Aj+D" href="#c-fV5QN7Aj+D" tabindex="-1" role="presentation"></a>Esta es la primera l√≠nea
Y esta es la segunda</pre>

<p><a class="p_ident" id="p-RWoLLBFRNt" href="#p-RWoLLBFRNt" tabindex="-1" role="presentation"></a>Por supuesto, hay situaciones en las que deseas que una barra invertida en una cadena sea simplemente una barra invertida, no un c√≥digo especial. Si dos barras invertidas van seguidas, se colapsar√°n juntas y solo quedar√° una en el valor de cadena resultante. As√≠ es como se puede expresar la cadena ‚Äú<em>Un car√°cter de nueva l√≠nea se escribe como <code>&quot;</code>\n<code>&quot;</code>.</em>‚Äù:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-vqlaw2tox2" href="#c-vqlaw2tox2" tabindex="-1" role="presentation"></a><span class="tok-string">&quot;Un car√°cter de nueva l√≠nea se escribe como </span><span class="tok-string2">\&quot;</span><span class="tok-string2">\\</span><span class="tok-string">n</span><span class="tok-string2">\&quot;</span><span class="tok-string">.&quot;</span></pre>

<p id="unicode"><a class="p_ident" id="p-mbzJaYAs/g" href="#p-mbzJaYAs/g" tabindex="-1" role="presentation"></a>Las cadenas tambi√©n deben ser modeladas como una serie de bits para poder existir dentro de la computadora. La forma en que JavaScript lo hace se basa en el est√°ndar <em>Unicode</em>. Este est√°ndar asigna un n√∫mero a pr√°cticamente cada car√°cter que puedas necesitar, incluidos los caracteres griegos, √°rabes, japoneses, armenios, y as√≠ sucesivamente. Si tenemos un n√∫mero para cada car√°cter, una cadena puede ser descrita por una secuencia de n√∫meros. Y eso es lo que hace JavaScript.</p>

<p><a class="p_ident" id="p-Ygjt4M8HFV" href="#p-Ygjt4M8HFV" tabindex="-1" role="presentation"></a>Sin embargo, hay una complicaci√≥n: la representaci√≥n de JavaScript utiliza 16 bits por elemento de cadena, lo que puede describir hasta 2<sup>16</sup> caracteres diferentes. Sin embargo, Unicode define m√°s caracteres que eso ‚Äîaproximadamente el doble, en este momento. Por lo tanto, algunos caracteres, como muchos emoji, ocupan dos ‚Äúposiciones de caracteres‚Äù en las cadenas de JavaScript. Volveremos a esto en el <a href="05_higher_order.html#code_units">Cap√≠tulo 5</a>.</p>

<p><a class="p_ident" id="p-yVQTjTfX8O" href="#p-yVQTjTfX8O" tabindex="-1" role="presentation"></a>Las cadenas no se pueden dividir, multiplicar o restar. El operador <code>+</code> se puede usar en ellas, no para sumar, sino para <em>concatenar</em> ‚Äîunir dos cadenas. La siguiente l√≠nea producir√° la cadena <code>&quot;concatenar&quot;</code>:</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-meta="expr"><a class="c_ident" id="c-AF1pg1pIWq" href="#c-AF1pg1pIWq" tabindex="-1" role="presentation"></a><span class="tok-string">&quot;con&quot;</span> + <span class="tok-string">&quot;cat&quot;</span> + <span class="tok-string">&quot;e&quot;</span> + <span class="tok-string">&quot;nar&quot;</span></pre>

<p><a class="p_ident" id="p-lOVOo+omcp" href="#p-lOVOo+omcp" tabindex="-1" role="presentation"></a>Los valores de cadena tienen una serie de funciones asociadas (<em>m√©todos</em>) que se pueden utilizar para realizar otras operaciones con ellos. Hablar√© m√°s sobre esto en el <a href="04_data.html#methods">Cap√≠tulo 4</a>.</p>

<p><a class="p_ident" id="p-ihSs5peL7s" href="#p-ihSs5peL7s" tabindex="-1" role="presentation"></a>Las cadenas escritas con comillas simples o dobles se comportan de manera muy similar, la √∫nica diferencia radica en qu√© tipo de comilla necesitas escapar dentro de ellas. Las cadenas entre acentos graves, generalmente llamadas <em>template literals</em>, pueden hacer algunas cosas m√°s. Aparte de poder abarcar varias l√≠neas, tambi√©n pueden incrustar otros valores.</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-meta="expr"><a class="c_ident" id="c-Q70paqTNYa" href="#c-Q70paqTNYa" tabindex="-1" role="presentation"></a><span class="tok-string2">`la mitad de 100 es </span>${<span class="tok-number">100</span> / <span class="tok-number">2</span>}<span class="tok-string2">`</span></pre>

<p><a class="p_ident" id="p-6tfJCNVaMB" href="#p-6tfJCNVaMB" tabindex="-1" role="presentation"></a>Cuando escribes algo dentro de <code>${}</code> en una plantilla literal, su resultado se calcular√°, se convertir√° en una cadena y se incluir√° en esa posici√≥n. Este ejemplo produce ‚Äú<em>la mitad de 100 es 50</em>‚Äù.</p>

<h2><a class="h_ident" id="h-Ba/lVluC/D" href="#h-Ba/lVluC/D" tabindex="-1" role="presentation"></a>Operadores unarios</h2>

<p><a class="p_ident" id="p-301hsEim2E" href="#p-301hsEim2E" tabindex="-1" role="presentation"></a>No todos los operadores son s√≠mbolos. Algunos se escriben como palabras. Un ejemplo es el operador <code>typeof</code>, que produce un valor de cadena que indica el tipo del valor que le proporcionas.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-iWT//VyY7j" href="#c-iWT//VyY7j" tabindex="-1" role="presentation"></a>console.log(<span class="tok-keyword">typeof</span> <span class="tok-number">4.5</span>)
<span class="tok-comment">// ‚Üí number</span>
console.log(<span class="tok-keyword">typeof</span> <span class="tok-string">&quot;x&quot;</span>)
<span class="tok-comment">// ‚Üí string</span></pre>

<p id="console.log"><a class="p_ident" id="p-8bF6kfCQe4" href="#p-8bF6kfCQe4" tabindex="-1" role="presentation"></a>Utilizaremos <code>console.log</code> en ejemplos de c√≥digo para indicar que queremos ver el resultado de evaluar algo. M√°s sobre eso en el <a href="02_program_structure.html">pr√≥ximo cap√≠tulo</a>.</p>

<p><a class="p_ident" id="p-IOtfkjfLvQ" href="#p-IOtfkjfLvQ" tabindex="-1" role="presentation"></a>Los otros operadores mostrados hasta ahora en este cap√≠tulo operaron sobre dos valores, pero <code>typeof</code> toma solo uno. Los operadores que utilizan dos valores se llaman operadores <em>binarios</em>, mientras que aquellos que toman uno se llaman operadores <em>unarios</em>. El operador menos se puede usar tanto como un operador binario como un operador unario.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-VpL89RFAPj" href="#c-VpL89RFAPj" tabindex="-1" role="presentation"></a>console.log(- (<span class="tok-number">10</span> - <span class="tok-number">2</span>))
<span class="tok-comment">// ‚Üí -8</span></pre>

<h2><a class="h_ident" id="h-hcL3SuiDyH" href="#h-hcL3SuiDyH" tabindex="-1" role="presentation"></a>Valores booleanos</h2>

<p><a class="p_ident" id="p-a0eGPQEgO5" href="#p-a0eGPQEgO5" tabindex="-1" role="presentation"></a>A menudo es √∫til tener un valor que distinga solo entre dos posibilidades, como ‚Äús√≠&quot; y ‚Äúno‚Äù o ‚Äúencendido‚Äù y ‚Äúapagado‚Äù. Para este prop√≥sito, JavaScript tiene un tipo <em>Booleano</em>, que tiene solo dos valores, true y false, escritos como esas palabras.</p>

<h3><a class="i_ident" id="i-j8pkHXp4wK" href="#i-j8pkHXp4wK" tabindex="-1" role="presentation"></a>Comparaci√≥n</h3>

<p><a class="p_ident" id="p-9jdGN2oSxe" href="#p-9jdGN2oSxe" tabindex="-1" role="presentation"></a>Aqu√≠ hay una forma de producir valores booleanos:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-GaxnXrIPwC" href="#c-GaxnXrIPwC" tabindex="-1" role="presentation"></a>console.log(<span class="tok-number">3</span> &gt; <span class="tok-number">2</span>)
<span class="tok-comment">// ‚Üí true</span>
console.log(<span class="tok-number">3</span> &lt; <span class="tok-number">2</span>)
<span class="tok-comment">// ‚Üí false</span></pre>

<p><a class="p_ident" id="p-RXzYYl/NBh" href="#p-RXzYYl/NBh" tabindex="-1" role="presentation"></a>Los signos <code>&gt;</code> y <code>&lt;</code> son s√≠mbolos tradicionales para ‚Äúes mayor que‚Äù y ‚Äúes menor que‚Äù, respectivamente. Son operadores binarios. Aplicarlos da como resultado un valor booleano que indica si son verdaderos en este caso.</p>

<p><a class="p_ident" id="p-Ch4A0mWDGs" href="#p-Ch4A0mWDGs" tabindex="-1" role="presentation"></a>Las cadenas se pueden comparar de la misma manera:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Qud5plnVuV" href="#c-Qud5plnVuV" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">&quot;Aardvark&quot;</span> &lt; <span class="tok-string">&quot;Zoroaster&quot;</span>)
<span class="tok-comment">// ‚Üí true</span></pre>

<p><a class="p_ident" id="p-D+mD6K0/Wd" href="#p-D+mD6K0/Wd" tabindex="-1" role="presentation"></a>La forma en que se ordenan las cadenas es aproximadamente alfab√©tica pero no es realmente lo que esperar√≠as ver en un diccionario: las letras may√∫sculas son siempre ‚Äúmenores‚Äù que las min√∫sculas, por lo que <code>&quot;Z&quot; &lt; &quot;a&quot;</code>, y los caracteres no alfab√©ticos (!, -, y as√≠ sucesivamente) tambi√©n se incluyen en la ordenaci√≥n. Al comparar cadenas, JavaScript recorre los caracteres de izquierda a derecha, comparando los c√≥digos Unicode uno por uno.</p>

<p><a class="p_ident" id="p-LWMB/exwEI" href="#p-LWMB/exwEI" tabindex="-1" role="presentation"></a>Otros operadores similares son <code>&gt;=</code> (mayor o igual que), <code>&lt;=</code> (menor o igual que), <code>==</code> (igual a), y <code>!=</code> (no igual a).</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-iej8kEEcWL" href="#c-iej8kEEcWL" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">&quot;Granate&quot;</span> != <span class="tok-string">&quot;Rub√≠&quot;</span>)
<span class="tok-comment">// ‚Üí true</span>
console.log(<span class="tok-string">&quot;Perla&quot;</span> == <span class="tok-string">&quot;Amatista&quot;</span>)
<span class="tok-comment">// ‚Üí false</span></pre>

<p><a class="p_ident" id="p-qeF5rEgoVg" href="#p-qeF5rEgoVg" tabindex="-1" role="presentation"></a>Solo hay un valor en JavaScript que no es igual a s√≠ mismo, y ese es <code>NaN</code> (‚Äúno es un n√∫mero‚Äù).</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Vhz09Rgw3h" href="#c-Vhz09Rgw3h" tabindex="-1" role="presentation"></a>console.log(NaN == NaN)
<span class="tok-comment">// ‚Üí false</span></pre>

<p><a class="p_ident" id="p-sYaVOKvJs0" href="#p-sYaVOKvJs0" tabindex="-1" role="presentation"></a><code>NaN</code> se supone que denota el resultado de un c√°lculo sin sentido y, como tal, no es igual al resultado de ning√∫n otro c√°lculo sin sentido.</p>

<h3><a class="i_ident" id="i-gt6oADpxuG" href="#i-gt6oADpxuG" tabindex="-1" role="presentation"></a>Operadores l√≥gicos</h3>

<p><a class="p_ident" id="p-bDUM8R6qD8" href="#p-bDUM8R6qD8" tabindex="-1" role="presentation"></a>Tambi√©n hay algunas operaciones que se pueden aplicar a los propios valores Booleanos. JavaScript soporta tres operadores l√≥gicos: <em>and</em> (y), <em>or</em> (o), y <em>not</em> (no). Estos se pueden usar para ‚Äúrazonar‚Äù sobre valores Booleanos.</p>

<p><a class="p_ident" id="p-IlZiB/NoWt" href="#p-IlZiB/NoWt" tabindex="-1" role="presentation"></a>El operador <code>&amp;&amp;</code> representa el <em>and</em> l√≥gico. Es un operador binario, y su resultado es verdadero solo si ambos valores dados son verdaderos.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-SHi38sNkwM" href="#c-SHi38sNkwM" tabindex="-1" role="presentation"></a>console.log(true &amp;&amp; false)
<span class="tok-comment">// ‚Üí false</span>
console.log(true &amp;&amp; true)
<span class="tok-comment">// ‚Üí true</span></pre>

<p><a class="p_ident" id="p-CUv4iRpVzs" href="#p-CUv4iRpVzs" tabindex="-1" role="presentation"></a>El operador <code>||</code> representa el <em>or</em> l√≥gico. Produce verdadero si cualquiera de los valores dados es verdadero.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-diXyv7iPd1" href="#c-diXyv7iPd1" tabindex="-1" role="presentation"></a>console.log(false || true)
<span class="tok-comment">// ‚Üí true</span>
console.log(false || false)
<span class="tok-comment">// ‚Üí false</span></pre>

<p><a class="p_ident" id="p-yd+g1Em++r" href="#p-yd+g1Em++r" tabindex="-1" role="presentation"></a><em>Not</em> se escribe con un signo de exclamaci√≥n (<code>!</code>). Es un operador unario que invierte el valor dado; <code>!true</code> produce <code>false</code> y <code>!false</code> produce <code>true</code>.</p>

<p><a class="p_ident" id="p-93dQyS+qYG" href="#p-93dQyS+qYG" tabindex="-1" role="presentation"></a>Al combinar estos operadores Booleanos con operadores aritm√©ticos y otros operadores, no siempre es obvio cu√°ndo se necesitan par√©ntesis. En la pr√°ctica, generalmente puedes avanzar sabiendo que de los operadores que hemos visto hasta ahora, <code>||</code> tiene la menor precedencia, luego viene <code>&amp;&amp;</code>, luego los operadores de comparaci√≥n (<code>&gt;</code>, <code>==</code>, etc.), y luego el resto. Este orden ha sido elegido de tal manera que, en expresiones t√≠picas como la siguiente, se necesiten la menor cantidad de par√©ntesis posible:</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-meta="expr"><a class="c_ident" id="c-6eZ07bDo11" href="#c-6eZ07bDo11" tabindex="-1" role="presentation"></a><span class="tok-number">1</span> + <span class="tok-number">1</span> == <span class="tok-number">2</span> &amp;&amp; <span class="tok-number">10</span> * <span class="tok-number">10</span> &gt; <span class="tok-number">50</span></pre>

<p><a class="p_ident" id="p-UiSwCiAKjN" href="#p-UiSwCiAKjN" tabindex="-1" role="presentation"></a>El √∫ltimo operador l√≥gico que veremos no es unario ni binario, sino <em>ternario</em>, operando en tres valores. Se escribe con un signo de interrogaci√≥n y dos puntos, as√≠:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-G7eVm8ilWm" href="#c-G7eVm8ilWm" tabindex="-1" role="presentation"></a>console.log(true ? <span class="tok-number">1</span> : <span class="tok-number">2</span>);
<span class="tok-comment">// ‚Üí 1</span>
console.log(false ? <span class="tok-number">1</span> : <span class="tok-number">2</span>);
<span class="tok-comment">// ‚Üí 2</span></pre>

<p><a class="p_ident" id="p-iVFzSp2zoP" href="#p-iVFzSp2zoP" tabindex="-1" role="presentation"></a>Este se llama el operador <em>condicional</em> (o a veces simplemente <em>el operador ternario</em> ya que es el √∫nico operador de este tipo en el lenguaje). El operador usa el valor a la izquierda del signo de interrogaci√≥n para decidir cu√°l de los otros dos valores ‚Äúelegir‚Äù. Si escribes <code>a ? b : c</code>, el resultado ser√° <code>b</code> cuando <code>a</code> es verdadero y <code>c</code> de lo contrario.</p>

<h2><a class="h_ident" id="h-u3yR/DNtwV" href="#h-u3yR/DNtwV" tabindex="-1" role="presentation"></a>Valores vac√≠os</h2>

<p><a class="p_ident" id="p-u9OVOcj2FK" href="#p-u9OVOcj2FK" tabindex="-1" role="presentation"></a>Hay dos valores especiales, escritos <code>null</code> y <code>undefined</code>, que se utilizan para denotar la ausencia de un valor <em>significativo</em>. Son valores en s√≠ mismos, pero no llevan ninguna informaci√≥n. Muchas operaciones en el lenguaje que no producen un valor significativo devuelven <code>undefined</code> simplemente porque tienen que devolver <em>alg√∫n</em> valor.</p>

<p><a class="p_ident" id="p-m+cr0CKvEq" href="#p-m+cr0CKvEq" tabindex="-1" role="presentation"></a>La diferencia en el significado entre <code>undefined</code> y <code>null</code> es un accidente del dise√±o de JavaScript, y la mayor√≠a de las veces no importa. En casos en los que realmente tienes que preocuparte por estos valores, recomiendo tratarlos como en su mayor√≠a intercambiables.</p>

<h2><a class="h_ident" id="h-d0EfIV+05Q" href="#h-d0EfIV+05Q" tabindex="-1" role="presentation"></a>Conversi√≥n autom√°tica de tipos</h2>

<p><a class="p_ident" id="p-hiiKbgQYbK" href="#p-hiiKbgQYbK" tabindex="-1" role="presentation"></a>En la Introducci√≥n, mencion√© que JavaScript se esfuerza por aceptar casi cualquier programa que le des, incluso programas que hacen cosas extra√±as. Esto se demuestra claramente con las siguientes expresiones:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-QqYG9KqZ2/" href="#c-QqYG9KqZ2/" tabindex="-1" role="presentation"></a>console.log(<span class="tok-number">8</span> * <span class="tok-keyword">null</span>)
<span class="tok-comment">// ‚Üí 0</span>
console.log(<span class="tok-string">&quot;5&quot;</span> - <span class="tok-number">1</span>)
<span class="tok-comment">// ‚Üí 4</span>
console.log(<span class="tok-string">&quot;5&quot;</span> + <span class="tok-number">1</span>)
<span class="tok-comment">// ‚Üí 51</span>
console.log(<span class="tok-string">&quot;five&quot;</span> * <span class="tok-number">2</span>)
<span class="tok-comment">// ‚Üí NaN</span>
console.log(false == <span class="tok-number">0</span>)
<span class="tok-comment">// ‚Üí true</span></pre>

<p><a class="p_ident" id="p-kB8tbSpJvt" href="#p-kB8tbSpJvt" tabindex="-1" role="presentation"></a>Cuando se aplica un operador al tipo de valor ‚Äúincorrecto‚Äù, JavaScript convertir√° silenciosamente ese valor al tipo que necesita, utilizando un conjunto de reglas que a menudo no son las que deseas o esperas. Esto se llama <em>coerci√≥n de tipos</em>. El <code>null</code> en la primera expresi√≥n se convierte en <code>0</code> y el <code>&quot;5&quot;</code> en la segunda expresi√≥n se convierte en <code>5</code> (de cadena a n√∫mero). Sin embargo, en la tercera expresi√≥n, <code>+</code> intenta la concatenaci√≥n de cadenas antes que la suma num√©rica, por lo que el <code>1</code> se convierte en <code>&quot;1&quot;</code> (de n√∫mero a cadena).</p>

<p><a class="p_ident" id="p-jcnJfAvvp6" href="#p-jcnJfAvvp6" tabindex="-1" role="presentation"></a>Cuando algo que no se corresponde con un n√∫mero de manera obvia (como <code>&quot;five&quot;</code> o <code>undefined</code>) se convierte en un n√∫mero, obtienes el valor <code>NaN</code>. M√°s operaciones aritm√©ticas en <code>NaN</code> siguen produciendo <code>NaN</code>, as√≠ que si te encuentras con uno de estos en un lugar inesperado, busca conversiones de tipo accidentales.</p>

<p><a class="p_ident" id="p-qunwSNidbj" href="#p-qunwSNidbj" tabindex="-1" role="presentation"></a>Cuando se comparan valores del mismo tipo usando el operador <code>==</code>, el resultado es f√°cil de predecir: deber√≠as obtener verdadero cuando ambos valores son iguales, excepto en el caso de <code>NaN</code>. Pero cuando los tipos difieren, JavaScript utiliza un conjunto de reglas complicado y confuso para determinar qu√© hacer. En la mayor√≠a de los casos, simplemente intenta convertir uno de los valores al tipo del otro valor. Sin embargo, cuando <code>null</code> o <code>undefined</code> aparece en cualquiera de los lados del operador, produce verdadero solo si ambos lados son uno de <code>null</code> o <code>undefined</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-qmGDPdETlf" href="#c-qmGDPdETlf" tabindex="-1" role="presentation"></a>console.log(<span class="tok-keyword">null</span> == undefined);
<span class="tok-comment">// ‚Üí true</span>
console.log(<span class="tok-keyword">null</span> == <span class="tok-number">0</span>);
<span class="tok-comment">// ‚Üí false</span></pre>

<p><a class="p_ident" id="p-Xtu7tKxIxD" href="#p-Xtu7tKxIxD" tabindex="-1" role="presentation"></a>Ese comportamiento a menudo es √∫til. Cuando quieres probar si un valor tiene un valor real en lugar de <code>null</code> o <code>undefined</code>, puedes compararlo con <code>null</code> usando el operador <code>==</code> o <code>!=</code>.</p>

<p><a class="p_ident" id="p-ov1vMdqygq" href="#p-ov1vMdqygq" tabindex="-1" role="presentation"></a>¬øQu√© sucede si quieres probar si algo se refiere al valor preciso <code>false</code>? Expresiones como <code>0 == false</code> y <code>&quot;&quot; == false</code> tambi√©n son verdaderas debido a la conversi√≥n autom√°tica de tipos. Cuando <em>no</em> deseas que ocurran conversiones de tipo, hay dos operadores adicionales: <code>===</code> y <code>!==</code>. El primero prueba si un valor es <em>precisamente</em> igual al otro, y el segundo prueba si no es precisamente igual. Por lo tanto, <code>&quot;&quot; === false</code> es falso como se espera. Recomiendo usar los operadores de comparaci√≥n de tres caracteres defensivamente para evitar conversiones de tipo inesperadas que puedan complicarte las cosas. Pero cuando est√©s seguro de que los tipos en ambos lados ser√°n los mismos, no hay problema en usar los operadores m√°s cortos.</p>

<h3><a class="i_ident" id="i-SOUbB0ZSTp" href="#i-SOUbB0ZSTp" tabindex="-1" role="presentation"></a>Cortocircuito de operadores l√≥gicos</h3>

<p><a class="p_ident" id="p-uieZyUDZJD" href="#p-uieZyUDZJD" tabindex="-1" role="presentation"></a>Los operadores l√≥gicos <code>&amp;&amp;</code> y <code>||</code> manejan valores de diferentes tipos de una manera peculiar. Convertir√°n el valor del lado izquierdo a tipo Booleano para decidir qu√© hacer, pero dependiendo del operador y el resultado de esa conversi√≥n, devolver√°n ya sea el valor original del lado izquierdo o el valor del lado derecho.</p>

<p><a class="p_ident" id="p-d+fK5uFMGA" href="#p-d+fK5uFMGA" tabindex="-1" role="presentation"></a>El operador <code>||</code>, por ejemplo, devolver√° el valor de su izquierda cuando ese valor pueda convertirse en true y devolver√° el valor de su derecha de lo contrario. Esto tiene el efecto esperado cuando los valores son Booleanos y hace algo an√°logo para valores de otros tipos.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-2QvcXTa0ga" href="#c-2QvcXTa0ga" tabindex="-1" role="presentation"></a>console.log(<span class="tok-keyword">null</span> || <span class="tok-string">&quot;usuario&quot;</span>)
<span class="tok-comment">// ‚Üí usuario</span>
console.log(<span class="tok-string">&quot;Agnes&quot;</span> || <span class="tok-string">&quot;usuario&quot;</span>)
<span class="tok-comment">// ‚Üí Agnes</span></pre>

<p><a class="p_ident" id="p-x9D4HrfdZX" href="#p-x9D4HrfdZX" tabindex="-1" role="presentation"></a>Podemos utilizar esta funcionalidad como una forma de utilizar un valor predeterminado. Si tienes un valor que podr√≠a estar vac√≠o, puedes colocar <code>||</code> despu√©s de √©l con un valor de reemplazo. Si el valor inicial se puede convertir en false, obtendr√°s el valor de reemplazo en su lugar. Las reglas para convertir cadenas y n√∫meros en valores Booleanos establecen que <code>0</code>, <code>NaN</code> y la cadena vac√≠a (<code>&quot;&quot;</code>) cuentan como <code>false</code>, mientras que todos los dem√°s valores cuentan como <code>true</code>. Esto significa que <code>0 || -1</code> produce <code>-1</code>, y <code>&quot;&quot; || &quot;!?&quot;</code> da como resultado <code>&quot;!?&quot;</code>.</p>

<p><a class="p_ident" id="p-E/l93sJCpQ" href="#p-E/l93sJCpQ" tabindex="-1" role="presentation"></a>El operador <code>??</code> se asemeja a <code>||</code>, pero devuelve el valor de la derecha solo si el de la izquierda es null o undefined, no si es alg√∫n otro valor que se pueda convertir en <code>false</code>. A menudo, este comportamiento es preferible al de <code>||</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-UVdLwFRz8U" href="#c-UVdLwFRz8U" tabindex="-1" role="presentation"></a>console.log(<span class="tok-number">0</span> || <span class="tok-number">100</span>);
<span class="tok-comment">// ‚Üí 100</span>
console.log(<span class="tok-number">0</span> ?? <span class="tok-number">100</span>);
<span class="tok-comment">// ‚Üí 0</span>
console.log(<span class="tok-keyword">null</span> ?? <span class="tok-number">100</span>);
<span class="tok-comment">// ‚Üí 100</span></pre>

<p><a class="p_ident" id="p-NtTtZBsnPX" href="#p-NtTtZBsnPX" tabindex="-1" role="presentation"></a>El operador <code>&amp;&amp;</code> funciona de manera similar pero en sentido contrario. Cuando el valor a su izquierda es algo que se convierte en false, devuelve ese valor, y de lo contrario devuelve el valor de su derecha.</p>

<p><a class="p_ident" id="p-+rquv/zDNk" href="#p-+rquv/zDNk" tabindex="-1" role="presentation"></a>Otra propiedad importante de estos dos operadores es que la parte de su derecha se eval√∫a solo cuando es necesario. En el caso de <code>true || X</code>, no importa qu√© sea <code>X</code>, incluso si es una parte del programa que hace algo <em>terrible</em>, el resultado ser√° true, y <code>X</code> nunca se evaluar√°. Lo mismo ocurre con <code>false &amp;&amp; X</code>, que es false e ignorar√° <code>X</code>. Esto se llama <em>evaluaci√≥n de cortocircuito</em>.</p>

<p><a class="p_ident" id="p-tWKK3353PD" href="#p-tWKK3353PD" tabindex="-1" role="presentation"></a>El operador condicional funciona de manera similar. De los valores segundo y tercero, solo se eval√∫a el que sea seleccionado.</p>

<h2><a class="h_ident" id="h-NUFOUyK+lw" href="#h-NUFOUyK+lw" tabindex="-1" role="presentation"></a>Resumen</h2>

<p><a class="p_ident" id="p-8teOb/HsE+" href="#p-8teOb/HsE+" tabindex="-1" role="presentation"></a>En este cap√≠tulo examinamos cuatro tipos de valores en JavaScript: n√∫meros, cadenas, Booleanos y valores indefinidos. Tales valores son creados escribiendo su nombre (<code>true</code>, <code>null</code>) o valor (<code>13</code>, <code>&quot;abc&quot;</code>). Puedes combinar y transformar valores con operadores. Vimos operadores binarios para aritm√©tica (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> y <code>%</code>), concatenaci√≥n de cadenas (<code>+</code>), comparaci√≥n (<code>==</code>, <code>!=</code>, <code>===</code>, <code>!==</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>) y l√≥gica (<code>&amp;&amp;</code>, <code>||</code>, <code>??</code>), as√≠ como varios operadores unarios (<code>-</code> para negar un n√∫mero, <code>!</code> para negar l√≥gicamente, y <code>typeof</code> para encontrar el tipo de un valor) y un operador ternario (<code>?:</code>) para elegir uno de dos valores basado en un tercer valor.</p>

<p><a class="p_ident" id="p-asWL1nI+Xu" href="#p-asWL1nI+Xu" tabindex="-1" role="presentation"></a>Esto te proporciona suficiente informaci√≥n para usar JavaScript como una calculadora de bolsillo, pero no mucho m√°s. El <a href="02_program_structure.html">pr√≥ximo cap√≠tulo</a> comenzar√° a unir estas expresiones en programas b√°sicos.</p><nav><a href="00_intro.html" title="previous chapter" aria-label="previous chapter">‚óÇ</a>¬†<a href="index.html" title="cover" aria-label="cover">‚óè</a>¬†<a href="02_program_structure.html" title="next chapter" aria-label="next chapter">‚ñ∏</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>&nbsp;<button class="dark-mode-toggle">üåô</button>
</nav>
</article>

<script src="ejs.js"></script>
