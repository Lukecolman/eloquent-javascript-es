<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Dibujando en Canvas :: Eloquent JavaScript</title>
  <link rel=stylesheet href="css/ejs.css"><script>
      var page = {"type":"chapter","number":17,"load_files":["code/chapter/16_game.js","code/levels.js","code/stop_keys.js","code/chapter/17_canvas.js"]}</script></head>

<article>
<nav><a href="16_game.html" title="previous chapter" aria-label="previous chapter">‚óÇ</a>¬†<a href="index.html" title="cover" aria-label="cover">‚óè</a>¬†<a href="18_http.html" title="next chapter" aria-label="next chapter">‚ñ∏</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>&nbsp;<button class="dark-mode-toggle">üåô</button>
</nav>

<h1>Dibujando en Canvas</h1>

<blockquote>

<p><a class="p_ident" id="p-WK6Londj2s" href="#p-WK6Londj2s" tabindex="-1" role="presentation"></a>Dibujar es enga√±ar.</p>

<footer>M.C. Escher, <cite>citado por Bruno Ernst en El Espejo M√°gico de M.C. Escher</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_17.jpg" alt="Ilustraci√≥n que muestra un brazo rob√≥tico con aspecto industrial dibujando una ciudad en un trozo de papel"></figure>

<p><a class="p_ident" id="p-WsH95+AeJX" href="#p-WsH95+AeJX" tabindex="-1" role="presentation"></a>Los navegadores nos ofrecen varias formas de mostrar gr√°ficos. La forma m√°s simple es usar estilos para posicionar y colorear elementos DOM regulares. Esto puede llevarnos bastante lejos, como mostr√≥ el juego en el <a href="16_game.html">cap√≠tulo anterior</a>. Al agregar im√°genes de fondo parcialmente transparentes a los nodos, podemos hacer que se vean exactamente como queremos. Incluso es posible rotar o sesgar nodos con el estilo <code>transform</code>.</p>

<p><a class="p_ident" id="p-VaIkI2Lvrr" href="#p-VaIkI2Lvrr" tabindex="-1" role="presentation"></a>Pero estar√≠amos utilizando el DOM para algo para lo que no fue dise√±ado originalmente. Algunas tareas, como dibujar una l√≠nea entre puntos arbitrarios, son extremadamente inc√≥modas de hacer con elementos HTML regulares.</p>

<p><a class="p_ident" id="p-8EN87JsadZ" href="#p-8EN87JsadZ" tabindex="-1" role="presentation"></a>Hay dos alternativas. La primera es basada en el DOM pero utiliza <em>Gr√°ficos Vectoriales Escalables</em> (SVG), en lugar de HTML. Piensa en SVG como un dialecto de marcado de documento que se centra en las formas en lugar de en el texto. Puedes incrustar un documento SVG directamente en un documento HTML o incluirlo con una etiqueta <code>&lt;img&gt;</code>.</p>

<p><a class="p_ident" id="p-5ipuOzKaXl" href="#p-5ipuOzKaXl" tabindex="-1" role="presentation"></a>La segunda alternativa se llama <em>lienzo</em>. Un lienzo es un solo elemento DOM que encapsula una imagen. Proporciona una interfaz de programaci√≥n para dibujar formas en el espacio ocupado por el nodo. La principal diferencia entre un lienzo y una imagen SVG es que en SVG se conserva la descripci√≥n original de las formas para que puedan moverse o redimensionarse en cualquier momento. Un lienzo, por otro lado, convierte las formas en p√≠xels (puntos de color en una cuadr√≠cula) en cuanto se dibujan y no recuerda qu√© representan estos p√≠xeles. La √∫nica forma de mover una forma en un lienzo es borrar el lienzo (o la parte del lienzo alrededor de la forma) y volver a dibujarlo con la forma en una nueva posici√≥n.</p>

<h2><a class="h_ident" id="h-UPzm0CiZhQ" href="#h-UPzm0CiZhQ" tabindex="-1" role="presentation"></a>SVG</h2>

<p><a class="p_ident" id="p-qX100BfTD/" href="#p-qX100BfTD/" tabindex="-1" role="presentation"></a>Este libro no se adentrar√° en detalles sobre SVG, pero explicar√© brevemente c√≥mo funciona. Al <a href="17_canvas.html#tradeoffs_graficos">final del cap√≠tulo</a>, volver√© a los compromisos que debes considerar al decidir qu√© mecanismo de dibujo es adecuado para una aplicaci√≥n determinada.</p>

<p><a class="p_ident" id="p-GYntGFJZWA" href="#p-GYntGFJZWA" tabindex="-1" role="presentation"></a>Este es un documento HTML con una sencilla imagen SVG en √©l:</p>

<pre tabindex="0" class="snippet" data-language="html"  data-sandbox="svg"><a class="c_ident" id="c-8Fs/4abQ/e" href="#c-8Fs/4abQ/e" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">p</span>&gt;Aqu√≠ va HTML normal.&lt;/<span class="tok-typeName">p</span>&gt;
&lt;<span class="tok-typeName">svg</span> xmlns=<span class="tok-string">&quot;http://www.w3.org/2000/svg&quot;</span>&gt;
  &lt;<span class="tok-typeName">circle</span> r=<span class="tok-string">&quot;50&quot;</span> cx=<span class="tok-string">&quot;50&quot;</span> cy=<span class="tok-string">&quot;50&quot;</span> fill=<span class="tok-string">&quot;red&quot;</span>/&gt;
  &lt;<span class="tok-typeName">rect</span> x=<span class="tok-string">&quot;120&quot;</span> y=<span class="tok-string">&quot;5&quot;</span> width=<span class="tok-string">&quot;90&quot;</span> height=<span class="tok-string">&quot;90&quot;</span>
        stroke=<span class="tok-string">&quot;blue&quot;</span> fill=<span class="tok-string">&quot;none&quot;</span>/&gt;
&lt;/<span class="tok-typeName">svg</span>&gt;</pre>

<p><a class="p_ident" id="p-nP9GmCkWpk" href="#p-nP9GmCkWpk" tabindex="-1" role="presentation"></a>Estas etiquetas crean elementos del DOM, al igual que las etiquetas HTML, con las que los scripts pueden interactuar. Por ejemplo, esto cambia el elemento <code>&lt;circle&gt;</code> para que se coloree de cian:</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-sandbox="svg"><a class="c_ident" id="c-jx+UOHRvDL" href="#c-jx+UOHRvDL" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">circle</span> = document.querySelector(<span class="tok-string">&quot;circle&quot;</span>);
circle.setAttribute(<span class="tok-string">&quot;fill&quot;</span>, <span class="tok-string">&quot;cyan&quot;</span>);</pre>

<h2><a class="h_ident" id="h-IHgXAPlRoi" href="#h-IHgXAPlRoi" tabindex="-1" role="presentation"></a>El elemento canvas</h2>

<p><a class="p_ident" id="p-foVNVjLewD" href="#p-foVNVjLewD" tabindex="-1" role="presentation"></a>Los gr√°ficos en lienzo pueden ser dibujados en un elemento <code>&lt;canvas&gt;</code>. Puedes darle a dicho elemento atributos <code>width</code> y <code>height</code> para determinar su tama√±o en p√≠xels.</p>

<p><a class="p_ident" id="p-aUuyVtTlLJ" href="#p-aUuyVtTlLJ" tabindex="-1" role="presentation"></a>Un lienzo nuevo est√° vac√≠o, lo que significa que es completamente transparente y por lo tanto se muestra como espacio vac√≠o en el documento.</p>

<p><a class="p_ident" id="p-zuEJbhu4U0" href="#p-zuEJbhu4U0" tabindex="-1" role="presentation"></a>La etiqueta <code>&lt;canvas&gt;</code> est√° destinada a permitir diferentes estilos de dibujo. Para acceder a una interfaz de dibujo real, primero necesitamos crear un <em>contexto</em>, un objeto cuyos m√©todos proporcionan la interfaz de dibujo. Actualmente existen tres estilos de dibujo ampliamente compatibles: <code>&quot;2d&quot;</code> para gr√°ficos bidimensionales, <code>&quot;webgl&quot;</code> para gr√°ficos tridimensionales a trav√©s de la interfaz OpenGL, y <code>&quot;webgpu&quot;</code>, una alternativa m√°s moderna y flexible a WebGL.</p>

<p><a class="p_ident" id="p-s3Qi60Vb/g" href="#p-s3Qi60Vb/g" tabindex="-1" role="presentation"></a>Este libro no discutir√° WebGL ni WebGPU‚Äînos mantendremos en dos dimensiones. Pero si est√°s interesado en gr√°ficos tridimensionales, te animo a investigar sobre WebGPU. Proporciona una interfaz directa al hardware gr√°fico y te permite renderizar escenas incluso complicadas de manera eficiente, utilizando JavaScript.</p>

<p><a class="p_ident" id="p-MEgOg5Mvt7" href="#p-MEgOg5Mvt7" tabindex="-1" role="presentation"></a>Creas un contexto con el m√©todo <code>getContext</code> en el elemento DOM <code>&lt;canvas&gt;</code>.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-5f0tu/efaY" href="#c-5f0tu/efaY" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">p</span>&gt;Antes del lienzo.&lt;/<span class="tok-typeName">p</span>&gt;
&lt;<span class="tok-typeName">canvas</span> width=<span class="tok-string">&quot;120&quot;</span> height=<span class="tok-string">&quot;60&quot;</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">p</span>&gt;Despu√©s del lienzo.&lt;/<span class="tok-typeName">p</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">canvas</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>);
  <span class="tok-keyword">let</span> <span class="tok-definition">context</span> = canvas.getContext(<span class="tok-string">&quot;2d&quot;</span>);
  context.fillStyle = <span class="tok-string">&quot;red&quot;</span>;
  context.fillRect(<span class="tok-number">10</span>, <span class="tok-number">10</span>, <span class="tok-number">100</span>, <span class="tok-number">50</span>);
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-Z8FbmAPx0e" href="#p-Z8FbmAPx0e" tabindex="-1" role="presentation"></a>Despu√©s de crear el objeto de contexto, el ejemplo dibuja un rect√°ngulo rojo de 100 p√≠xeles de ancho y 50 p√≠xeles de alto, con su esquina superior izquierda en las coordenadas (10,10).</p>

<p><a class="p_ident" id="p-lvxXAWASbe" href="#p-lvxXAWASbe" tabindex="-1" role="presentation"></a>Al igual que en HTML (y SVG), el sistema de coordenadas que utiliza el lienzo sit√∫a el (0,0) en la esquina superior izquierda, y el eje y-positivo va hacia abajo desde all√≠. Por lo tanto, (10,10) est√° 10 p√≠xeles abajo y a la derecha de la esquina superior izquierda.</p>

<h2 id="fill_stroke"><a class="h_ident" id="h-pjhQhwBlI5" href="#h-pjhQhwBlI5" tabindex="-1" role="presentation"></a>L√≠neas y superficies</h2>

<p><a class="p_ident" id="p-O6DYJslVdE" href="#p-O6DYJslVdE" tabindex="-1" role="presentation"></a>En la interfaz de lienzo, una forma puede ser <em>rellenada</em>, lo que significa que su √°rea recibe un color o patr√≥n determinado, o puede ser <em>trazada</em>, lo que significa que se dibuja una l√≠nea a lo largo de su borde. La misma terminolog√≠a se utiliza en SVG.</p>

<p><a class="p_ident" id="p-0VT8ruNYTo" href="#p-0VT8ruNYTo" tabindex="-1" role="presentation"></a>El m√©todo <code>fillRect</code> rellena un rect√°ngulo. Primero toma las coordenadas x e y de la esquina superior izquierda del rect√°ngulo, luego su ancho y finalmente su altura. Un m√©todo similar llamado <code>strokeRect</code> dibuja el contorno de un rect√°ngulo.</p>

<p><a class="p_ident" id="p-RfsD8lcuyO" href="#p-RfsD8lcuyO" tabindex="-1" role="presentation"></a>Ninguno de los m√©todos toma m√°s par√°metros. El color del relleno, el grosor del trazo, y dem√°s, no son determinados por un argumento del m√©todo, como podr√≠as esperar razonablemente, sino por propiedades del objeto contexto.</p>

<p><a class="p_ident" id="p-3Koe6zpld5" href="#p-3Koe6zpld5" tabindex="-1" role="presentation"></a>La propiedad <code>fillStyle</code> controla la forma en que se rellenan las formas. Puede establecerse como una cadena que especifica un color, utilizando la notaci√≥n de color utilizada por CSS.</p>

<p><a class="p_ident" id="p-SGPqnpLFJH" href="#p-SGPqnpLFJH" tabindex="-1" role="presentation"></a>La propiedad <code>strokeStyle</code> funciona de manera similar, pero determina el color utilizado para una l√≠nea contorneada. El ancho de esa l√≠nea se determina mediante la propiedad <code>lineWidth</code>, que puede contener cualquier n√∫mero positivo.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-RXlmHDTr07" href="#c-RXlmHDTr07" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  cx.strokeStyle = <span class="tok-string">&quot;blue&quot;</span>;
  cx.strokeRect(<span class="tok-number">5</span>, <span class="tok-number">5</span>, <span class="tok-number">50</span>, <span class="tok-number">50</span>);
  cx.lineWidth = <span class="tok-number">5</span>;
  cx.strokeRect(<span class="tok-number">135</span>, <span class="tok-number">5</span>, <span class="tok-number">50</span>, <span class="tok-number">50</span>);
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-eP8J7bTZtY" href="#p-eP8J7bTZtY" tabindex="-1" role="presentation"></a>Cuando no se especifica ning√∫n atributo <code>width</code> o <code>height</code>, como en el ejemplo, un elemento canvas obtiene un ancho predeterminado de 300 p√≠xeles y una altura de 150 p√≠xeles.</p>

<h2><a class="h_ident" id="h-Z7qInlh67F" href="#h-Z7qInlh67F" tabindex="-1" role="presentation"></a>Caminos</h2>

<p><a class="p_ident" id="p-5k991wc6m3" href="#p-5k991wc6m3" tabindex="-1" role="presentation"></a>Un camino es una secuencia de l√≠neas. La interfaz del canvas 2D toma un enfoque peculiar para describir un camino. Se realiza completamente a trav√©s de efecto secundarios. Los caminos no son valores que se puedan almacenar y pasar. En su lugar, si deseas hacer algo con un camino, haces una secuencia de llamadas a m√©todos para describir su forma.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-q5tyCN7mU3" href="#c-q5tyCN7mU3" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  cx.beginPath();
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">y</span> = <span class="tok-number">10</span>; y &lt; <span class="tok-number">100</span>; y += <span class="tok-number">10</span>) {
    cx.moveTo(<span class="tok-number">10</span>, y);
    cx.lineTo(<span class="tok-number">90</span>, y);
  }
  cx.stroke();
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-FIflUFp6Ac" href="#p-FIflUFp6Ac" tabindex="-1" role="presentation"></a>Este ejemplo crea un camino con varios segmentos horizontales de l√≠nea y luego lo traza usando el m√©todo <code>stroke</code>. Cada segmento creado con <code>lineTo</code> comienza en la posici√≥n <em>actual</em> del camino. Esa posici√≥n suele ser el final del √∫ltimo segmento, a menos que se haya llamado a <code>moveTo</code>. En ese caso, el siguiente segmento comenzar√≠a en la posici√≥n pasada a <code>moveTo</code>.</p>

<p><a class="p_ident" id="p-iJK0Cor0G1" href="#p-iJK0Cor0G1" tabindex="-1" role="presentation"></a>Cuando se rellena un camino (usando el m√©todo <code>fill</code>), cada forma se llena por separado. Un camino puede contener m√∫ltiples formas‚Äîcada movimiento de <code>moveTo</code> inicia una nueva forma. Pero el camino necesita estar <em>cerrado</em> (significando que su inicio y final est√°n en la misma posici√≥n) antes de poder ser rellenado. Si el camino a√∫n no est√° cerrado, se agrega una l√≠nea desde su final hasta su inicio, y se rellena la forma encerrada por el camino completado.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-dKfK5v1gw2" href="#c-dKfK5v1gw2" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  cx.beginPath();
  cx.moveTo(<span class="tok-number">50</span>, <span class="tok-number">10</span>);
  cx.lineTo(<span class="tok-number">10</span>, <span class="tok-number">70</span>);
  cx.lineTo(<span class="tok-number">90</span>, <span class="tok-number">70</span>);
  cx.fill();
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-pS4j/40SI7" href="#p-pS4j/40SI7" tabindex="-1" role="presentation"></a>Este ejemplo dibuja un tri√°ngulo relleno. Ten en cuenta que solo se dibujan expl√≠citamente dos de los lados del tri√°ngulo. El tercero, desde la esquina inferior derecha de regreso a la parte superior, se da por impl√≠cito y no estar√≠a all√≠ cuando se traze el recorrido.</p>

<p><a class="p_ident" id="p-Tk2aVSsGnM" href="#p-Tk2aVSsGnM" tabindex="-1" role="presentation"></a>Tambi√©n puedes usar el m√©todo <code>closePath</code> para cerrar expl√≠citamente un recorrido agregando un segmento real line de vuelta al inicio del recorrido. Este segmento <em>se</em> dibuja cuando se traza el recorrido.</p>

<h2><a class="h_ident" id="h-9hC2009SxC" href="#h-9hC2009SxC" tabindex="-1" role="presentation"></a>Curvas</h2>

<p><a class="p_ident" id="p-WSTFQiXLdY" href="#p-WSTFQiXLdY" tabindex="-1" role="presentation"></a>Un recorrido tambi√©n puede contener l√≠neas curvadas. Lamentablemente, estas son un poco m√°s complicadas de dibujar.</p>

<p><a class="p_ident" id="p-3OHms/qYjY" href="#p-3OHms/qYjY" tabindex="-1" role="presentation"></a>El m√©todo <code>quadraticCurveTo</code> dibuja una curva hacia un punto dado. Para determinar la curvatura de la l√≠nea, el m√©todo recibe un punto de control as√≠ como un punto de destino. Imagina este punto de control como <em>atrayendo</em> la l√≠nea, d√°ndole su curva. La l√≠nea no pasar√° por el punto de control, pero su direcci√≥n en los puntos de inicio y fin ser√° tal que una l√≠nea recta en esa direcci√≥n apuntar√≠a hacia el punto de control. El siguiente ejemplo ilustra esto:</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-SD49jQshd2" href="#c-SD49jQshd2" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  cx.beginPath();
  cx.moveTo(<span class="tok-number">10</span>, <span class="tok-number">90</span>);
  <span class="tok-comment">// control=(60,10) meta=(90,90)</span>
  cx.quadraticCurveTo(<span class="tok-number">60</span>, <span class="tok-number">10</span>, <span class="tok-number">90</span>, <span class="tok-number">90</span>);
  cx.lineTo(<span class="tok-number">60</span>, <span class="tok-number">10</span>);
  cx.closePath();
  cx.stroke();
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-0Do2D1mx/8" href="#p-0Do2D1mx/8" tabindex="-1" role="presentation"></a>Dibujamos una curva cuadr√°tica de izquierda a derecha, con (60,10) como punto de control, y luego dibujamos dos segmentos line que pasan por ese punto de control y vuelven al inicio de la l√≠nea. El resultado se asemeja a un emblema de <em>Star Trek</em>. Puedes ver el efecto del punto de control: las l√≠neas que salen de las esquinas inferiores comienzan en la direcci√≥n del punto de control y luego se curvan hacia su objetivo.</p>

<p><a class="p_ident" id="p-dtLc0HxcsU" href="#p-dtLc0HxcsU" tabindex="-1" role="presentation"></a>El m√©todo <code>bezierCurveTo</code> dibuja un tipo de curva similar. En lugar de un √∫nico punto de control, este tiene dos‚Äîuno para cada uno de los extremos de la l√≠nea. Aqu√≠ hay un boceto similar para ilustrar el comportamiento de dicha curva:</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-0UOWPJLGDV" href="#c-0UOWPJLGDV" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  cx.beginPath();
  cx.moveTo(<span class="tok-number">10</span>, <span class="tok-number">90</span>);
  <span class="tok-comment">// control1=(10,10) control2=(90,10) meta=(50,90)</span>
  cx.bezierCurveTo(<span class="tok-number">10</span>, <span class="tok-number">10</span>, <span class="tok-number">90</span>, <span class="tok-number">10</span>, <span class="tok-number">50</span>, <span class="tok-number">90</span>);
  cx.lineTo(<span class="tok-number">90</span>, <span class="tok-number">10</span>);
  cx.lineTo(<span class="tok-number">10</span>, <span class="tok-number">10</span>);
  cx.closePath();
  cx.stroke();
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-nzyix6jR0u" href="#p-nzyix6jR0u" tabindex="-1" role="presentation"></a>Los dos puntos de control especifican la direcci√≥n en ambos extremos de la curva. Cuanto m√°s separados est√©n de su punto correspondiente, m√°s la curva ‚Äúabultar√°&quot; en esa direcci√≥n.</p>

<p><a class="p_ident" id="p-tELXhF/ylX" href="#p-tELXhF/ylX" tabindex="-1" role="presentation"></a>curves como estas pueden ser dif√≠ciles de trabajar, no siempre es claro c√≥mo encontrar los control points que proporcionan la forma que est√°s buscando. A veces puedes calcularlos y a veces simplemente tendr√°s que encontrar un valor adecuado mediante prueba y error.</p>

<p><a class="p_ident" id="p-1rScitaxyO" href="#p-1rScitaxyO" tabindex="-1" role="presentation"></a>El m√©todo <code>arc</code> es una forma de dibujar una l√≠nea que se curva a lo largo del borde de un c√≠rculo. Toma un par de coordenadas para el centro del arco, un radio, y luego un √°ngulo de inicio y un √°ngulo final.</p>

<p><a class="p_ident" id="p-NTElsgJi2Y" href="#p-NTElsgJi2Y" tabindex="-1" role="presentation"></a>Estos √∫ltimos dos par√°metros permiten dibujar solo parte del c√≠rculo. Los √°ngulos se miden en radianes, no en grados. Esto significa que un c√≠rculo completo tiene un √°ngulo de 2œÄ, o <code>2 * Math.PI</code>, que es aproximadamente 6.28. El √°ngulo comienza a contar en el punto a la derecha del centro del c√≠rculo y va en sentido horario desde all√≠. Puedes usar un inicio de 0 y un final mayor que 2œÄ (por ejemplo, 7) para dibujar un c√≠rculo completo.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-D61ZW3HiS3" href="#c-D61ZW3HiS3" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  cx.beginPath();
  <span class="tok-comment">// centro=(50,50) radio=40 √°ngulo=0 a 7</span>
  cx.arc(<span class="tok-number">50</span>, <span class="tok-number">50</span>, <span class="tok-number">40</span>, <span class="tok-number">0</span>, <span class="tok-number">7</span>);
  <span class="tok-comment">// centro=(150,50) radio=40 √°ngulo=0 a ¬ΩœÄ</span>
  cx.arc(<span class="tok-number">150</span>, <span class="tok-number">50</span>, <span class="tok-number">40</span>, <span class="tok-number">0</span>, <span class="tok-number">0.5</span> * Math.PI);
  cx.stroke();
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-jkO8t0wU0c" href="#p-jkO8t0wU0c" tabindex="-1" role="presentation"></a>La imagen resultante contiene una l√≠nea desde la derecha del c√≠rculo completo (primer llamado a <code>arc</code>) hasta la derecha del cuarto del c√≠rculo (segundo llamado). Al igual que otros m√©todos de dibujo de trayectos, una l√≠nea dibujada con <code>arc</code> est√° conectada al segmento de trayecto anterior. Puedes llamar a <code>moveTo</code> o comenzar un nuevo trayecto para evitar esto.</p>

<h2 id="diagrama_sectores"><a class="h_ident" id="h-wGotxOQ6Zk" href="#h-wGotxOQ6Zk" tabindex="-1" role="presentation"></a>Dibujo de un diagrama de sectores</h2>

<p><a class="p_ident" id="p-xlrQHhcAT1" href="#p-xlrQHhcAT1" tabindex="-1" role="presentation"></a>Imagina que acabas de aceptar un trabajo en EconomiCorp, Inc., y tu primera tarea es dibujar un diagrama de sectores de los resultados de la encuesta de satisfacci√≥n de los clientes.</p>

<p><a class="p_ident" id="p-dUxzE17XwV" href="#p-dUxzE17XwV" tabindex="-1" role="presentation"></a>El enlace <code>results</code> contiene una matriz de objetos que representan las respuestas de la encuesta.</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-sandbox="pie"><a class="c_ident" id="c-xc7hhd8RrM" href="#c-xc7hhd8RrM" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">results</span> = [
  {<span class="tok-definition">name</span>: <span class="tok-string">&quot;Satisfecho&quot;</span>, <span class="tok-definition">count</span>: <span class="tok-number">1043</span>, <span class="tok-definition">color</span>: <span class="tok-string">&quot;lightblue&quot;</span>},
  {<span class="tok-definition">name</span>: <span class="tok-string">&quot;Neutral&quot;</span>, <span class="tok-definition">count</span>: <span class="tok-number">563</span>, <span class="tok-definition">color</span>: <span class="tok-string">&quot;lightgreen&quot;</span>},
  {<span class="tok-definition">name</span>: <span class="tok-string">&quot;Insatisfecho&quot;</span>, <span class="tok-definition">count</span>: <span class="tok-number">510</span>, <span class="tok-definition">color</span>: <span class="tok-string">&quot;pink&quot;</span>},
  {<span class="tok-definition">name</span>: <span class="tok-string">&quot;Sin comentario&quot;</span>, <span class="tok-definition">count</span>: <span class="tok-number">175</span>, <span class="tok-definition">color</span>: <span class="tok-string">&quot;silver&quot;</span>}
];</pre>

<p><a class="p_ident" id="p-+20FYXG99L" href="#p-+20FYXG99L" tabindex="-1" role="presentation"></a>Para dibujar un diagrama de sectores, dibujamos una serie de sectores circulares, cada uno compuesto por un arco y un par de l√≠neas hacia el centro de ese arco. Podemos calcular el √°ngulo ocupado por cada arco dividiendo un c√≠rculo completo (2œÄ) por el n√∫mero total de respuestas y luego multiplicando ese n√∫mero (el √°ngulo por respuesta) por el n√∫mero de personas que eligieron una opci√≥n determinada.</p>

<pre tabindex="0" class="snippet" data-language="html"  data-sandbox="pie"><a class="c_ident" id="c-ULeWDvZXon" href="#c-ULeWDvZXon" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span> width=<span class="tok-string">&quot;200&quot;</span> height=<span class="tok-string">&quot;200&quot;</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  <span class="tok-keyword">let</span> <span class="tok-definition">total</span> = results
    .reduce((<span class="tok-definition">sum</span>, {count}) =&gt; sum + count, <span class="tok-number">0</span>);
  <span class="tok-comment">// Comenzar en la parte superior</span>
  <span class="tok-keyword">let</span> <span class="tok-definition">currentAngle</span> = -<span class="tok-number">0.5</span> * Math.PI;
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">result</span> <span class="tok-keyword">of</span> results) {
    <span class="tok-keyword">let</span> <span class="tok-definition">sliceAngle</span> = (result.count / total) * <span class="tok-number">2</span> * Math.PI;
    cx.beginPath();
    <span class="tok-comment">// centro=100,100, radio=100</span>
    <span class="tok-comment">// desde el √°ngulo actual, en sentido horario por el √°ngulo del sector</span>
    cx.arc(<span class="tok-number">100</span>, <span class="tok-number">100</span>, <span class="tok-number">100</span>,
           currentAngle, currentAngle + sliceAngle);
    currentAngle += sliceAngle;
    cx.lineTo(<span class="tok-number">100</span>, <span class="tok-number">100</span>);
    cx.fillStyle = result.color;
    cx.fill();
  }
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-YwIFCgKnJL" href="#p-YwIFCgKnJL" tabindex="-1" role="presentation"></a>Pero un gr√°fico que no nos dice qu√© significan las porciones no es muy √∫til. Necesitamos una forma de dibujar texto en el canvas.</p>

<h2><a class="h_ident" id="h-buumVsDzyv" href="#h-buumVsDzyv" tabindex="-1" role="presentation"></a>Texto</h2>

<p><a class="p_ident" id="p-jqhT5gaaJR" href="#p-jqhT5gaaJR" tabindex="-1" role="presentation"></a>Un contexto de dibujo en lienzo 2D proporciona los m√©todos <code>fillText</code> y <code>strokeText</code>. Este √∫ltimo puede ser √∫til para contornear letras, pero generalmente <code>fillText</code> es lo que necesitas. Este llenar√° el contorno del texto dado con el <code>fillStyle</code> actual.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-tAzTaI8U1M" href="#c-tAzTaI8U1M" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  cx.font = <span class="tok-string">&quot;28px Georgia&quot;</span>;
  cx.fillStyle = <span class="tok-string">&quot;fuchsia&quot;</span>;
  cx.fillText(<span class="tok-string">&quot;¬°Tambi√©n puedo dibujar texto!&quot;</span>, <span class="tok-number">10</span>, <span class="tok-number">50</span>);
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-Y8lIKRMGXQ" href="#p-Y8lIKRMGXQ" tabindex="-1" role="presentation"></a>Puedes especificar el tama√±o, estilo y fuente del texto con la propiedad <code>font</code>. Este ejemplo solo da un tama√±o de fuente y un nombre de familia. Tambi√©n es posible agregar <code>italic</code> o <code>bold</code> al comienzo de la cadena para seleccionar un estilo.</p>

<p><a class="p_ident" id="p-rhCNRQsUbN" href="#p-rhCNRQsUbN" tabindex="-1" role="presentation"></a>Los dos √∫ltimos argumentos de <code>fillText</code> y <code>strokeText</code> proporcionan la posici√≥n en la que se dibuja la fuente. Por defecto, indican la posici√≥n del inicio de la l√≠nea alfab√©tica del texto, que es la l√≠nea en la que las letras ‚Äúse paran‚Äù, sin contar las partes colgantes en letras como la <em>j</em> o la <em>p</em>. Puedes cambiar la posici√≥n horizontal configurando la propiedad <code>textAlign</code> en <code>&quot;end&quot;</code> o <code>&quot;center&quot;</code> y la posici√≥n vertical configurando <code>textBaseline</code> en <code>&quot;top&quot;</code>, <code>&quot;middle&quot;</code> o <code>&quot;bottom&quot;</code>.</p>

<p><a class="p_ident" id="p-2Nlk49Yj28" href="#p-2Nlk49Yj28" tabindex="-1" role="presentation"></a>Volveremos a nuestro gr√°fico circular y al problema de etiquetar las porciones, en los <a href="17_canvas.html#exercise_pie_chart">ejercicios</a> al final del cap√≠tulo.</p>

<h2><a class="h_ident" id="h-By2JQsVi0D" href="#h-By2JQsVi0D" tabindex="-1" role="presentation"></a>Im√°genes</h2>

<p><a class="p_ident" id="p-fUHn+F0MIN" href="#p-fUHn+F0MIN" tabindex="-1" role="presentation"></a>En gr√°ficos por computadora, a menudo se hace una distinci√≥n entre gr√°ficos <em>vectoriales</em> y gr√°ficos <em>de mapa de bits</em>. El primero es lo que hemos estado haciendo hasta ahora en este cap√≠tulo: especificar una imagen dando una descripci√≥n l√≥gica de las formas. Los gr√°ficos de mapa de bits, por otro lado, no especifican formas reales, sino que trabajan con datos de p√≠xel (rasteros de puntos de colores).</p>

<p><a class="p_ident" id="p-8mi7vOkN1m" href="#p-8mi7vOkN1m" tabindex="-1" role="presentation"></a>El m√©todo <code>drawImage</code> nos permite dibujar datos de p√≠xel en un canvas. Estos datos de p√≠xel pueden originarse desde un elemento <code>&lt;img&gt;</code> o desde otro lienzo. El siguiente ejemplo crea un elemento <code>&lt;img&gt;</code> independiente y carga un archivo de imagen en √©l. Pero no podemos comenzar a dibujar inmediatamente desde esta imagen porque es posible que el navegador a√∫n no la haya cargado. Para manejar esto, registramos un controlador de eventos <code>&quot;load&quot;</code> y hacemos el dibujo despu√©s de que la imagen se haya cargado.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-Uzn6msw1dJ" href="#c-Uzn6msw1dJ" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  <span class="tok-keyword">let</span> <span class="tok-definition">img</span> = document.createElement(<span class="tok-string">&quot;img&quot;</span>);
  img.src = <span class="tok-string">&quot;img/hat.png&quot;</span>;
  img.addEventListener(<span class="tok-string">&quot;load&quot;</span>, () =&gt; {
    <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">x</span> = <span class="tok-number">10</span>; x &lt; <span class="tok-number">200</span>; x += <span class="tok-number">30</span>) {
      cx.drawImage(img, x, <span class="tok-number">10</span>);
    }
  });
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-QY3iTHAR+O" href="#p-QY3iTHAR+O" tabindex="-1" role="presentation"></a>Por defecto, <code>drawImage</code> dibujar√° la imagen a su tama√±o original. Tambi√©n se le pueden proporcionar dos argumentos adicionales para establecer un ancho y alto diferente.</p>

<p><a class="p_ident" id="p-PhR2+0pqld" href="#p-PhR2+0pqld" tabindex="-1" role="presentation"></a>Cuando se utilizan <em>nueve</em> argumentos en <code>drawImage</code>, se puede usar para dibujar solo un fragmento de una imagen. Los argumentos segundo a quinto indican el rect√°ngulo (x, y, ancho y alto) en la imagen de origen que se deber√≠a copiar, y los argumentos sexto a noveno indican el rect√°ngulo (en el lienzo) en el cual se deber√≠a copiar.</p>

<p><a class="p_ident" id="p-OGnn92PfqV" href="#p-OGnn92PfqV" tabindex="-1" role="presentation"></a>Esto se puede utilizar para empaquetar varios <em>sprites</em> (elementos de imagen) en un √∫nico archivo de imagen y luego dibujar solo la parte que se necesita. Por ejemplo, tenemos esta imagen que contiene un personaje de juego en m√∫ltiples poses:</p><figure><img src="img/player_big.png" alt="Arte de p√≠xeles mostrando un personaje de videojuego en 10 poses diferentes. Las primeras 8 forman su ciclo de animaci√≥n de carrera, la novena tiene al personaje parado, y la d√©cima lo muestra saltando."></figure>

<p><a class="p_ident" id="p-irGio/b5/R" href="#p-irGio/b5/R" tabindex="-1" role="presentation"></a>Alternando qu√© pose dibujamos, podemos mostrar una animaci√≥n que parece un personaje caminando.</p>

<p><a class="p_ident" id="p-v9SUKElKNf" href="#p-v9SUKElKNf" tabindex="-1" role="presentation"></a>Para animar una imagen en un lienzo, el m√©todo <code>clearRect</code> es √∫til. Se asemeja a <code>fillRect</code>, pero en lugar de colorear el rect√°ngulo, lo vuelve transparente, eliminando los p√≠xeles dibujados anteriormente.</p>

<p><a class="p_ident" id="p-GE3ONxp2hC" href="#p-GE3ONxp2hC" tabindex="-1" role="presentation"></a>Sabemos que cada <em>sprite</em>, cada subimagen, tiene un ancho de 24 p√≠xeles y una altura de 30 p√≠xeles. El siguiente c√≥digo carga la imagen y luego establece un intervalo (temporizador repetido) para dibujar el siguiente frame:</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-RGrGdcKCNi" href="#c-RGrGdcKCNi" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  <span class="tok-keyword">let</span> <span class="tok-definition">img</span> = document.createElement(<span class="tok-string">&quot;img&quot;</span>);
  img.src = <span class="tok-string">&quot;img/player.png&quot;</span>;
  <span class="tok-keyword">let</span> <span class="tok-definition">spriteW</span> = <span class="tok-number">24</span>, <span class="tok-definition">spriteH</span> = <span class="tok-number">30</span>;
  img.addEventListener(<span class="tok-string">&quot;load&quot;</span>, () =&gt; {
    <span class="tok-keyword">let</span> <span class="tok-definition">ciclo</span> = <span class="tok-number">0</span>;
    setInterval(() =&gt; {
      cx.clearRect(<span class="tok-number">0</span>, <span class="tok-number">0</span>, spriteW, spriteH);
      cx.drawImage(img,
                   <span class="tok-comment">// rect√°ngulo de origen</span>
                   ciclo * spriteW, <span class="tok-number">0</span>, spriteW, spriteH,
                   <span class="tok-comment">// rect√°ngulo de destino</span>
                   <span class="tok-number">0</span>,               <span class="tok-number">0</span>, spriteW, spriteH);
      ciclo = (ciclo + <span class="tok-number">1</span>) % <span class="tok-number">8</span>;
    }, <span class="tok-number">120</span>);
  });
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-/TzcCCetH2" href="#p-/TzcCCetH2" tabindex="-1" role="presentation"></a>El enlace <code>ciclo</code> sigue nuestra posici√≥n en la animaci√≥n. En cada frame, se incrementa y luego se recorta de nuevo al rango de 0 a 7 usando el operador de resto. Este enlace se utiliza luego para calcular la coordenada x que tiene el sprite para la pose actual en la imagen.</p>

<h2><a class="h_ident" id="h-rW64MvxCiy" href="#h-rW64MvxCiy" tabindex="-1" role="presentation"></a>Transformaci√≥n</h2>

<p><a class="p_ident" id="p-IDnpmjkIIi" href="#p-IDnpmjkIIi" tabindex="-1" role="presentation"></a>Pero, ¬øqu√© pasa si queremos que nuestro personaje camine hacia la izquierda en lugar de hacia la derecha? Podr√≠amos dibujar otro conjunto de sprites, por supuesto. Pero tambi√©n podemos instruir al lienzo para que dibuje la imagen en sentido contrario.</p>

<p><a class="p_ident" id="p-k/kT+1q0Jm" href="#p-k/kT+1q0Jm" tabindex="-1" role="presentation"></a>Llamar al m√©todo <code>scale</code> har√° que todo lo que se dibuje despu√©s de √©l se escale. Este m√©todo toma dos par√°metros, uno para establecer una escala horizontal y otro para establecer una escala vertical.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-Ih3Ewav/dQ" href="#c-Ih3Ewav/dQ" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  cx.scale(<span class="tok-number">3</span>, <span class="tok-number">.5</span>);
  cx.beginPath();
  cx.arc(<span class="tok-number">50</span>, <span class="tok-number">50</span>, <span class="tok-number">40</span>, <span class="tok-number">0</span>, <span class="tok-number">7</span>);
  cx.lineWidth = <span class="tok-number">3</span>;
  cx.stroke();
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-giUMO7YZVM" href="#p-giUMO7YZVM" tabindex="-1" role="presentation"></a>Escalar har√° que todo en la imagen dibujada, incluyendo el grosor de l√≠nea, se estire o se comprima como se especifique. Escalar por una cantidad negativa voltear√° la imagen. La volteadura ocurre alrededor del punto (0,0), lo que significa que tambi√©n voltear√° la direcci√≥n del sistema de coordenadas. Cuando se aplica una escala horizontal de -1, una forma dibujada en la posici√≥n x 100 terminar√° en lo que sol√≠a ser la posici√≥n -100.</p>

<p><a class="p_ident" id="p-aFXzkU34ds" href="#p-aFXzkU34ds" tabindex="-1" role="presentation"></a>As√≠ que para voltear una imagen, no podemos simplemente agregar <code>cx.scale(-1, 1)</code> antes de la llamada a <code>drawImage</code> porque eso mover√≠a nuestra imagen fuera del lienzo, donde no ser√≠a visible. Podr√≠as ajustar las coordenadas dadas a <code>drawImage</code> para compensar esto dibujando la imagen en la posici√≥n x -50 en lugar de 0. Otra soluci√≥n, que no requiere que el c√≥digo que hace el dibujo sepa sobre el cambio de escala, es ajustar el eje alrededor del cual ocurre el escalado.</p>

<p><a class="p_ident" id="p-NsPf5RT0UM" href="#p-NsPf5RT0UM" tabindex="-1" role="presentation"></a>Hay varios otros m√©todos adem√°s de <code>scale</code> que influyen en el sistema de coordenadas de un lienzo. Puedes rotar formas dibujadas posteriormente con el m√©todo <code>rotate</code> y moverlas con el m√©todo <code>translate</code>. Lo interesante‚Äîy confuso‚Äîes que estas transformaciones <em>se apilan</em>, lo que significa que cada una ocurre relativa a las transformaciones anteriores.</p>

<p><a class="p_ident" id="p-MQX9G34XVb" href="#p-MQX9G34XVb" tabindex="-1" role="presentation"></a>Entonces, si traducimos por 10 p√≠xeles horizontales dos veces, todo se dibujar√° 20 p√≠xeles a la derecha. Si primero movemos el centro del sistema de coordenadas a (50,50) y luego rotamos por 20 grados (aproximadamente 0.1œÄ radianes), esa rotaci√≥n ocurrir√° <em>alrededor</em> del punto (50,50).</p><figure><img src="img/transform.svg" alt="Diagrama que muestra el resultado de apilar transformaciones. El primer diagrama traduce y luego rota, causando que la traducci√≥n ocurra normalmente y la rotaci√≥n alrededor del objetivo de la traducci√≥n. El segundo diagrama primero rota y luego traduce, causando que la rotaci√≥n ocurra alrededor del origen y la direcci√≥n de traducci√≥n se incline por esa rotaci√≥n."></figure>

<p><a class="p_ident" id="p-mKDS7oclkz" href="#p-mKDS7oclkz" tabindex="-1" role="presentation"></a>Pero si <em>primero</em> rotamos 20 grados y <em>luego</em> traducimos por (50,50), la traducci√≥n ocurrir√° en el sistema de coordenadas rotado y producir√° una orientaci√≥n diferente. El orden en el que se aplican las transformaciones es importante.</p>

<p><a class="p_ident" id="p-MKg3FxKQhR" href="#p-MKg3FxKQhR" tabindex="-1" role="presentation"></a>Para voltear una imagen alrededor de la l√≠nea vertical en una posici√≥n x dada, podemos hacer lo siguiente:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-gPWtMqSBLU" href="#c-gPWtMqSBLU" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">flipHorizontally</span>(<span class="tok-definition">context</span>, <span class="tok-definition">around</span>) {
  context.translate(around, <span class="tok-number">0</span>);
  context.scale(-<span class="tok-number">1</span>, <span class="tok-number">1</span>);
  context.translate(-around, <span class="tok-number">0</span>);
}</pre>

<p><a class="p_ident" id="p-vp1fsWT2Uu" href="#p-vp1fsWT2Uu" tabindex="-1" role="presentation"></a>Movemos el eje y a donde queremos que est√© nuestro espejo, aplicamos el efecto de espejo y finalmente devolvemos el eje y a su lugar adecuado en el universo espejado. La siguiente imagen explica por qu√© esto funciona:</p><figure><img src="img/mirror.svg" alt="Diagrama que muestra el efecto de trasladar y espejar un tri√°ngulo"></figure>

<p><a class="p_ident" id="p-iQ7XKEQztk" href="#p-iQ7XKEQztk" tabindex="-1" role="presentation"></a>Esto muestra los sistemas de coordenadas antes y despu√©s del espejo a trav√©s de la l√≠nea central. Los tri√°ngulos est√°n numerados para ilustrar cada paso. Si dibujamos un tri√°ngulo en una posici√≥n x positiva, por defecto estar√≠a en el lugar donde se encuentra el tri√°ngulo 1. Una llamada a <code>flipHorizontally</code> primero realiza una traslaci√≥n a la derecha, lo que nos lleva al tri√°ngulo 2. Luego escala, volteando el tri√°ngulo a la posici√≥n 3. Esto no es donde deber√≠a estar, si estuviera reflejado en la l√≠nea dada. La segunda llamada a <code>translate</code> corrige esto, ‚Äúcancela‚Äù la traslaci√≥n inicial y hace que el tri√°ngulo 4 aparezca exactamente donde deber√≠a.</p>

<p><a class="p_ident" id="p-IewluZ2i85" href="#p-IewluZ2i85" tabindex="-1" role="presentation"></a>Ahora podemos dibujar un personaje espejado en la posici√≥n (100,0) volteando el mundo alrededor del centro vertical del personaje.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-D9HyHgZKCz" href="#c-D9HyHgZKCz" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  <span class="tok-keyword">let</span> <span class="tok-definition">img</span> = document.createElement(<span class="tok-string">&quot;img&quot;</span>);
  img.src = <span class="tok-string">&quot;img/jugador.png&quot;</span>;
  <span class="tok-keyword">let</span> <span class="tok-definition">spriteW</span> = <span class="tok-number">24</span>, <span class="tok-definition">spriteH</span> = <span class="tok-number">30</span>;
  img.addEventListener(<span class="tok-string">&quot;load&quot;</span>, () =&gt; {
    flipHorizontally(cx, <span class="tok-number">100</span> + spriteW / <span class="tok-number">2</span>);
    cx.drawImage(img, <span class="tok-number">0</span>, <span class="tok-number">0</span>, spriteW, spriteH,
                 <span class="tok-number">100</span>, <span class="tok-number">0</span>, spriteW, spriteH);
  });
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<h2><a class="h_ident" id="h-IJTm33ZSO1" href="#h-IJTm33ZSO1" tabindex="-1" role="presentation"></a>Almacenando y eliminando transformaciones</h2>

<p><a class="p_ident" id="p-rJlfTniPkL" href="#p-rJlfTniPkL" tabindex="-1" role="presentation"></a>Las transformaciones permanecen. Todo lo que dibujemos despu√©s de ese personaje espejado tambi√©n estar√° reflejado. Eso podr√≠a ser inconveniente.</p>

<p><a class="p_ident" id="p-SalCElR8sc" href="#p-SalCElR8sc" tabindex="-1" role="presentation"></a>Es posible guardar la transformaci√≥n actual, hacer algunos dibujos y transformaciones, y luego restaurar la antigua transformaci√≥n. Esto suele ser lo apropiado para una funci√≥n que necesita transformar temporalmente el sistema de coordenadas. Primero, guardamos cualquier transformaci√≥n que estuviera utilizando el c√≥digo que llam√≥ a la funci√≥n. Luego, la funci√≥n realiza su tarea, agregando m√°s transformaciones sobre la transformaci√≥n actual. Finalmente, volvemos a la transformaci√≥n con la que comenzamos.</p>

<p><a class="p_ident" id="p-weTFB7xTVK" href="#p-weTFB7xTVK" tabindex="-1" role="presentation"></a>Los m√©todos <code>save</code> y <code>restore</code> en el contexto 2D del lienzo hacen este manejo de transformaciones. Conceptualmente mantienen una pila de estados de transformaci√≥n. Cuando llamas a <code>save</code>, el estado actual se apila, y cuando llamas a <code>restore</code>, se elimina el estado de la cima de la pila y se usa como la transformaci√≥n actual del contexto. Tambi√©n puedes llamar a <code>resetTransform</code> para restablecer completamente la transformaci√≥n.</p>

<p><a class="p_ident" id="p-MLYFMEHl9N" href="#p-MLYFMEHl9N" tabindex="-1" role="presentation"></a>La funci√≥n <code>branch</code> en el siguiente ejemplo ilustra lo que puedes hacer con una funci√≥n que cambia la transformaci√≥n y luego llama a una funci√≥n (en este caso a s√≠ misma), que contin√∫a dibujando con la transformaci√≥n dada.Esta funci√≥n dibuja una forma parecida a un √°rbol dibujando una l√≠nea, moviendo el centro del sistema de coordenadas al final de la l√≠nea, y llam√°ndose a s√≠ misma dos veces, primero rotada a la izquierda y luego rotada a la derecha. Cada llamada reduce la longitud de la rama dibujada, y la recursividad se detiene cuando la longitud desciende por debajo de 8.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-TvoVOvq541" href="#c-TvoVOvq541" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span> width=<span class="tok-string">&quot;600&quot;</span> height=<span class="tok-string">&quot;300&quot;</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  <span class="tok-keyword">function</span> <span class="tok-definition">branch</span>(<span class="tok-definition">length</span>, <span class="tok-definition">angle</span>, <span class="tok-definition">scale</span>) {
    cx.fillRect(<span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">1</span>, length);
    <span class="tok-keyword">if</span> (length &lt; <span class="tok-number">8</span>) <span class="tok-keyword">return</span>;
    cx.save();
    cx.translate(<span class="tok-number">0</span>, length);
    cx.rotate(-angle);
    branch(length * scale, angle, scale);
    cx.rotate(<span class="tok-number">2</span> * angle);
    branch(length * scale, angle, scale);
    cx.restore();
  }
  cx.translate(<span class="tok-number">300</span>, <span class="tok-number">0</span>);
  branch(<span class="tok-number">60</span>, <span class="tok-number">0.5</span>, <span class="tok-number">0.8</span>);
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-brpP2b1pSn" href="#p-brpP2b1pSn" tabindex="-1" role="presentation"></a>Si las llamadas a <code>save</code> y <code>restore</code> no estuvieran all√≠, la segunda llamada recursiva a <code>branch</code> terminar√≠a con la posici√≥n y rotaci√≥n creadas por la primera llamada. No estar√≠a conectada a la rama actual sino m√°s bien a la rama m√°s interna y a la derecha dibujada por la primera llamada. La forma resultante podr√≠a ser interesante, pero definitivamente no ser√≠a un √°rbol.</p>

<h2 id="canvasdisplay"><a class="h_ident" id="h-5rj4QZAZI1" href="#h-5rj4QZAZI1" tabindex="-1" role="presentation"></a>De vuelta al juego</h2>

<p><a class="p_ident" id="p-Uhavxryl5K" href="#p-Uhavxryl5K" tabindex="-1" role="presentation"></a>Ahora sabemos lo suficiente sobre el dibujo en canvas para empezar a trabajar en un sistema de display basado en canvas para el juego del <a href="16_game.html">cap√≠tulo anterior</a>. El nuevo display ya no mostrar√° solo cajas de colores. En su lugar, usaremos <code>drawImage</code> para dibujar im√°genes que representen los elementos del juego.</p>

<p><a class="p_ident" id="p-c0RKUCIK0E" href="#p-c0RKUCIK0E" tabindex="-1" role="presentation"></a>Definimos otro tipo de objeto de display llamado <code>CanvasDisplay</code>, que soporta la misma interfaz que <code>DOMDisplay</code> del <a href="16_game.html#domdisplay">Cap√≠tulo 16</a>, es decir, los m√©todos <code>syncState</code> y <code>clear</code>.</p>

<p><a class="p_ident" id="p-QpuEer5cNQ" href="#p-QpuEer5cNQ" tabindex="-1" role="presentation"></a>Este objeto mantiene un poco m√°s de informaci√≥n que <code>DOMDisplay</code>. En lugar de utilizar la posici√≥n de desplazamiento de su elemento DOM, realiza un seguimiento de su propio viewport, que nos indica qu√© parte del nivel estamos viendo actualmente. Por √∫ltimo, mantiene una propiedad <code>flipPlayer</code> para que incluso cuando el jugador est√© quieto, siga mirando en la direcci√≥n en la que se movi√≥ por √∫ltima vez.</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-sandbox="game"><a class="c_ident" id="c-0YCIeiiRNE" href="#c-0YCIeiiRNE" tabindex="-1" role="presentation"></a><span class="tok-keyword">class</span> CanvasDisplay {
  <span class="tok-definition">constructor</span>(<span class="tok-definition">parent</span>, <span class="tok-definition">level</span>) {
    <span class="tok-keyword">this</span>.canvas = document.createElement(<span class="tok-string">&quot;canvas&quot;</span>);
    <span class="tok-keyword">this</span>.canvas.width = Math.min(<span class="tok-number">600</span>, level.width * scale);
    <span class="tok-keyword">this</span>.canvas.height = Math.min(<span class="tok-number">450</span>, level.height * scale);
    parent.appendChild(<span class="tok-keyword">this</span>.canvas);
    <span class="tok-keyword">this</span>.cx = <span class="tok-keyword">this</span>.canvas.getContext(<span class="tok-string">&quot;2d&quot;</span>);

    <span class="tok-keyword">this</span>.flipPlayer = false;

    <span class="tok-keyword">this</span>.viewport = {
      <span class="tok-definition">left</span>: <span class="tok-number">0</span>,
      <span class="tok-definition">top</span>: <span class="tok-number">0</span>,
      <span class="tok-definition">width</span>: <span class="tok-keyword">this</span>.canvas.width / scale,
      <span class="tok-definition">height</span>: <span class="tok-keyword">this</span>.canvas.height / scale
    };
  }

  <span class="tok-definition">clear</span>() {
    <span class="tok-keyword">this</span>.canvas.remove();
  }
}</pre>

<p><a class="p_ident" id="p-JVl9qvzgu9" href="#p-JVl9qvzgu9" tabindex="-1" role="presentation"></a>El m√©todo <code>syncState</code> primero calcula un nuevo viewport y luego dibuja la escena del juego en la posici√≥n adecuada.</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-sandbox="game"><a class="c_ident" id="c-cERhn3J5yx" href="#c-cERhn3J5yx" tabindex="-1" role="presentation"></a>CanvasDisplay.prototype.syncState = <span class="tok-keyword">function</span>(<span class="tok-definition">state</span>) {
  <span class="tok-keyword">this</span>.updateViewport(state);
  <span class="tok-keyword">this</span>.clearDisplay(state.status);
  <span class="tok-keyword">this</span>.drawBackground(state.level);
  <span class="tok-keyword">this</span>.drawActors(state.actors);
};</pre>

<p><a class="p_ident" id="p-j+OyZJxzOM" href="#p-j+OyZJxzOM" tabindex="-1" role="presentation"></a>A diferencia de <code>DOMDisplay</code>, este estilo de visualizaci√≥n <strong>s√≠</strong> tiene que redibujar el fondo en cada actualizaci√≥n. Debido a que las formas en un lienzo son solo p√≠xeles, una vez que las dibujamos no hay una buena manera de moverlas (o eliminarlas). La √∫nica forma de actualizar la visualizaci√≥n en lienzo es borrarla y volver a dibujar la escena. Tambi√©n puede ser que hayamos hecho scroll, lo que requerir√≠a que el fondo est√© en una posici√≥n diferente.</p>

<p><a class="p_ident" id="p-LmcyJEPAXY" href="#p-LmcyJEPAXY" tabindex="-1" role="presentation"></a>El m√©todo <code>updateViewport</code> es similar al m√©todo <code>scrollPlayerIntoView</code> de <code>DOMDisplay</code>. Verifica si el jugador est√° demasiado cerca del borde de la pantalla y mueve el <strong>viewport</strong> en ese caso.</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-sandbox="game"><a class="c_ident" id="c-OjMIL2K7Ii" href="#c-OjMIL2K7Ii" tabindex="-1" role="presentation"></a>CanvasDisplay.prototype.updateViewport = <span class="tok-keyword">function</span>(<span class="tok-definition">state</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">view</span> = <span class="tok-keyword">this</span>.viewport, <span class="tok-definition">margin</span> = view.width / <span class="tok-number">3</span>;
  <span class="tok-keyword">let</span> <span class="tok-definition">player</span> = state.player;
  <span class="tok-keyword">let</span> <span class="tok-definition">center</span> = player.pos.plus(player.size.times(<span class="tok-number">0.5</span>));

  <span class="tok-keyword">if</span> (center.x &lt; view.left + margin) {
    view.left = Math.max(center.x - margin, <span class="tok-number">0</span>);
  } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (center.x &gt; view.left + view.width - margin) {
    view.left = Math.min(center.x + margin - view.width,
                         state.level.width - view.width);
  }
  <span class="tok-keyword">if</span> (center.y &lt; view.top + margin) {
    view.top = Math.max(center.y - margin, <span class="tok-number">0</span>);
  } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (center.y &gt; view.top + view.height - margin) {
    view.top = Math.min(center.y + margin - view.height,
                        state.level.height - view.height);
  }
};</pre>

<p><a class="p_ident" id="p-LTvt7zghYT" href="#p-LTvt7zghYT" tabindex="-1" role="presentation"></a>Las llamadas a <code>Math.max</code> y <code>Math.min</code> aseguran que el <strong>viewport</strong> no termine mostrando espacio fuera del nivel. <code>Math.max(x, 0)</code> se asegura de que el n√∫mero resultante no sea menor que cero. <code>Math.min</code> garantiza de manera similar que un valor se mantenga por debajo de un l√≠mite dado.</p>

<p><a class="p_ident" id="p-ciYesmCNwa" href="#p-ciYesmCNwa" tabindex="-1" role="presentation"></a>Al <strong>limpiar</strong> la visualizaci√≥n, usaremos un color ligeramente diferente seg√∫n si el juego se ha ganado (m√°s brillante) o perdido (m√°s oscuro).</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-sandbox="game"><a class="c_ident" id="c-P43rIXnt0B" href="#c-P43rIXnt0B" tabindex="-1" role="presentation"></a>CanvasDisplay.prototype.clearDisplay = <span class="tok-keyword">function</span>(<span class="tok-definition">status</span>) {
  <span class="tok-keyword">if</span> (status == <span class="tok-string">&quot;won&quot;</span>) {
    <span class="tok-keyword">this</span>.cx.fillStyle = <span class="tok-string">&quot;rgb(68, 191, 255)&quot;</span>;
  } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (status == <span class="tok-string">&quot;lost&quot;</span>) {
    <span class="tok-keyword">this</span>.cx.fillStyle = <span class="tok-string">&quot;rgb(44, 136, 214)&quot;</span>;
  } <span class="tok-keyword">else</span> {
    <span class="tok-keyword">this</span>.cx.fillStyle = <span class="tok-string">&quot;rgb(52, 166, 251)&quot;</span>;
  }
  <span class="tok-keyword">this</span>.cx.fillRect(<span class="tok-number">0</span>, <span class="tok-number">0</span>,
                   <span class="tok-keyword">this</span>.canvas.width, <span class="tok-keyword">this</span>.canvas.height);
};</pre>

<p><a class="p_ident" id="p-yjX+YUKb2N" href="#p-yjX+YUKb2N" tabindex="-1" role="presentation"></a>Para dibujar el fondo, recorremos los mosaicos que son visibles en el <strong>viewport</strong> actual, utilizando el mismo truco usado en el m√©todo <code>touches</code> del <a href="16_game.html#touches">cap√≠tulo anterior</a>.</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-sandbox="game"><a class="c_ident" id="c-UYqDAMiEp6" href="#c-UYqDAMiEp6" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">otherSprites</span> = document.createElement(<span class="tok-string">&quot;img&quot;</span>);
otherSprites.src = <span class="tok-string">&quot;img/sprites.png&quot;</span>;

CanvasDisplay.prototype.drawBackground = <span class="tok-keyword">function</span>(<span class="tok-definition">level</span>) {
  <span class="tok-keyword">let</span> {left, top, width, height} = <span class="tok-keyword">this</span>.viewport;
  <span class="tok-keyword">let</span> <span class="tok-definition">xStart</span> = Math.floor(left);
  <span class="tok-keyword">let</span> <span class="tok-definition">xEnd</span> = Math.ceil(left + width);
  <span class="tok-keyword">let</span> <span class="tok-definition">yStart</span> = Math.floor(top);
  <span class="tok-keyword">let</span> <span class="tok-definition">yEnd</span> = Math.ceil(top + height);

  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">y</span> = yStart; y &lt; yEnd; y++) {
    <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">x</span> = xStart; x &lt; xEnd; x++) {
      <span class="tok-keyword">let</span> <span class="tok-definition">tile</span> = level.rows[y][x];
      <span class="tok-keyword">if</span> (tile == <span class="tok-string">&quot;empty&quot;</span>) <span class="tok-keyword">continue</span>;
      <span class="tok-keyword">let</span> <span class="tok-definition">screenX</span> = (x - left) * scale;
      <span class="tok-keyword">let</span> <span class="tok-definition">screenY</span> = (y - top) * scale;
      <span class="tok-keyword">let</span> <span class="tok-definition">tileX</span> = tile == <span class="tok-string">&quot;lava&quot;</span> ? scale : <span class="tok-number">0</span>;
      <span class="tok-keyword">this</span>.cx.drawImage(otherSprites,
                        tileX,         <span class="tok-number">0</span>, scale, scale,
                        screenX, screenY, scale, scale);
    }
  }
};</pre>

<p><a class="p_ident" id="p-EitgnSjUGR" href="#p-EitgnSjUGR" tabindex="-1" role="presentation"></a>Las casillas que no est√°n vac√≠as se dibujan con <code>drawImage</code>. La imagen <code>otherSprites</code> contiene las im√°genes utilizadas para elementos que no son el jugador. Contiene, de izquierda a derecha, la casilla de pared, la casilla de lava y el sprite de una moneda.</p><figure><img src="img/sprites_big.png" alt="Arte pixelado que muestra tres sprites: una pieza de pared, hecha de peque√±as piedras blancas, un cuadrado de lava naranja y una moneda redonda."></figure>

<p><a class="p_ident" id="p-pZ+9buT79l" href="#p-pZ+9buT79l" tabindex="-1" role="presentation"></a>Las casillas de fondo son de 20 por 20 p√≠xeles ya que usaremos la misma escala que en <code>DOMDisplay</code>. Por lo tanto, el desplazamiento para las casillas de lava es 20 (el valor del enlace <code>scale</code>), y el desplazamiento para las paredes es 0.</p>

<p><a class="p_ident" id="p-ZcJ4ygukyJ" href="#p-ZcJ4ygukyJ" tabindex="-1" role="presentation"></a>No nos molesta esperar a que se cargue la imagen del sprite. Llamar a <code>drawImage</code> con una imagen que a√∫n no se ha cargado simplemente no har√° nada. Por lo tanto, podr√≠amos no dibujar correctamente el juego durante los primeros cuadros, mientras la imagen a√∫n se est√° cargando, pero eso no es un problema grave. Dado que seguimos actualizando la pantalla, la escena correcta aparecer√° tan pronto como termine la carga.</p>

<p><a class="p_ident" id="p-ORq0xRxiNO" href="#p-ORq0xRxiNO" tabindex="-1" role="presentation"></a>El personaje de movimiento que se mostr√≥ anteriormente se utilizar√° para representar al jugador. El c√≥digo que lo dibuja necesita seleccionar el sprite adecuado y la direcci√≥n bas√°ndose en el movimiento actual del jugador. Los primeros ocho sprites contienen una animaci√≥n de caminar. Cuando el jugador se est√° moviendo a lo largo de una superficie, los recorremos seg√∫n el tiempo actual. Queremos cambiar de fotogramas cada 60 milisegundos, por lo que primero dividimos el tiempo por 60. Cuando el jugador est√° quieto, dibujamos el noveno sprite. Durante los saltos, que se reconocen por el hecho de que la velocidad vertical no es cero, usamos el d√©cimo sprite de la derecha.</p>

<p><a class="p_ident" id="p-0A/X02lHnK" href="#p-0A/X02lHnK" tabindex="-1" role="presentation"></a>Dado que los sprites son ligeramente m√°s anchos que el objeto del jugador‚Äî24 en lugar de 16 p√≠xeles para permitir algo de espacio para los pies y los brazos‚Äîel m√©todo debe ajustar la coordenada x y el ancho por una cantidad dada (<code>playerXOverlap</code>).</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-sandbox="game"><a class="c_ident" id="c-T61uCWX04T" href="#c-T61uCWX04T" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">playerSprites</span> = document.createElement(<span class="tok-string">&quot;img&quot;</span>);
playerSprites.src = <span class="tok-string">&quot;img/player.png&quot;</span>;
<span class="tok-keyword">const</span> <span class="tok-definition">playerXOverlap</span> = <span class="tok-number">4</span>;

CanvasDisplay.prototype.drawPlayer = <span class="tok-keyword">function</span>(<span class="tok-definition">player</span>, <span class="tok-definition">x</span>, <span class="tok-definition">y</span>,
                                              <span class="tok-definition">width</span>, <span class="tok-definition">height</span>){
  width += playerXOverlap * <span class="tok-number">2</span>;
  x -= playerXOverlap;
  <span class="tok-keyword">if</span> (player.speed.x != <span class="tok-number">0</span>) {
    <span class="tok-keyword">this</span>.flipPlayer = player.speed.x &lt; <span class="tok-number">0</span>;
  }

  <span class="tok-keyword">let</span> <span class="tok-definition">tile</span> = <span class="tok-number">8</span>;
  <span class="tok-keyword">if</span> (player.speed.y != <span class="tok-number">0</span>) {
    tile = <span class="tok-number">9</span>;
  } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (player.speed.x != <span class="tok-number">0</span>) {
    tile = Math.floor(Date.now() / <span class="tok-number">60</span>) % <span class="tok-number">8</span>;
  }

  <span class="tok-keyword">this</span>.cx.save();
  <span class="tok-keyword">if</span> (<span class="tok-keyword">this</span>.flipPlayer) {
    flipHorizontally(<span class="tok-keyword">this</span>.cx, x + width / <span class="tok-number">2</span>);
  }
  <span class="tok-keyword">let</span> <span class="tok-definition">tileX</span> = tile * width;
  <span class="tok-keyword">this</span>.cx.drawImage(playerSprites, tileX, <span class="tok-number">0</span>, width, height,
                                   x,     y, width, height);
  <span class="tok-keyword">this</span>.cx.restore();
};</pre>

<p><a class="p_ident" id="p-OseNNDx2yk" href="#p-OseNNDx2yk" tabindex="-1" role="presentation"></a>El m√©todo <code>drawPlayer</code> es llamado por <code>drawActors</code>, el cual es responsable de dibujar todos los actores en el juego.</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-sandbox="game"><a class="c_ident" id="c-XwZEfLqKhO" href="#c-XwZEfLqKhO" tabindex="-1" role="presentation"></a>CanvasDisplay.prototype.drawActors = <span class="tok-keyword">function</span>(<span class="tok-definition">actors</span>) {
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">actor</span> <span class="tok-keyword">of</span> actors) {
    <span class="tok-keyword">let</span> <span class="tok-definition">width</span> = actor.size.x * scale;
    <span class="tok-keyword">let</span> <span class="tok-definition">height</span> = actor.size.y * scale;
    <span class="tok-keyword">let</span> <span class="tok-definition">x</span> = (actor.pos.x - <span class="tok-keyword">this</span>.viewport.left) * scale;
    <span class="tok-keyword">let</span> <span class="tok-definition">y</span> = (actor.pos.y - <span class="tok-keyword">this</span>.viewport.top) * scale;
    <span class="tok-keyword">if</span> (actor.type == <span class="tok-string">&quot;player&quot;</span>) {
      <span class="tok-keyword">this</span>.drawPlayer(actor, x, y, width, height);
    } <span class="tok-keyword">else</span> {
      <span class="tok-keyword">let</span> <span class="tok-definition">tileX</span> = (actor.type == <span class="tok-string">&quot;coin&quot;</span> ? <span class="tok-number">2</span> : <span class="tok-number">1</span>) * scale;
      <span class="tok-keyword">this</span>.cx.drawImage(otherSprites,
                        tileX, <span class="tok-number">0</span>, width, height,
                        x,     y, width, height);
    }
  }
};</pre>

<p><a class="p_ident" id="p-mYmRBqJrsx" href="#p-mYmRBqJrsx" tabindex="-1" role="presentation"></a>Cuando se est√° dibujando algo que no es el jugador, miramos su tipo para encontrar el desplazamiento del sprite correcto. El tile de lava se encuentra en el desplazamiento 20, y el sprite de la moneda se encuentra en 40 (dos veces <code>scale</code>).</p>

<p><a class="p_ident" id="p-l9WGkcrpyc" href="#p-l9WGkcrpyc" tabindex="-1" role="presentation"></a>Tenemos que restar la posici√≥n del viewport al calcular la posici√≥n del actor, ya que (0,0) en nuestro canvas corresponde a la esquina superior izquierda del viewport, no a la esquina superior izquierda del nivel. Tambi√©n podr√≠amos haber usado <code>translate</code> para esto. De ambas maneras funciona.</p>

<p><a class="p_ident" id="p-BKnEpLNETg" href="#p-BKnEpLNETg" tabindex="-1" role="presentation"></a>Este documento conecta el nuevo display a <code>runGame</code>:</p>

<pre tabindex="0" class="snippet" data-language="html"  data-focus="true" data-sandbox="game"><a class="c_ident" id="c-TSR2vcnWZv" href="#c-TSR2vcnWZv" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">body</span>&gt;
  &lt;<span class="tok-typeName">script</span>&gt;
    runGame(GAME_LEVELS, CanvasDisplay);
  &lt;/<span class="tok-typeName">script</span>&gt;
&lt;/<span class="tok-typeName">body</span>&gt;</pre>

<h2 id="graphics_tradeoffs"><a class="h_ident" id="h-7mCVVOn6Wy" href="#h-7mCVVOn6Wy" tabindex="-1" role="presentation"></a>Elecci√≥n de una interfaz gr√°fica</h2>

<p><a class="p_ident" id="p-cuNTHd8qgs" href="#p-cuNTHd8qgs" tabindex="-1" role="presentation"></a>Por lo tanto, cuando necesitas generar gr√°ficos en el navegador, puedes elegir entre HTML simple, SVG y canvas. No hay un enfoque √∫nico <em>mejor</em> que funcione en todas las situaciones. Cada opci√≥n tiene sus fortalezas y debilidades.</p>

<p><a class="p_ident" id="p-a0Iu5/ZW5u" href="#p-a0Iu5/ZW5u" tabindex="-1" role="presentation"></a>HTML simple tiene la ventaja de ser simple. Tambi√©n se integra bien con texto. Tanto SVG como canvas te permiten dibujar texto, pero no te ayudar√°n a posicionar ese texto o envolverlo cuando ocupa m√°s de una l√≠nea. En una imagen basada en HTML, es mucho m√°s f√°cil incluir bloques de texto.</p>

<p><a class="p_ident" id="p-3iAwjt81PX" href="#p-3iAwjt81PX" tabindex="-1" role="presentation"></a>SVG se puede utilizar para producir gr√°ficos n√≠tidos que se ven bien en cualquier nivel de zoom. A diferencia de HTML, est√° dise√±ado para dibujar y, por lo tanto, es m√°s adecuado para ese prop√≥sito.</p>

<p><a class="p_ident" id="p-KKqtQMD1GU" href="#p-KKqtQMD1GU" tabindex="-1" role="presentation"></a>Tanto SVG como HTML construyen una estructura de datos (el DOM) que representa tu imagen. Esto hace posible modificar elementos despu√©s de ser dibujados. Si necesitas cambiar repetidamente una peque√±a parte de una imagen grande en respuesta a lo que est√° haciendo el usuario o como parte de una animaci√≥n, hacerlo en un canvas puede ser innecesariamente costoso. El DOM tambi√©n nos permite registrar manipuladores de eventos de rat√≥n en cada elemento de la imagen (incluso en formas dibujadas con SVG). No puedes hacer eso con canvas.</p>

<p><a class="p_ident" id="p-RRzI6Zv0v1" href="#p-RRzI6Zv0v1" tabindex="-1" role="presentation"></a>Pero el enfoque orientado a p√≠xeles de canvas puede ser una ventaja al dibujar una gran cantidad de elementos peque√±os. El hecho de que no construye una estructura de datos, sino que solo dibuja repetidamente sobre la misma superficie de p√≠xeles, hace que canvas tenga un menor costo por forma.</p>

<p><a class="p_ident" id="p-JcCiSu5oeu" href="#p-JcCiSu5oeu" tabindex="-1" role="presentation"></a>Tambi√©n hay efectos, como renderizar una escena p√≠xel por p√≠xel (por ejemplo, usando un ray tracer) o procesar una imagen con JavaScript (desenfocarla o distorsionarla), que solo son pr√°cticos con un elemento canvas.</p>

<p><a class="p_ident" id="p-N6EbEIQTYy" href="#p-N6EbEIQTYy" tabindex="-1" role="presentation"></a>En algunos casos, puede que desees combinar varias de estas t√©cnicas. Por ejemplo, podr√≠as dibujar un gr√°fico con SVG o canvas pero mostrar informaci√≥n textual posicionando un elemento HTML encima de la imagen.</p>

<p><a class="p_ident" id="p-ur+3ZHHg7V" href="#p-ur+3ZHHg7V" tabindex="-1" role="presentation"></a>Para aplicaciones poco exigentes, realmente no importa mucho qu√© interfaz elijas. La visualizaci√≥n que construimos para nuestro juego en este cap√≠tulo podr√≠a haber sido implementada utilizando cualquiera de estas tres tecnolog√≠as gr√°ficas ya que no necesita dibujar texto, manejar interacci√≥n del mouse o trabajar con una cantidad extraordinariamente grande de elementos.</p>

<h2><a class="h_ident" id="h-NUFOUyK+lw" href="#h-NUFOUyK+lw" tabindex="-1" role="presentation"></a>Resumen</h2>

<p><a class="p_ident" id="p-SxVIOG6sY6" href="#p-SxVIOG6sY6" tabindex="-1" role="presentation"></a>En este cap√≠tulo discutimos t√©cnicas para dibujar gr√°ficos en el navegador, centr√°ndonos en el elemento <code>&lt;canvas&gt;</code>.</p>

<p><a class="p_ident" id="p-wSJk3oWZQ4" href="#p-wSJk3oWZQ4" tabindex="-1" role="presentation"></a>Un nodo canvas representa un √°rea en un documento en la que nuestro programa puede dibujar. Este dibujo se realiza a trav√©s de un objeto de contexto de dibujo, creado con el m√©todo <code>getContext</code>.</p>

<p><a class="p_ident" id="p-xBzY0lpQ5o" href="#p-xBzY0lpQ5o" tabindex="-1" role="presentation"></a>La interfaz de dibujo 2D nos permite rellenar y trazar varias formas. La propiedad <code>fillStyle</code> del contexto determina c√≥mo se rellenan las formas. Las propiedades <code>strokeStyle</code> y <code>lineWidth</code> controlan la forma en que se dibujan las l√≠neas.</p>

<p><a class="p_ident" id="p-pzTbA34IPz" href="#p-pzTbA34IPz" tabindex="-1" role="presentation"></a>Los rect√°ngulos y trozos de texto se pueden dibujar con una sola llamada a m√©todo. Los m√©todos <code>fillRect</code> y <code>strokeRect</code> dibujan rect√°ngulos, y los m√©todos <code>fillText</code> y <code>strokeText</code> dibujan texto. Para crear formas personalizadas, primero debemos construir un camino.</p>

<p><a class="p_ident" id="p-gNJPCbDPHb" href="#p-gNJPCbDPHb" tabindex="-1" role="presentation"></a>Llamar a <code>beginPath</code> inicia un nuevo camino. Varios otros m√©todos agregan l√≠neas y curvas al camino actual. Por ejemplo, <code>lineTo</code> puede agregar una l√≠nea recta. Cuando un camino est√° terminado, se puede rellenar con el m√©todo <code>fill</code> o trazarse con el m√©todo <code>stroke</code>.</p>

<p><a class="p_ident" id="p-WlLN55doNo" href="#p-WlLN55doNo" tabindex="-1" role="presentation"></a>Mover p√≠xeles desde una imagen u otro canvas a nuestro canvas se hace con el m√©todo <code>drawImage</code>. Por defecto, este m√©todo dibuja toda la imagen fuente, pero al darle m√°s par√°metros, puedes copiar un √°rea espec√≠fica de la imagen. Utilizamos esto para nuestro juego copiando poses individuales del personaje del juego de una imagen que conten√≠a muchas poses.</p>

<p><a class="p_ident" id="p-DfCg8B2Ck8" href="#p-DfCg8B2Ck8" tabindex="-1" role="presentation"></a>Las transformaciones te permiten dibujar una forma en m√∫ltiples orientaciones. Un contexto de dibujo 2D tiene una transformaci√≥n actual que se puede cambiar con los m√©todos <code>translate</code>, <code>scale</code> y <code>rotate</code>. Estos afectar√°n todas las operaciones de dibujo subsiguientes. Un estado de transformaci√≥n se puede guardar con el m√©todo <code>save</code> y restaurar con el m√©todo <code>restore</code>.</p>

<p><a class="p_ident" id="p-RN8WgeZRpl" href="#p-RN8WgeZRpl" tabindex="-1" role="presentation"></a>Al mostrar una animaci√≥n en un canvas, se puede usar el m√©todo <code>clearRect</code> para borrar parte del canvas antes de volver a dibujarlo.</p>

<h2><a class="h_ident" id="h-tkm7ntLto1" href="#h-tkm7ntLto1" tabindex="-1" role="presentation"></a>Ejercicios</h2>

<h3><a class="i_ident" id="i-6W3KpJZhnW" href="#i-6W3KpJZhnW" tabindex="-1" role="presentation"></a>Formas</h3>

<p><a class="p_ident" id="p-iT72bWnKCh" href="#p-iT72bWnKCh" tabindex="-1" role="presentation"></a>Escribe un programa que dibuje las siguientes formas en un lienzo canvas:</p>

<ol>

<li>

<p><a class="p_ident" id="p-r1g3z75bQs" href="#p-r1g3z75bQs" tabindex="-1" role="presentation"></a>Un trapecio (un rect√°ngulo que es m√°s ancho en un lado)</p></li>

<li>

<p><a class="p_ident" id="p-RnXEkaR+23" href="#p-RnXEkaR+23" tabindex="-1" role="presentation"></a>Un diamante rojo diamond (un rect√°ngulo rotado 45 grados o ¬ºœÄ radianes)</p></li>

<li>

<p><a class="p_ident" id="p-nAyyEMAyNl" href="#p-nAyyEMAyNl" tabindex="-1" role="presentation"></a>Una l√≠nea en zigzag</p></li>

<li>

<p><a class="p_ident" id="p-HMNmf2kRcX" href="#p-HMNmf2kRcX" tabindex="-1" role="presentation"></a>Un espiral compuesta por 100 segmentos de l√≠nea recta</p></li>

<li>

<p><a class="p_ident" id="p-UYtj+NTTI5" href="#p-UYtj+NTTI5" tabindex="-1" role="presentation"></a>Una estrella amarilla star</p></li>

</ol><figure><img src="img/exercise_shapes.png" alt="Imagen que muestra las formas que se te pide dibujar"></figure>

<p><a class="p_ident" id="p-Zg0P7TZXO0" href="#p-Zg0P7TZXO0" tabindex="-1" role="presentation"></a>Cuando dibujes las dos √∫ltimas, es posible que quieras consultar la explicaci√≥n de <code>Math.cos</code> y <code>Math.sin</code> en el <a href="14_dom.html#sin_cos">Cap√≠tulo 14</a>, que describe c√≥mo obtener coordenadas en un c√≠rculo utilizando estas funciones.</p>

<p><a class="p_ident" id="p-5++I4nM1YH" href="#p-5++I4nM1YH" tabindex="-1" role="presentation"></a>Recomiendo crear una funci√≥n para cada forma. Pasa la posici√≥n y opcionalmente otras propiedades como el tama√±o o el n√∫mero de puntos, como par√°metros. La alternativa, que es codificar n√∫meros en todo tu c√≥digo, tiende a hacer que el c√≥digo sea innecesariamente dif√≠cil de leer y modificar.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-Lb4eOfSFvm" href="#c-Lb4eOfSFvm" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span> width=<span class="tok-string">&quot;600&quot;</span> height=<span class="tok-string">&quot;200&quot;</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);

  <span class="tok-comment">// Tu c√≥digo aqu√≠.</span>
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-hImc7Tohvp" href="#p-hImc7Tohvp" tabindex="-1" role="presentation"></a>El trapecio (1) es m√°s f√°cil de dibujar usando un recorrido. Elige coordenadas centrales adecuadas y agrega cada una de las cuatro esquinas alrededor del centro.</p>

<p><a class="p_ident" id="p-5H/3njUG1K" href="#p-5H/3njUG1K" tabindex="-1" role="presentation"></a>{{index ‚Äúfunci√≥n flipHorizontally‚Äù, rotaci√≥n}}</p>

<p><a class="p_ident" id="p-v4JHTMrZvY" href="#p-v4JHTMrZvY" tabindex="-1" role="presentation"></a>El diamante diamond (2) se puede dibujar de forma directa, con un recorrido, o de forma interesante, con una transformaci√≥n de <code>rotaci√≥n</code>. Para usar la rotaci√≥n, tendr√°s que aplicar un truco similar al que hicimos en la funci√≥n <code>flipHorizontally</code>. Debido a que quieres rotar alrededor del centro de tu rect√°ngulo y no alrededor del punto (0,0), primero debes <code>translate</code> all√≠, luego rotar, y luego volver a trasladar.</p>

<p><a class="p_ident" id="p-UT6K3d6lOT" href="#p-UT6K3d6lOT" tabindex="-1" role="presentation"></a>Aseg√∫rate de restablecer la transformaci√≥n despu√©s de dibujar cualquier forma que la cree.</p>

<p><a class="p_ident" id="p-6aPL81jRO0" href="#p-6aPL81jRO0" tabindex="-1" role="presentation"></a>Para el zigzag (3) se vuelve impr√°ctico escribir una nueva llamada a <code>lineTo</code> para cada segmento de l√≠nea. En su lugar, deber√≠as usar un bucle. En cada iteraci√≥n, puedes hacer que dibuje dos segmentos de l√≠nea (derecha y luego izquierda nuevamente) o uno, en cuyo caso debes usar la paridad (<code>% 2</code>) del √≠ndice del bucle para determinar si ir a la izquierda o a la derecha.</p>

<p><a class="p_ident" id="p-3DikRGSFgr" href="#p-3DikRGSFgr" tabindex="-1" role="presentation"></a>Tambi√©n necesitar√°s un bucle para la espiral (4). Si dibujas una serie de puntos, con cada punto movi√©ndose m√°s lejos a lo largo de un c√≠rculo alrededor del centro de la espiral, obtienes un c√≠rculo. Si, durante el bucle, var√≠as el radio del c√≠rculo en el que est√°s poniendo el punto actual y das m√°s de una vuelta, el resultado es una espiral.</p>

<p><a class="p_ident" id="p-nnbEXh4bjC" href="#p-nnbEXh4bjC" tabindex="-1" role="presentation"></a>La estrella (5) representada est√° construida con l√≠neas <code>quadraticCurveTo</code>. Tambi√©n podr√≠as dibujar una con l√≠neas rectas. Divide un c√≠rculo en ocho piezas para una estrella con ocho puntas, o cuantas piezas desees. Dibuja l√≠neas entre estos puntos, haci√©ndolas curvar hacia el centro de la estrella. Con <code>quadraticCurveTo</code>, puedes usar el centro como punto de control.</p>

</div></details>

<h3 id="exercise_pie_chart"><a class="i_ident" id="i-BMrB5aTm8r" href="#i-BMrB5aTm8r" tabindex="-1" role="presentation"></a>El gr√°fico circular</h3>

<p><a class="p_ident" id="p-6jUrW+U79l" href="#p-6jUrW+U79l" tabindex="-1" role="presentation"></a>Anteriormente en este cap√≠tulo, vimos un programa de ejemplo que dibujaba un gr√°fico circular. Modifica este programa para que el nombre de cada categor√≠a se muestre junto a la porci√≥n que la representa. Intenta encontrar una forma agradable de posicionar autom√°ticamente este texto que funcione tambi√©n para otros conjuntos de datos. Puedes asumir que las categor√≠as son lo suficientemente grandes como para dejar espacio suficiente para sus etiquetas.</p>

<p><a class="p_ident" id="p-ydhZmqGWMr" href="#p-ydhZmqGWMr" tabindex="-1" role="presentation"></a>Podr√≠as necesitar <code>Math.sin</code> y <code>Math.cos</code> de nuevo, que se describen en el <a href="14_dom.html#sin_cos">Cap√≠tulo 14</a>.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-DTliIvEhY1" href="#c-DTliIvEhY1" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span> width=<span class="tok-string">&quot;600&quot;</span> height=<span class="tok-string">&quot;300&quot;</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  <span class="tok-keyword">let</span> <span class="tok-definition">total</span> = results
    .reduce((<span class="tok-definition">sum</span>, {count}) =&gt; sum + count, <span class="tok-number">0</span>);
  <span class="tok-keyword">let</span> <span class="tok-definition">currentAngle</span> = -<span class="tok-number">0.5</span> * Math.PI;
  <span class="tok-keyword">let</span> <span class="tok-definition">centerX</span> = <span class="tok-number">300</span>, <span class="tok-definition">centerY</span> = <span class="tok-number">150</span>;

  <span class="tok-comment">// Add code to draw the slice labels in this loop.</span>
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">result</span> <span class="tok-keyword">of</span> results) {
    <span class="tok-keyword">let</span> <span class="tok-definition">sliceAngle</span> = (result.count / total) * <span class="tok-number">2</span> * Math.PI;
    cx.beginPath();
    cx.arc(centerX, centerY, <span class="tok-number">100</span>,
           currentAngle, currentAngle + sliceAngle);
    currentAngle += sliceAngle;
    cx.lineTo(centerX, centerY);
    cx.fillStyle = result.color;
    cx.fill();
  }
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-K+C2avvWfz" href="#p-K+C2avvWfz" tabindex="-1" role="presentation"></a>Necesitar√°s llamar a <code>fillText</code> y establecer las propiedades <code>textAlign</code> y <code>textBaseline</code> del contexto de manera que el texto termine donde quieras.</p>

<p><a class="p_ident" id="p-/TzvRLyHWY" href="#p-/TzvRLyHWY" tabindex="-1" role="presentation"></a>Una forma sensata de posicionar las etiquetas ser√≠a poner el texto en la l√≠nea que va desde el centro del c√≠rculo a trav√©s del medio de la porci√≥n. No quieres poner el texto directamente contra el lado del c√≠rculo, sino mover el texto hacia afuera del c√≠rculo por un n√∫mero determinado de p√≠xeles.</p>

<p><a class="p_ident" id="p-haGP3J94Ub" href="#p-haGP3J94Ub" tabindex="-1" role="presentation"></a>El √°ngulo de esta l√≠nea es <code>currentAngle + 0.<wbr>5 * sliceAngle</code>. El siguiente c√≥digo encuentra una posici√≥n en esta l√≠nea a 120 p√≠xeles del centro:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-7kVY28rLLf" href="#c-7kVY28rLLf" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">middleAngle</span> = currentAngle + <span class="tok-number">0.5</span> * sliceAngle;
<span class="tok-keyword">let</span> <span class="tok-definition">textX</span> = Math.cos(middleAngle) * <span class="tok-number">120</span> + centerX;
<span class="tok-keyword">let</span> <span class="tok-definition">textY</span> = Math.sin(middleAngle) * <span class="tok-number">120</span> + centerY;</pre>

<p><a class="p_ident" id="p-icUXr4QXvM" href="#p-icUXr4QXvM" tabindex="-1" role="presentation"></a>Para <code>textBaseline</code>, el valor <code>&quot;middle&quot;</code> probablemente sea apropiado al usar este enfoque. Lo que se debe usar para <code>textAlign</code> depende de en qu√© lado del c√≠rculo nos encontremos. En el lado izquierdo, deber√≠a ser <code>&quot;right&quot;</code>, y en el lado derecho, deber√≠a ser <code>&quot;left&quot;</code>, de manera que el texto se posicione lejos del c√≠rculo.</p>

<p><a class="p_ident" id="p-DWuqvj0Dl2" href="#p-DWuqvj0Dl2" tabindex="-1" role="presentation"></a>Si no est√°s seguro de c√≥mo averiguar en qu√© lado del c√≠rculo se encuentra un √°ngulo dado, consulta la explicaci√≥n de <code>Math.cos</code> en el <a href="14_dom.html#sin_cos">Cap√≠tulo 14</a>. El coseno de un √°ngulo nos indica qu√© coordenada x le corresponde, lo que a su vez nos dice exactamente en qu√© lado del c√≠rculo estamos.</p>

</div></details>

<h3><a class="i_ident" id="i-V/3ulxW65J" href="#i-V/3ulxW65J" tabindex="-1" role="presentation"></a>Una pelota rebotando</h3>

<p><a class="p_ident" id="p-E0rF74dj7i" href="#p-E0rF74dj7i" tabindex="-1" role="presentation"></a>Utiliza la t√©cnica de <code>requestAnimationFrame</code> que vimos en el <a href="14_dom.html#animationFrame">Cap√≠tulo 14</a> y <a href="16_game.html#runAnimation">Cap√≠tulo 16</a> para dibujar una caja con una pelota rebotando dentro. La pelota se mueve a una velocidad constante y rebota en los lados de la caja cuando los alcanza.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-gdyoJV+nv2" href="#c-gdyoJV+nv2" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span> width=<span class="tok-string">&quot;400&quot;</span> height=<span class="tok-string">&quot;400&quot;</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);

  <span class="tok-keyword">let</span> <span class="tok-definition">lastTime</span> = <span class="tok-keyword">null</span>;
  <span class="tok-keyword">function</span> <span class="tok-definition">frame</span>(<span class="tok-definition">time</span>) {
    <span class="tok-keyword">if</span> (lastTime != <span class="tok-keyword">null</span>) {
      updateAnimation(Math.min(<span class="tok-number">100</span>, time - lastTime) / <span class="tok-number">1000</span>);
    }
    lastTime = time;
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  <span class="tok-keyword">function</span> <span class="tok-definition">updateAnimation</span>(<span class="tok-definition">step</span>) {
    <span class="tok-comment">// Tu c√≥digo aqu√≠.</span>
  }
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-Q3e575eaiY" href="#p-Q3e575eaiY" tabindex="-1" role="presentation"></a>Un cuadro es f√°cil de dibujar con <code>strokeRect</code>. Define una variable que contenga su tama√±o o define dos variables si el ancho y alto de tu cuadro difieren. Para crear una pelota redonda, comienza un camino y llama a <code>arc(x, y, radio, 0, 7)</code>, que crea un arco que va desde cero a m√°s de un c√≠rculo completo. Luego rellena el camino.</p>

<p><a class="p_ident" id="p-wCWbSjfD5D" href="#p-wCWbSjfD5D" tabindex="-1" role="presentation"></a>Para modelar la posici√≥n y la velocidad de la pelota, puedes usar la clase <code>Vec</code> del <a href="16_game.html#vector">Cap√≠tulo 16</a> (que est√° disponible en esta p√°gina){if interactive}. Dale una velocidad inicial, preferiblemente una que no sea puramente vertical u horizontal, y en cada cuadro multiplica esa velocidad por la cantidad de tiempo transcurrido. Cuando la pelota se acerca demasiado a una pared vertical, invierte el componente x en su velocidad. De manera similar, invierte el componente y cuando golpea una pared horizontal.</p>

<p><a class="p_ident" id="p-VxbSsJWTCt" href="#p-VxbSsJWTCt" tabindex="-1" role="presentation"></a>Despu√©s de encontrar la nueva posici√≥n y velocidad de la pelota, usa <code>clearRect</code> para borrar la escena y vu√©lvela a dibujar usando la nueva posici√≥n.</p>

</div></details>

<h3><a class="i_ident" id="i-bWN6DLs80w" href="#i-bWN6DLs80w" tabindex="-1" role="presentation"></a>Reflejo precalculado</h3>

<p><a class="p_ident" id="p-kI8Y5v6gUy" href="#p-kI8Y5v6gUy" tabindex="-1" role="presentation"></a>Una desventaja de las transformaciones es que ralentizan el dibujo de mapas de bits. La posici√≥n y el tama√±o de cada p√≠xel deben ser transformados, y aunque es posible que los navegadores se vuelvan m√°s inteligentes sobre las transformaciones en el futuro, actualmente causan un aumento medible en el tiempo que lleva dibujar un mapa de bits.</p>

<p><a class="p_ident" id="p-NG42ekOsOP" href="#p-NG42ekOsOP" tabindex="-1" role="presentation"></a>En un juego como el nuestro, en el que solo estamos dibujando un sprite transformado, esto no es un problema. Pero imagina que necesitamos dibujar cientos de personajes o miles de part√≠culas giratorias de una explosi√≥n.</p>

<p><a class="p_ident" id="p-/D9ug4jUKG" href="#p-/D9ug4jUKG" tabindex="-1" role="presentation"></a>Piensa en una forma de permitirnos dibujar un personaje invertido sin cargar archivos de imagen adicionales y sin tener que hacer llamadas transformadas de <code>drawImage</code> en cada cuadro.</p>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-hHgQtZU0jT" href="#p-hHgQtZU0jT" tabindex="-1" role="presentation"></a>La clave para la soluci√≥n est√° en el hecho de que podemos usar un elemento canvas como imagen de origen al usar <code>drawImage</code>. Es posible crear un elemento <code>&lt;canvas&gt;</code> adicional, sin agregarlo al documento, y dibujar nuestros sprites invertidos en √©l, una vez. Al dibujar un cuadro real, simplemente copiamos los sprites ya invertidos al lienzo principal.</p>

<p><a class="p_ident" id="p-Mr2v3L0lpj" href="#p-Mr2v3L0lpj" tabindex="-1" role="presentation"></a>Se requerir√≠a cierto cuidado porque las im√°genes no se cargan instant√°neamente. Hacemos el dibujo invertido solo una vez y, si lo hacemos antes de que la imagen se cargue, no dibujar√° nada. Se puede usar un controlador de <code>&quot;load&quot;</code> en la imagen para dibujar las im√°genes invertidas en el lienzo adicional. Este lienzo se puede usar como fuente de dibujo inmediatamente (simplemente estar√° en blanco hasta que dibujemos el personaje en √©l).</p>

</div></details><nav><a href="16_game.html" title="previous chapter" aria-label="previous chapter">‚óÇ</a>¬†<a href="index.html" title="cover" aria-label="cover">‚óè</a>¬†<a href="18_http.html" title="next chapter" aria-label="next chapter">‚ñ∏</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>&nbsp;<button class="dark-mode-toggle">üåô</button>
</nav>
</article>

<script src="ejs.js"></script>
