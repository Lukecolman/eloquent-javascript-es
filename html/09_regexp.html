<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Expresiones regulares :: Eloquent JavaScript</title>
  <link rel=stylesheet href="css/ejs.css"><script>
      var page = {"type":"chapter","number":9}</script></head>

<article>
<nav><a href="08_error.html" title="previous chapter" aria-label="previous chapter">‚óÇ</a>¬†<a href="index.html" title="cover" aria-label="cover">‚óè</a>¬†<a href="10_modules.html" title="next chapter" aria-label="next chapter">‚ñ∏</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>&nbsp;<button class="dark-mode-toggle">üåô</button>
</nav>

<h1>Expresiones regulares</h1>

<blockquote>

<p><a class="p_ident" id="p-48rajKViXI" href="#p-48rajKViXI" tabindex="-1" role="presentation"></a>Algunas personas, cuando se enfrentan a un problema, piensan '¬°Ya s√©, usar√© expresiones regulares!‚Äô Ahora tienen dos problemas.</p>

<footer>Jamie Zawinski</footer>

</blockquote>

<blockquote>

<p><a class="p_ident" id="p-93M9wGPUIB" href="#p-93M9wGPUIB" tabindex="-1" role="presentation"></a>Cuando cortas en contra de la veta de la madera, se necesita mucha fuerza. Cuando programas en contra de la veta del problema, se necesita mucho c√≥digo.</p>

<footer>Master Yuan-Ma, <cite>El Libro de la Programaci√≥n</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_9.jpg" alt="Ilustraci√≥n de un sistema de ferrocarril que representa la estructura sint√°ctica de las expresiones regulares"></figure>

<p><a class="p_ident" id="p-cUW+3W7fmu" href="#p-cUW+3W7fmu" tabindex="-1" role="presentation"></a>Las herramientas y t√©cnicas de programaci√≥n sobreviven y se propagan de manera ca√≥tica y evolutiva. No siempre ganan las mejores o brillantes, sino aquellas que funcionan lo suficientemente bien dentro del nicho correcto o que se integran con otra pieza exitosa de tecnolog√≠a.</p>

<p><a class="p_ident" id="p-DXsuW+HRzs" href="#p-DXsuW+HRzs" tabindex="-1" role="presentation"></a>En este cap√≠tulo, discutir√© una de esas herramientas, <em>expresiones regulares</em>. Las expresiones regulares son una forma de describir patr√≥nes en datos de cadena. Forman un peque√±o lenguaje separado que es parte de JavaScript y muchos otros lenguajes y sistemas.</p>

<p><a class="p_ident" id="p-7XhIkGJNrR" href="#p-7XhIkGJNrR" tabindex="-1" role="presentation"></a>Las expresiones regulares son tanto terriblemente inc√≥modas como extremadamente √∫tiles. Su sintaxis es cr√≠ptica y la interfaz de programaci√≥n que JavaScript proporciona para ellas es torpe. Pero son una herramienta poderosa para inspeccionar y procesar cadenas. Comprender adecuadamente las expresiones regulares te har√° un programador m√°s efectivo.</p>

<h2><a class="h_ident" id="h-SxIVkReIo1" href="#h-SxIVkReIo1" tabindex="-1" role="presentation"></a>Creando una expresi√≥n regular</h2>

<p><a class="p_ident" id="p-Xg1xoCrnF5" href="#p-Xg1xoCrnF5" tabindex="-1" role="presentation"></a>Una expresi√≥n regular es un tipo de objeto. Puede ser construido con el constructor <code>RegExp</code> o escrito como un valor literal al encerrar un patr√≥n entre caracteres de barra diagonal (<code>/</code>).</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-O1I2rl+HTy" href="#c-O1I2rl+HTy" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">re1</span> = <span class="tok-keyword">new</span> RegExp(<span class="tok-string">&quot;abc&quot;</span>);
<span class="tok-keyword">let</span> <span class="tok-definition">re2</span> = <span class="tok-string2">/abc/</span>;</pre>

<p><a class="p_ident" id="p-Fz6ODF3XJG" href="#p-Fz6ODF3XJG" tabindex="-1" role="presentation"></a>Ambos objetos de expresi√≥n regular representan el mismo patr√≥n: un car√°cter <em>a</em> seguido de un <em>b</em> seguido de un <em>c</em>.</p>

<p><a class="p_ident" id="p-AD2f7pq4at" href="#p-AD2f7pq4at" tabindex="-1" role="presentation"></a>Cuando se utiliza el constructor <code>RegExp</code>, el patr√≥n se escribe como una cadena normal, por lo que se aplican las reglas habituales para las barras invertidas.</p>

<p><a class="p_ident" id="p-KZsxzenKjx" href="#p-KZsxzenKjx" tabindex="-1" role="presentation"></a>La segunda notaci√≥n, donde el patr√≥n aparece entre caracteres de barra diagonal, trata las barras invertidas de manera un poco diferente. Primero, dado que una barra diagonal termina el patr√≥n, debemos poner una barra invertida antes de cualquier barra diagonal que queramos que sea <em>parte</em> del patr√≥n. Adem√°s, las barras invertidas que no forman parte de c√≥digos de caracteres especiales (como <code>\n</code>) ser√°n <em>preservadas</em>, en lugar de ser ignoradas como lo son en las cadenas, y cambian el significado del patr√≥n. Algunos caracteres, como signos de interrogaci√≥n y signos de m√°s, tienen significados especiales en las expresiones regulares y deben ser precedidos por una barra invertida si se desea representar el propio car√°cter.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-QdJ95//DRD" href="#c-QdJ95//DRD" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">aPlus</span> = <span class="tok-string2">/A\+/</span>;</pre>

<h2><a class="h_ident" id="h-s5v2OAvvFA" href="#h-s5v2OAvvFA" tabindex="-1" role="presentation"></a>Pruebas de coincidencias</h2>

<p><a class="p_ident" id="p-VTSToxvyfB" href="#p-VTSToxvyfB" tabindex="-1" role="presentation"></a>Los objetos de expresiones regulares tienen varios m√©todos. El m√°s simple es <code>test</code>. Si le pasas una cadena, devolver√° un Booleano indic√°ndote si la cadena contiene una coincidencia con el patr√≥n de la expresi√≥n.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Szn1CmrIV5" href="#c-Szn1CmrIV5" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string2">/abc/</span>.test(<span class="tok-string">&quot;abcde&quot;</span>));
<span class="tok-comment">// ‚Üí true</span>
console.log(<span class="tok-string2">/abc/</span>.test(<span class="tok-string">&quot;abxde&quot;</span>));
<span class="tok-comment">// ‚Üí false</span></pre>

<p><a class="p_ident" id="p-I9d7+CqxO+" href="#p-I9d7+CqxO+" tabindex="-1" role="presentation"></a>Una expresi√≥n regular que consiste solo en caracteres no especiales simplemente representa esa secuencia de caracteres. Si <em>abc</em> aparece en cualquier parte de la cadena contra la cual estamos probando (no solo al principio), <code>test</code> devolver√° <code>true</code>.</p>

<h2><a class="h_ident" id="h-JdVGOTeHyG" href="#h-JdVGOTeHyG" tabindex="-1" role="presentation"></a>Conjuntos de caracteres</h2>

<p><a class="p_ident" id="p-z3JS3xx91L" href="#p-z3JS3xx91L" tabindex="-1" role="presentation"></a>Descubrir si una cadena contiene <em>abc</em> tambi√©n se podr√≠a hacer con una llamada a <code>indexOf</code>. Las expresiones regulares son √∫tiles porque nos permiten describir patrones m√°s complicados.</p>

<p><a class="p_ident" id="p-Eh18fULy+Q" href="#p-Eh18fULy+Q" tabindex="-1" role="presentation"></a>Digamos que queremos hacer coincidir cualquier n√∫mero. En una expresi√≥n regular, poner un conjunto de caracteres entre corchetes hace que esa parte de la expresi√≥n coincida con cualquiera de los caracteres entre los corchetes.</p>

<p><a class="p_ident" id="p-kRrDHyV1gb" href="#p-kRrDHyV1gb" tabindex="-1" role="presentation"></a>Ambas expresiones siguientes hacen coincidir todas las cadenas que contienen un d√≠gito:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Z3UJdL//cY" href="#c-Z3UJdL//cY" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string2">/[0123456789]/</span>.test(<span class="tok-string">&quot;in 1992&quot;</span>));
<span class="tok-comment">// ‚Üí true</span>
console.log(<span class="tok-string2">/[0-9]/</span>.test(<span class="tok-string">&quot;in 1992&quot;</span>));
<span class="tok-comment">// ‚Üí true</span></pre>

<p><a class="p_ident" id="p-5qaMU7hqLJ" href="#p-5qaMU7hqLJ" tabindex="-1" role="presentation"></a>Dentro de corchetes, un guion (<code>-</code>) entre dos caracteres se puede usar para indicar un rango de caracteres, donde el orden es determinado por el n√∫mero del car√°cter en el Unicode. Los caracteres del 0 al 9 est√°n uno al lado del otro en este orden (c√≥digos 48 a 57), por lo que <code>[0-9]</code> abarca todos ellos y coincide con cualquier d√≠gito.</p>

<p><a class="p_ident" id="p-lrGSB7/f6l" href="#p-lrGSB7/f6l" tabindex="-1" role="presentation"></a>Varios grupos comunes de caracteres tienen sus propias abreviaturas incorporadas. Los d√≠gitos son uno de ellos: <code>\d</code> significa lo mismo que <code>[0-9]</code>.</p>

<table>

<tr><td><code>\d</code></td><td>Cualquier car√°cter d√≠gito</td>

</tr>

<tr><td><code>\w</code></td><td>Un car√°cter alfanum√©rico (‚Äúcar√°cter de palabra‚Äù)</td>

</tr>

<tr><td><code>\s</code></td><td>Cualquier car√°cter de espacio en blanco (espacio, tabulaci√≥n, nueva l√≠nea, y similares)</td>

</tr>

<tr><td><code>\D</code></td><td>Un car√°cter que <em>no</em> es un d√≠gito</td>

</tr>

<tr><td><code>\W</code></td><td>Un car√°cter no alfanum√©rico</td>

</tr>

<tr><td><code>\S</code></td><td>Un car√°cter que no es de espacio en blanco</td>

</tr>

<tr><td><code>.</code></td><td>Cualquier car√°cter excepto nueva l√≠nea</td>

</tr>

</table>

<p><a class="p_ident" id="p-kqSlU9BE3X" href="#p-kqSlU9BE3X" tabindex="-1" role="presentation"></a>As√≠ que podr√≠as hacer coincidir un formato de fecha y hora como 01-30-2003 15:20 con la siguiente expresi√≥n:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-wJvOGyKwyj" href="#c-wJvOGyKwyj" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">dateTime</span> = <span class="tok-string2">/\d\d-\d\d-\d\d\d\d \d\d:\d\d/</span>;
console.log(dateTime.test(<span class="tok-string">&quot;01-30-2003 15:20&quot;</span>));
<span class="tok-comment">// ‚Üí true</span>
console.log(dateTime.test(<span class="tok-string">&quot;30-ene-2003 15:20&quot;</span>));
<span class="tok-comment">// ‚Üí false</span></pre>

<p><a class="p_ident" id="p-1mBi7vFTKu" href="#p-1mBi7vFTKu" tabindex="-1" role="presentation"></a>¬°Eso se ve completamente horrible, ¬øverdad? La mitad son barras invertidas, produciendo un ruido de fondo que dificulta identificar el patr√≥n expresado. Veremos una versi√≥n ligeramente mejorada de esta expresi√≥n <a href="09_regexp.html#date_regexp_counted">m√°s adelante</a>.</p>

<p><a class="p_ident" id="p-qWhaV0LfTF" href="#p-qWhaV0LfTF" tabindex="-1" role="presentation"></a>Estos c√≥digos de barra invertida tambi√©n se pueden usar dentro de corchetes. Por ejemplo, <code>[\d.]</code> significa cualquier d√≠gito o un car√°cter de punto. Pero el punto en s√≠, entre corchetes, pierde su significado especial. Lo mismo ocurre con otros caracteres especiales, como <code>+</code>.</p>

<p><a class="p_ident" id="p-UfEuOyZI/2" href="#p-UfEuOyZI/2" tabindex="-1" role="presentation"></a>Para <em>invertir</em> un conjunto de caracteres, es decir, expresar que deseas hacer coincidir cualquier car√°cter <em>excepto</em> los que est√°n en el conjunto, puedes escribir un car√°cter circunflejo (<code>^</code>) despu√©s del corchete de apertura.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-jj4NG87MXv" href="#c-jj4NG87MXv" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">nonBinary</span> = <span class="tok-string2">/[^01]/</span>;
console.log(nonBinary.test(<span class="tok-string">&quot;1100100010100110&quot;</span>));
<span class="tok-comment">// ‚Üí false</span>
console.log(nonBinary.test(<span class="tok-string">&quot;0111010112101001&quot;</span>));
<span class="tok-comment">// ‚Üí true</span></pre>

<h2><a class="h_ident" id="h-z2+P4EyKss" href="#h-z2+P4EyKss" tabindex="-1" role="presentation"></a>Caracteres internacionales</h2>

<p><a class="p_ident" id="p-vKYjSGxrpB" href="#p-vKYjSGxrpB" tabindex="-1" role="presentation"></a>Debido a la implementaci√≥n simplista inicial de JavaScript y al hecho de que este enfoque simplista luego se estableci√≥ como comportamiento est√°ndar, las expresiones regulares de JavaScript son bastante simples en lo que respecta a los caracteres que no aparecen en el idioma ingl√©s. Por ejemplo, seg√∫n las expresiones regulares de JavaScript, un ‚Äúcar√°cter de palabra‚Äù es solo uno de los 26 caracteres del alfabeto latino (may√∫sculas o min√∫sculas), d√≠gitos decimales y, por alguna raz√≥n, el guion bajo. Cosas como <em>√©</em> o <em>Œ≤</em>, que definitivamente son caracteres de palabra, no coincidir√°n con <code>\w</code> (y <em>s√≠</em> coincidir√°n con <code>\W</code> en may√∫sculas, la categor√≠a de no palabras).</p>

<p><a class="p_ident" id="p-1RUMuhSGvB" href="#p-1RUMuhSGvB" tabindex="-1" role="presentation"></a>Por un extra√±o accidente hist√≥rico, <code>\s</code> (espacio en blanco) no tiene este problema y coincide con todos los caracteres que el est√°ndar Unicode considera espacios en blanco, incluidos elementos como el espacio sin ruptura y el separador de vocal mongol.</p>

<p><a class="p_ident" id="p-osUhjAOwQC" href="#p-osUhjAOwQC" tabindex="-1" role="presentation"></a>Es posible usar <code>\p</code> en una expresi√≥n regular para hacer coincidir todos los caracteres a los que el est√°ndar Unicode asigna una propiedad dada. Esto nos permite hacer coincidir cosas como letras de una manera m√°s cosmopolita. Sin embargo, nuevamente debido a la compatibilidad con los est√°ndares originales del lenguaje, estos solo se reconocen cuando se coloca un car√°cter <code>u</code> (por Unicode) despu√©s de la expresi√≥n regular.</p>

<table>

<tr><td><code>\p{L}</code></td><td>Cualquier letra</td>

</tr>

<tr><td><code>\p{N}</code></td><td>Cualquier car√°cter num√©rico</td>

</tr>

<tr><td><code>\p{P}</code></td><td>Cualquier car√°cter de puntuaci√≥n</td>

</tr>

<tr><td><code>\P{L}</code></td><td>Cualquier no letra (la P en may√∫sculas invierte)</td>

</tr>

<tr><td><code>\p{Script=Hangul}</code></td><td>Cualquier car√°cter del guion dado (ver <a href="05_higher_order.html#scripts">Cap√≠tulo 5</a>)</td>

</tr>

</table>

<p><a class="p_ident" id="p-ArOE+RMcya" href="#p-ArOE+RMcya" tabindex="-1" role="presentation"></a>Usar <code>\w</code> para el procesamiento de texto que puede necesitar manejar texto no ingl√©s (o incluso texto en ingl√©s con palabras prestadas como ‚Äúclich√©&quot;) es una desventaja, ya que no tratar√° caracteres como &quot;√©&quot; como letras. Aunque tienden a ser un poco m√°s verbosos, los grupos de propiedades <code>\p</code> son m√°s robustos.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-s9MXvH0LEh" href="#c-s9MXvH0LEh" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string2">/\p{L}/u</span>.test(<span class="tok-string">&quot;Œ±&quot;</span>));
<span class="tok-comment">// ‚Üí true</span>
console.log(<span class="tok-string2">/\p{L}/u</span>.test(<span class="tok-string">&quot;!&quot;</span>));
<span class="tok-comment">// ‚Üí false</span>
console.log(<span class="tok-string2">/\p{Script=Greek}/u</span>.test(<span class="tok-string">&quot;Œ±&quot;</span>));
<span class="tok-comment">// ‚Üí true</span>
console.log(<span class="tok-string2">/\p{Script=Arabic}/u</span>.test(<span class="tok-string">&quot;Œ±&quot;</span>));
<span class="tok-comment">// ‚Üí false</span></pre>

<p><a class="p_ident" id="p-oTgMYVkQhW" href="#p-oTgMYVkQhW" tabindex="-1" role="presentation"></a>Por otro lado, si est√°s haciendo coincidir n√∫meros para hacer algo con ellos, a menudo querr√°s usar <code>\d</code> para d√≠gitos, ya que convertir caracteres num√©ricos arbitrarios en un n√∫mero de JavaScript no es algo que una funci√≥n como <code>Number</code> pueda hacer por ti.</p>

<h2><a class="h_ident" id="h-jw7Q3yVJ5U" href="#h-jw7Q3yVJ5U" tabindex="-1" role="presentation"></a>Repetir partes de un patr√≥n</h2>

<p><a class="p_ident" id="p-Rewuh7bsSI" href="#p-Rewuh7bsSI" tabindex="-1" role="presentation"></a>Ahora sabemos c√≥mo hacer coincidir un solo d√≠gito. ¬øQu√© tal si queremos hacer coincidir un n√∫mero entero, una secuencia de uno o m√°s d√≠gitos?</p>

<p><a class="p_ident" id="p-wGrdJKTgSN" href="#p-wGrdJKTgSN" tabindex="-1" role="presentation"></a>Cuando colocas un signo m√°s (<code>+</code>) despu√©s de algo en una expresi√≥n regular, indica que el elemento puede repetirse m√°s de una vez. As√≠, <code>/\d+/</code> hace coincidir uno o m√°s caracteres de d√≠gitos.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-9/5mFF4Ih4" href="#c-9/5mFF4Ih4" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string2">/'\d+'/</span>.test(<span class="tok-string">&quot;'123'&quot;</span>));
<span class="tok-comment">// ‚Üí true</span>
console.log(<span class="tok-string2">/'\d+'/</span>.test(<span class="tok-string">&quot;''&quot;</span>));
<span class="tok-comment">// ‚Üí false</span>
console.log(<span class="tok-string2">/'\d*'/</span>.test(<span class="tok-string">&quot;'123'&quot;</span>));
<span class="tok-comment">// ‚Üí true</span>
console.log(<span class="tok-string2">/'\d*'/</span>.test(<span class="tok-string">&quot;''&quot;</span>));
<span class="tok-comment">// ‚Üí true</span></pre>

<p><a class="p_ident" id="p-s2rQiOFAes" href="#p-s2rQiOFAes" tabindex="-1" role="presentation"></a>El asterisco (<code>*</code>) tiene un significado similar pero tambi√©n permite que el patr√≥n coincida cero veces. Algo con un asterisco despu√©s nunca impide que un patr√≥n coincida, simplemente coincidir√° cero veces si no puede encontrar ning√∫n texto adecuado para hacer coincidir.</p>

<p><a class="p_ident" id="p-z8tNT58Jv0" href="#p-z8tNT58Jv0" tabindex="-1" role="presentation"></a>Un signo de interrogaci√≥n hace que una parte de un patr√≥n sea <em>opcional</em>, lo que significa que puede ocurrir cero veces o una vez. En el siguiente ejemplo, se permite que el car√°cter <em>u</em> ocurra, pero el patr√≥n tambi√©n coincide cuando falta.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-EiCIowdq+d" href="#c-EiCIowdq+d" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">neighbor</span> = <span class="tok-string2">/neighbou?r/</span>;
console.log(neighbor.test(<span class="tok-string">&quot;neighbour&quot;</span>));
<span class="tok-comment">// ‚Üí true</span>
console.log(neighbor.test(<span class="tok-string">&quot;neighbor&quot;</span>));
<span class="tok-comment">// ‚Üí true</span></pre>

<p><a class="p_ident" id="p-pQrIOoMzrK" href="#p-pQrIOoMzrK" tabindex="-1" role="presentation"></a>Para indicar que un patr√≥n debe ocurrir un n√∫mero preciso de veces, utiliza llaves. Colocar <code>{4}</code> despu√©s de un elemento, por ejemplo, requiere que ocurra exactamente cuatro veces. Tambi√©n es posible especificar un rango de esta manera: <code>{2,4}</code> significa que el elemento debe ocurrir al menos dos veces y como m√°ximo cuatro veces.</p>

<p id="date_regexp_counted"><a class="p_ident" id="p-lup45v+KG+" href="#p-lup45v+KG+" tabindex="-1" role="presentation"></a>Aqu√≠ tienes otra versi√≥n del patr√≥n de fecha y hora que permite d√≠as, meses y horas de uno o dos d√≠gitos. Tambi√©n es un poco m√°s f√°cil de entender.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Tw+K6Mxe45" href="#c-Tw+K6Mxe45" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">dateTime</span> = <span class="tok-string2">/\d{1,2}-\d{1,2}-\d{4} \d{1,2}:\d{2}/</span>;
console.log(dateTime.test(<span class="tok-string">&quot;1-30-2003 8:45&quot;</span>));
<span class="tok-comment">// ‚Üí true</span></pre>

<p><a class="p_ident" id="p-PBrmor3xzD" href="#p-PBrmor3xzD" tabindex="-1" role="presentation"></a>Tambi√©n puedes especificar rangos abiertos al utilizar llaves omitiendo el n√∫mero despu√©s de la coma. As√≠, <code>{5,}</code> significa cinco o m√°s veces.</p>

<h2><a class="h_ident" id="h-ajNAW/IU6r" href="#h-ajNAW/IU6r" tabindex="-1" role="presentation"></a>Agrupaci√≥n de subexpresiones</h2>

<p><a class="p_ident" id="p-v3uf4iDeF4" href="#p-v3uf4iDeF4" tabindex="-1" role="presentation"></a>Para usar un operador como <code>*</code> o <code>+</code> en m√°s de un elemento a la vez, debes utilizar par√©ntesis. Una parte de una expresi√≥n regular que est√° encerrada entre par√©ntesis cuenta como un solo elemento en lo que respecta a los operadores que le siguen.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-P/f6a65XwI" href="#c-P/f6a65XwI" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">cartoonCrying</span> = <span class="tok-string2">/boo+(hoo+)+/i</span>;
console.log(cartoonCrying.test(<span class="tok-string">&quot;Boohoooohoohooo&quot;</span>));
<span class="tok-comment">// ‚Üí true</span></pre>

<p><a class="p_ident" id="p-1LZtgULsIM" href="#p-1LZtgULsIM" tabindex="-1" role="presentation"></a>Los primeros y segundos caracteres <code>+</code> aplican solo al segundo <em>o</em> en <em>boo</em> y <em>hoo</em>, respectivamente. El tercer <code>+</code> se aplica a todo el grupo <code>(hoo+)</code>, haciendo coincidir una o m√°s secuencias como esa.</p>

<p><a class="p_ident" id="p-uBIcF0MS0l" href="#p-uBIcF0MS0l" tabindex="-1" role="presentation"></a>La <code>i</code> al final de la expresi√≥n en el ejemplo hace que esta expresi√≥n regular ignore may√∫sculas y min√∫sculas, lo que le permite hacer coincidir la <em>B</em> may√∫scula en la cadena de entrada, aunque el patr√≥n en s√≠ est√° completamente en min√∫sculas.</p>

<h2><a class="h_ident" id="h-G8LUB/KGbs" href="#h-G8LUB/KGbs" tabindex="-1" role="presentation"></a>Coincidencias y grupos</h2>

<p><a class="p_ident" id="p-4/Ykf8h2Ls" href="#p-4/Ykf8h2Ls" tabindex="-1" role="presentation"></a>El m√©todo <code>test</code> es la forma m√°s simple de hacer coincidir una expresi√≥n regular. Solo te indica si hubo coincidencia y nada m√°s. Las expresiones regulares tambi√©n tienen un m√©todo <code>exec</code> (ejecutar) que devolver√° <code>null</code> si no se encontr√≥ ninguna coincidencia y devolver√° un objeto con informaci√≥n sobre la coincidencia en caso contrario.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-geq7uRLZVm" href="#c-geq7uRLZVm" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">coincidencia</span> = <span class="tok-string2">/\d+/</span>.exec(<span class="tok-string">&quot;uno dos 100&quot;</span>);
console.log(coincidencia);
<span class="tok-comment">// ‚Üí [&quot;100&quot;]</span>
console.log(coincidencia.index);
<span class="tok-comment">// ‚Üí 8</span></pre>

<p><a class="p_ident" id="p-MEyBiymd+J" href="#p-MEyBiymd+J" tabindex="-1" role="presentation"></a>Un objeto devuelto por <code>exec</code> tiene una propiedad de <code>index</code> que nos dice <em>d√≥nde</em> en la cadena comienza la coincidencia exitosa. Aparte de eso, el objeto parece (y de hecho es) un array de strings, cuyo primer elemento es la cadena que coincidi√≥. En el ejemplo anterior, esta es la secuencia de d√≠gitos que est√°bamos buscando.</p>

<p><a class="p_ident" id="p-e2o3R6JZyN" href="#p-e2o3R6JZyN" tabindex="-1" role="presentation"></a>Los valores de tipo string tienen un m√©todo <code>match</code> que se comporta de manera similar.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-KCEzXI85eI" href="#c-KCEzXI85eI" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">&quot;uno dos 100&quot;</span>.match(<span class="tok-string2">/\d+/</span>));
<span class="tok-comment">// ‚Üí [&quot;100&quot;]</span></pre>

<p><a class="p_ident" id="p-mvGBAzey4W" href="#p-mvGBAzey4W" tabindex="-1" role="presentation"></a>Cuando la expresi√≥n regular contiene subexpresiones agrupadas con par√©ntesis, el texto que coincidi√≥ con esos grupos tambi√©n aparecer√° en el array. La coincidencia completa es siempre el primer elemento. El siguiente elemento es la parte coincidente con el primer grupo (el que tiene el par√©ntesis de apertura primero en la expresi√≥n), luego el segundo grupo, y as√≠ sucesivamente.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-DhEu3yj+hp" href="#c-DhEu3yj+hp" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">textoEntreComillas</span> = <span class="tok-string2">/'([^']*)'/</span>;
console.log(textoEntreComillas.exec(<span class="tok-string">&quot;ella dijo 'hola'&quot;</span>));
<span class="tok-comment">// ‚Üí [&quot;'hola'&quot;, &quot;hola&quot;]</span></pre>

<p><a class="p_ident" id="p-mesWUfRxLZ" href="#p-mesWUfRxLZ" tabindex="-1" role="presentation"></a>Cuando un grupo no termina coincidiendo en absoluto (por ejemplo, cuando est√° seguido por un signo de pregunta), su posici√≥n en el array de salida contendr√° <code>undefined</code>. Y cuando un grupo coincide m√∫ltiples veces (por ejemplo, cuando est√° seguido por un <code>+</code>), solo la √∫ltima coincidencia termina en el array.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-SEbCBydGa3" href="#c-SEbCBydGa3" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string2">/mal(mente)?/</span>.exec(<span class="tok-string">&quot;mal&quot;</span>));
<span class="tok-comment">// ‚Üí [&quot;mal&quot;, undefined]</span>
console.log(<span class="tok-string2">/(\d)+/</span>.exec(<span class="tok-string">&quot;123&quot;</span>));
<span class="tok-comment">// ‚Üí [&quot;123&quot;, &quot;3&quot;]</span></pre>

<p><a class="p_ident" id="p-SAuB3/3lpK" href="#p-SAuB3/3lpK" tabindex="-1" role="presentation"></a>Si quieres utilizar par√©ntesis puramente para agrupar, sin que aparezcan en el array de coincidencias, puedes colocar <code>?:</code> despu√©s del par√©ntesis de apertura.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-JYRtOm6gNP" href="#c-JYRtOm6gNP" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string2">/(?:na)+/</span>.exec(<span class="tok-string">&quot;banana&quot;</span>));
<span class="tok-comment">// ‚Üí [&quot;nana&quot;]</span></pre>

<p><a class="p_ident" id="p-kh0zXCIbfV" href="#p-kh0zXCIbfV" tabindex="-1" role="presentation"></a>Los grupos pueden ser √∫tiles para extraer partes de una cadena. Si no solo queremos verificar si una cadena contiene una fecha sino tambi√©n extraerla y construir un objeto que la represente, podemos envolver par√©ntesis alrededor de los patrones de d√≠gitos y seleccionar directamente la fecha del resultado de <code>exec</code>.</p>

<p><a class="p_ident" id="p-YRmJQbp4Jt" href="#p-YRmJQbp4Jt" tabindex="-1" role="presentation"></a>Pero primero haremos un breve desv√≠o, en el que discutiremos la forma incorporada de representar fechas y horas en JavaScript.</p>

<h2><a class="h_ident" id="h-Mi5NWDyYJW" href="#h-Mi5NWDyYJW" tabindex="-1" role="presentation"></a>La clase Date</h2>

<p><a class="p_ident" id="p-iS/kDBNVYY" href="#p-iS/kDBNVYY" tabindex="-1" role="presentation"></a>JavaScript tiene una clase est√°ndar para representar fechas‚Äîo, m√°s bien, puntos en tiempo. Se llama <code>Date</code>. Si simplemente creas un objeto de fecha usando <code>new</code>, obtendr√°s la fecha y hora actuales.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-pkHhVmn87o" href="#c-pkHhVmn87o" tabindex="-1" role="presentation"></a>console.log(<span class="tok-keyword">new</span> Date());
<span class="tok-comment">// ‚Üí Fri Feb 02 2024 18:03:06 GMT+0100 (CET)</span></pre>

<p><a class="p_ident" id="p-WBNfYVwKZS" href="#p-WBNfYVwKZS" tabindex="-1" role="presentation"></a>Tambi√©n puedes crear un objeto para un momento espec√≠fico.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-FkAc42qjrU" href="#c-FkAc42qjrU" tabindex="-1" role="presentation"></a>console.log(<span class="tok-keyword">new</span> Date(<span class="tok-number">2009</span>, <span class="tok-number">11</span>, <span class="tok-number">9</span>));
<span class="tok-comment">// ‚Üí Mi√© Dec 09 2009 00:00:00 GMT+0100 (CET)</span>
console.log(<span class="tok-keyword">new</span> Date(<span class="tok-number">2009</span>, <span class="tok-number">11</span>, <span class="tok-number">9</span>, <span class="tok-number">12</span>, <span class="tok-number">59</span>, <span class="tok-number">59</span>, <span class="tok-number">999</span>));
<span class="tok-comment">// ‚Üí Mi√© Dec 09 2009 12:59:59 GMT+0100 (CET)</span></pre>

<p><a class="p_ident" id="p-Bw0MeCio5N" href="#p-Bw0MeCio5N" tabindex="-1" role="presentation"></a>JavaScript utiliza una convenci√≥n donde los n√∫meros de mes empiezan en cero (por lo que diciembre es 11), pero los n√∫meros de d√≠a comienzan en uno. Esto es confuso y tonto. Ten cuidado.</p>

<p><a class="p_ident" id="p-HgiufDrqlL" href="#p-HgiufDrqlL" tabindex="-1" role="presentation"></a>Los √∫ltimos cuatro argumentos (horas, minutos, segundos y milisegundos) son opcionales y se consideran cero cuando no se proporcionan.</p>

<p><a class="p_ident" id="p-gxwZAuY3o1" href="#p-gxwZAuY3o1" tabindex="-1" role="presentation"></a>Las marcas de tiempo se almacenan como el n√∫mero de milisegundos desde el comienzo de 1970, en UTC (zona horaria). Esto sigue una convenci√≥n establecida por ‚Äútiempo de Unix‚Äù, que fue inventado alrededor de esa √©poca. Puedes usar n√∫meros negativos para tiempos antes de 1970. El m√©todo <code>getTime</code> en un objeto de fecha retorna este n√∫mero. Es grande, como te puedes imaginar.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Lj+Qss3ZWD" href="#c-Lj+Qss3ZWD" tabindex="-1" role="presentation"></a>console.log(<span class="tok-keyword">new</span> Date(<span class="tok-number">2013</span>, <span class="tok-number">11</span>, <span class="tok-number">19</span>).getTime());
<span class="tok-comment">// ‚Üí 1387407600000</span>
console.log(<span class="tok-keyword">new</span> Date(<span class="tok-number">1387407600000</span>));
<span class="tok-comment">// ‚Üí Jue Dec 19 2013 00:00:00 GMT+0100 (CET)</span></pre>

<p><a class="p_ident" id="p-nCAtjqvFCh" href="#p-nCAtjqvFCh" tabindex="-1" role="presentation"></a>Si le proporcionas un √∫nico argumento al constructor <code>Date</code>, ese argumento se tratar√° como un recuento de milisegundos. Puedes obtener el recuento actual de milisegundos creando un nuevo objeto <code>Date</code> y llamando a <code>getTime</code> en √©l o llamando a la funci√≥n <code>Date.now</code>.</p>

<p><a class="p_ident" id="p-VscGabP21e" href="#p-VscGabP21e" tabindex="-1" role="presentation"></a>Los objetos de fecha proporcionan m√©todos como <code>getFullYear</code>, <code>getMonth</code>, <code>getDate</code>, <code>getHours</code>, <code>getMinutes</code> y <code>getSeconds</code> para extraer sus componentes. Adem√°s de <code>getFullYear</code>, tambi√©n existe <code>getYear</code>, que te da el a√±o menos 1900 (<code>98</code> o <code>119</code>) y es en su mayor√≠a in√∫til.</p>

<p><a class="p_ident" id="p-eA5U6lb8Dx" href="#p-eA5U6lb8Dx" tabindex="-1" role="presentation"></a>Poniendo par√©ntesis alrededor de las partes de la expresi√≥n que nos interesan, podemos crear un objeto de fecha a partir de una cadena.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-SU0rTpHzGn" href="#c-SU0rTpHzGn" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">getDate</span>(<span class="tok-definition">string</span>) {
  <span class="tok-keyword">let</span> [<span class="tok-definition">_</span>, <span class="tok-definition">month</span>, <span class="tok-definition">day</span>, <span class="tok-definition">year</span>] =
    <span class="tok-string2">/(\d{1,2})-(\d{1,2})-(\d{4})/</span>.exec(string);
  <span class="tok-keyword">return</span> <span class="tok-keyword">new</span> Date(year, month - <span class="tok-number">1</span>, day);
}
console.log(getDate(<span class="tok-string">&quot;1-30-2003&quot;</span>));
<span class="tok-comment">// ‚Üí Jue Ene 30 2003 00:00:00 GMT+0100 (CET)</span></pre>

<p><a class="p_ident" id="p-rkfkh1qvgb" href="#p-rkfkh1qvgb" tabindex="-1" role="presentation"></a>La vinculaci√≥n <code>_</code> (guion bajo) se ignora y se utiliza solo para omitir el elemento de coincidencia completa en el array devuelto por <code>exec</code>.</p>

<h2><a class="h_ident" id="h-tNtw4L7Y+r" href="#h-tNtw4L7Y+r" tabindex="-1" role="presentation"></a>L√≠mites y anticipaci√≥n</h2>

<p><a class="p_ident" id="p-qbV1DRyGh9" href="#p-qbV1DRyGh9" tabindex="-1" role="presentation"></a>Desafortunadamente, <code>getDate</code> tambi√©n extraer√° felizmente una fecha de la cadena <code>&quot;100-1-30000&quot;</code>. Una coincidencia puede ocurrir en cualquier parte de la cadena, por lo que en este caso, simplemente empezar√° en el segundo car√°cter y terminar√° en el antepen√∫ltimo car√°cter.</p>

<p><a class="p_ident" id="p-Mynhxs9BJv" href="#p-Mynhxs9BJv" tabindex="-1" role="presentation"></a>Si queremos asegurar que la coincidencia abarque toda la cadena, podemos agregar los marcadores <code>^</code> y <code>$</code>. El circunflejo coincide con el inicio de la cadena de entrada, mientras que el signo de d√≥lar coincide con el final. Por lo tanto, <code>/^\d+$/</code> coincide con una cadena que consiste completamente de uno o m√°s d√≠gitos, <code>/^!/</code> coincide con cualquier cadena que comience con un signo de exclamaci√≥n y <code>/x^/</code> no coincide con ninguna cadena (no puede haber una <em>x</em> antes del inicio de la cadena).</p>

<p><a class="p_ident" id="p-LrT5oRdCQy" href="#p-LrT5oRdCQy" tabindex="-1" role="presentation"></a>Tambi√©n existe un marcador <code>\b</code>, que coincide con los ‚Äúl√≠mites de palabra‚Äù, posiciones que tienen un car√°cter de palabra a un lado y un car√°cter que no es de palabra al otro. Desafortunadamente, estos utilizan el mismo concepto simplista de caracteres de palabra que <code>\w</code>, por lo que no son muy confiables.</p>

<p><a class="p_ident" id="p-RfgTmK5+t/" href="#p-RfgTmK5+t/" tabindex="-1" role="presentation"></a>Ten en cuenta que estos marcadores no coinciden con ning√∫n car√°cter real. Simplemente aseguran que se cumpla una condici√≥n determinada en el lugar donde aparecen en el patr√≥n.</p>

<p><a class="p_ident" id="p-HmSpm3FjH9" href="#p-HmSpm3FjH9" tabindex="-1" role="presentation"></a>Las pruebas de <em>mirar adelante</em> hacen algo similar. Proporcionan un patr√≥n y har√°n que la coincidencia falle si la entrada no coincide con ese patr√≥n, pero en realidad no mueven la posici√≥n de la coincidencia hacia adelante. Se escriben entre <code>(?=</code> y <code>)</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-ryfOqCgM06" href="#c-ryfOqCgM06" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string2">/a(?=e)/</span>.exec(<span class="tok-string">&quot;braeburn&quot;</span>));
<span class="tok-comment">// ‚Üí [&quot;a&quot;]</span>
console.log(<span class="tok-string2">/a(?! )/</span>.exec(<span class="tok-string">&quot;a b&quot;</span>));
<span class="tok-comment">// ‚Üí null</span></pre>

<p><a class="p_ident" id="p-RuQb3z5Mwx" href="#p-RuQb3z5Mwx" tabindex="-1" role="presentation"></a>Observa c√≥mo la <code>e</code> en el primer ejemplo es necesaria para coincidir, pero no forma parte de la cadena coincidente. La notaci√≥n <code>(?! )</code> expresa un mirar adelante <em>negativo</em>. Esto solo coincide si el patr√≥n entre par√©ntesis <em>no</em> coincide, lo que hace que el segundo ejemplo solo coincida con caracteres ‚Äúa‚Äù que no tienen un espacio despu√©s de ellos.</p>

<h2><a class="h_ident" id="h-TUSc554JnM" href="#h-TUSc554JnM" tabindex="-1" role="presentation"></a>Patrones de elecci√≥n</h2>

<p><a class="p_ident" id="p-g+0lsX1IVo" href="#p-g+0lsX1IVo" tabindex="-1" role="presentation"></a>Digamos que queremos saber si un texto contiene no solo un n√∫mero, sino un n√∫mero seguido de una de las palabras <em>pig</em>, <em>cow</em> o <em>chicken</em>, o cualquiera de sus formas en plural.</p>

<p><a class="p_ident" id="p-faCL6B9cwG" href="#p-faCL6B9cwG" tabindex="-1" role="presentation"></a>Podr√≠amos escribir tres expresiones regulares y probarlas sucesivamente, pero hay una forma m√°s sencilla. El car√°cter de barra vertical (<code>|</code>) denota una elecci√≥n entre el patr√≥n a su izquierda y el patr√≥n a su derecha. As√≠ que puedo decir esto:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-tEyQxhonoR" href="#c-tEyQxhonoR" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">animalCount</span> = <span class="tok-string2">/\d+ (pig|cow|chicken)s?/</span>;
console.log(animalCount.test(<span class="tok-string">&quot;15 pigs&quot;</span>));
<span class="tok-comment">// ‚Üí true</span>
console.log(animalCount.test(<span class="tok-string">&quot;15 pugs&quot;</span>));
<span class="tok-comment">// ‚Üí false</span></pre>

<p><a class="p_ident" id="p-o/w2hW+vwa" href="#p-o/w2hW+vwa" tabindex="-1" role="presentation"></a>Los par√©ntesis se pueden utilizar para limitar la parte del patr√≥n a la que se aplica el operador de barra, y puedes colocar varios de estos operadores uno al lado del otro para expresar una elecci√≥n entre m√°s de dos alternativas.</p>

<h2><a class="h_ident" id="h-LDlMA55Hgg" href="#h-LDlMA55Hgg" tabindex="-1" role="presentation"></a>La mec√°nica de la coincidencia</h2>

<p><a class="p_ident" id="p-yKsAs46XQh" href="#p-yKsAs46XQh" tabindex="-1" role="presentation"></a>Conceptualmente, cuando utilizas <code>exec</code> o <code>test</code>, el motor de expresiones regulares busca una coincidencia en tu cadena tratando de ajustar primero la expresi√≥n desde el comienzo de la cadena, luego desde el segundo car√°cter, y as√≠ sucesivamente, hasta que encuentra una coincidencia o llega al final de la cadena. Devolver√° la primera coincidencia que encuentre o fracasar√° en encontrar cualquier coincidencia.</p>

<p><a class="p_ident" id="p-F6uLAaHlXA" href="#p-F6uLAaHlXA" tabindex="-1" role="presentation"></a>Para hacer la coincidencia real, el motor trata a una expresi√≥n regular algo as√≠ como un diagrama de flujo. Este es el diagrama para la expresi√≥n de ganado en el ejemplo anterior:</p><figure><img src="img/re_pigchickens.svg" alt="Diagrama de ferrocarril que primero pasa por un recuadro etiquetado 'd√≠gito', que tiene un bucle que regresa desde despu√©s de √©l a antes de √©l, y luego un recuadro para un car√°cter de espacio. Despu√©s de eso, el ferrocarril se divide en tres, pasando por cuadros para 'pig', 'cow' y 'chicken'. Despu√©s de estos, se re√∫ne de nuevo y pasa por un cuadro etiquetado 's', que, al ser opcional, tambi√©n tiene un ferrocarril que lo pasa por alto. Finalmente, la l√≠nea llega al estado de aceptaci√≥n."></figure>

<p><a class="p_ident" id="p-6KuJyUkARn" href="#p-6KuJyUkARn" tabindex="-1" role="presentation"></a>Nuestra expresi√≥n coincide si podemos encontrar un camino desde el lado izquierdo del diagrama hasta el lado derecho. Mantenemos una posici√≥n actual en la cadena, y cada vez que avanzamos a trav√©s de un recuadro, verificamos que la parte de la cadena despu√©s de nuestra posici√≥n actual coincida con ese recuadro.</p>

<h2 id="retroceso"><a class="h_ident" id="h-nmeiqrCjN8" href="#h-nmeiqrCjN8" tabindex="-1" role="presentation"></a>Retroceso</h2>

<p><a class="p_ident" id="p-QOY2sD8j/J" href="#p-QOY2sD8j/J" tabindex="-1" role="presentation"></a>La expresi√≥n regular <code>/<wbr>^([01]+b|[\da-f]+h|\d+)$/<wbr></code> coincide ya sea con un n√∫mero binario seguido de una <em>b</em>, un n√∫mero hexadecimal (es decir, base 16, con las letras <em>a</em> a <em>f</em> representando los d√≠gitos del 10 al 15) seguido de un <em>h</em>, o un n√∫mero decimal regular sin un car√°cter de sufijo. Este es el diagrama correspondiente:</p><figure><img src="img/re_number.svg" alt="Diagrama de ferrocarril para la expresi√≥n regular '^([01]+b|\d+|[\da-f]+h)$'"></figure>

<p><a class="p_ident" id="p-F8PggnyHoN" href="#p-F8PggnyHoN" tabindex="-1" role="presentation"></a>Al coincidir con esta expresi√≥n, a menudo sucede que se ingresa por la rama superior (binaria) aunque la entrada en realidad no contenga un n√∫mero binario. Al coincidir con la cadena <code>&quot;103&quot;</code>, por ejemplo, solo se aclara en el 3 que estamos en la rama incorrecta. La cadena <em>coincide</em> con la expresi√≥n, simplemente no con la rama en la que nos encontramos actualmente.</p>

<p><a class="p_ident" id="p-7qbjzwRdSE" href="#p-7qbjzwRdSE" tabindex="-1" role="presentation"></a>Entonces, el coincidente <em>retrocede</em>. Al ingresar a una rama, recuerda su posici√≥n actual (en este caso, al principio de la cadena, justo despu√©s del primer cuadro de l√≠mite en el diagrama) para poder retroceder y probar otra rama si la actual no funciona. Para la cadena <code>&quot;103&quot;</code>, despu√©s de encontrar el car√°cter 3, intentar√° la rama para los n√∫meros hexadecimales, lo cual tambi√©n falla porque no hay un <em>h</em> despu√©s del n√∫mero. Entonces intenta la rama para los n√∫meros decimales. Esta encaja, y se informa una coincidencia despu√©s de todo.</p>

<p><a class="p_ident" id="p-0RSYS7890V" href="#p-0RSYS7890V" tabindex="-1" role="presentation"></a>El coincidente se detiene tan pronto como encuentra una coincidencia completa. Esto significa que si varias ramas podr√≠an coincidir potencialmente con una cadena, solo se usa la primera (ordenada por d√≥nde aparecen las ramas en la expresi√≥n regular).</p>

<p><a class="p_ident" id="p-G1JkUqppfY" href="#p-G1JkUqppfY" tabindex="-1" role="presentation"></a>El retroceso tambi√©n ocurre para los operadores de repetici√≥n como + y <code>*</code>. Si coincide con <code>/^.*x/</code> contra <code>&quot;abcxe&quot;</code>, la parte <code>.*</code> intentar√° primero consumir toda la cadena. Luego el motor se dar√° cuenta de que necesita una <em>x</em> para que coincida con el patr√≥n. Dado que no hay una <em>x</em> m√°s all√° del final de la cadena, el operador estrella intentar√° coincidir con un car√°cter menos. Pero el coincidente no encuentra una <em>x</em> despu√©s de <code>abcx</code> tampoco, por lo que retrocede nuevamente, coincidiendo con el operador estrella solo con <code>abc</code>. <em>Ahora</em> encuentra una <em>x</em> donde la necesita y reporta una coincidencia exitosa desde las posiciones 0 a 4.</p>

<p><a class="p_ident" id="p-PFas9MdMqI" href="#p-PFas9MdMqI" tabindex="-1" role="presentation"></a>Es posible escribir expresiones regulares que realizar√°n <em>mucho</em> retroceso. Este problema ocurre cuando un patr√≥n puede coincidir con una parte de la entrada de muchas formas diferentes. Por ejemplo, si nos confundimos al escribir una expresi√≥n regular para los n√∫meros binarios, podr√≠amos escribir accidentalmente algo como <code>/([01]+)+b/</code>.</p><figure><img src="img/re_slow.svg" alt="Diagrama de ferrocarril para la expresi√≥n regular '([01]+)+b'"></figure>

<p><a class="p_ident" id="p-jqlLoLqI3m" href="#p-jqlLoLqI3m" tabindex="-1" role="presentation"></a>Si intenta hacer coincidir una serie larga de ceros y unos sin un caracter <em>b</em> al final, el analizador primero pasa por el bucle interno hasta que se queda sin d√≠gitos. Luego se da cuenta de que no hay <em>b</em>, por lo que retrocede una posici√≥n, pasa por el bucle externo una vez y vuelve a darse por vencido, intentando retroceder nuevamente fuera del bucle interno. Continuar√° intentando todas las rutas posibles a trav√©s de estos dos bucles. Esto significa que la cantidad de trabajo se <em>duplica</em> con cada car√°cter adicional. Incluso con apenas unas pocas docenas de caracteres, la coincidencia resultante tomar√° pr√°cticamente para siempre.</p>

<h2><a class="h_ident" id="h-f49QceigRC" href="#h-f49QceigRC" tabindex="-1" role="presentation"></a>El m√©todo replace</h2>

<p><a class="p_ident" id="p-1ySwSsfW/X" href="#p-1ySwSsfW/X" tabindex="-1" role="presentation"></a>Los valores de cadena tienen un m√©todo <code>replace</code> que se puede utilizar para reemplazar parte de la cadena con otra cadena.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-dPdIdK/Wyi" href="#c-dPdIdK/Wyi" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">&quot;papa&quot;</span>.replace(<span class="tok-string">&quot;p&quot;</span>, <span class="tok-string">&quot;m&quot;</span>));
<span class="tok-comment">// ‚Üí mapa</span></pre>

<p><a class="p_ident" id="p-jRLNNW4/Hs" href="#p-jRLNNW4/Hs" tabindex="-1" role="presentation"></a>El primer argumento tambi√©n puede ser una expresi√≥n regular, en cuyo caso se reemplaza la primera coincidencia de la expresi√≥n regular. Cuando se agrega una opci√≥n <code>g</code> (para <em>global</em>) despu√©s de la expresi√≥n regular, <em>todas</em> las coincidencias en la cadena ser√°n reemplazadas, no solo la primera.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-ztGnSKyKy1" href="#c-ztGnSKyKy1" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">&quot;Borobudur&quot;</span>.replace(<span class="tok-string2">/[ou]/</span>, <span class="tok-string">&quot;a&quot;</span>));
<span class="tok-comment">// ‚Üí Barobudur</span>
console.log(<span class="tok-string">&quot;Borobudur&quot;</span>.replace(<span class="tok-string2">/[ou]/g</span>, <span class="tok-string">&quot;a&quot;</span>));
<span class="tok-comment">// ‚Üí Barabadar</span></pre>

<p><a class="p_ident" id="p-mDtLRf/Jcr" href="#p-mDtLRf/Jcr" tabindex="-1" role="presentation"></a>El verdadero poder de usar expresiones regulares con <code>replace</code> proviene del hecho de que podemos hacer referencia a grupos coincidentes en la cadena de reemplazo. Por ejemplo, digamos que tenemos una cadena larga que contiene los nombres de personas, un nombre por l√≠nea, en el formato <code>Apellido, Nombre</code>. Si queremos intercambiar estos nombres y eliminar la coma para obtener un formato <code>Nombre Apellido</code>, podemos usar el siguiente c√≥digo:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Kb7uk2ah9L" href="#c-Kb7uk2ah9L" tabindex="-1" role="presentation"></a>console.log(
  <span class="tok-string">&quot;Liskov, Barbara</span><span class="tok-string2">\n</span><span class="tok-string">McCarthy, John</span><span class="tok-string2">\n</span><span class="tok-string">Milner, Robin&quot;</span>
    .replace(<span class="tok-string2">/(\p{L}+), (\p{L}+)/gu</span>, <span class="tok-string">&quot;$2 $1&quot;</span>));
<span class="tok-comment">// ‚Üí Barbara Liskov</span>
<span class="tok-comment">//   John McCarthy</span>
<span class="tok-comment">//   Robin Milner</span></pre>

<p><a class="p_ident" id="p-p2f8BR4+jy" href="#p-p2f8BR4+jy" tabindex="-1" role="presentation"></a>Los <code>$1</code> y <code>$2</code> en la cadena de reemplazo se refieren a los grupos entre par√©ntesis en el patr√≥n. <code>$1</code> es reemplazado por el texto que coincidi√≥ con el primer grupo, <code>$2</code> por el segundo, y as√≠ sucesivamente, hasta <code>$9</code>. Toda la coincidencia se puede referenciar con <code>$&amp;</code>.</p>

<p><a class="p_ident" id="p-7Dj3BhD29k" href="#p-7Dj3BhD29k" tabindex="-1" role="presentation"></a>Es posible pasar una funci√≥n, en lugar de una cadena, como segundo argumento a <code>replace</code>. Para cada reemplazo, la funci√≥n se llamar√° con los grupos coincidentes (as√≠ como la coincidencia completa) como argumentos, y su valor de retorno se insertar√° en la nueva cadena.</p>

<p><a class="p_ident" id="p-Od/5LHikVf" href="#p-Od/5LHikVf" tabindex="-1" role="presentation"></a>Aqu√≠ tienes un ejemplo:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-uAXkxyRZne" href="#c-uAXkxyRZne" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">stock</span> = <span class="tok-string">&quot;1 lim√≥n, 2 repollos y 101 huevos&quot;</span>;
<span class="tok-keyword">function</span> <span class="tok-definition">menosUno</span>(<span class="tok-definition">match</span>, <span class="tok-definition">cantidad</span>, <span class="tok-definition">unidad</span>) {
  cantidad = Number(cantidad) - <span class="tok-number">1</span>;
  <span class="tok-keyword">if</span> (cantidad == <span class="tok-number">1</span>) { <span class="tok-comment">// solo queda uno, se elimina la 's'</span>
    unidad = unidad.slice(<span class="tok-number">0</span>, unidad.length - <span class="tok-number">1</span>);
  } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (cantidad == <span class="tok-number">0</span>) {
    cantidad = <span class="tok-string">&quot;ning√∫n&quot;</span>;
  }
  <span class="tok-keyword">return</span> cantidad + <span class="tok-string">&quot; &quot;</span> + unidad;
}
console.log(stock.replace(<span class="tok-string2">/(\d+) (\p{L}+)/gu</span>, menosUno));
<span class="tok-comment">// ‚Üí ning√∫n lim√≥n, 1 repollo y 100 huevos</span></pre>

<p><a class="p_ident" id="p-VHv2obV4AF" href="#p-VHv2obV4AF" tabindex="-1" role="presentation"></a>Esta funci√≥n toma una cadena, encuentra todas las ocurrencias de un n√∫mero seguido de una palabra alfanum√©rica, y devuelve una cadena que tiene una cantidad menos de cada una de esas ocurrencias.</p>

<p><a class="p_ident" id="p-ni452X7vOx" href="#p-ni452X7vOx" tabindex="-1" role="presentation"></a>El grupo <code>(\d+)</code> termina siendo el argumento <code>amount</code> de la funci√≥n, y el grupo <code>(\p{L}+)</code> se asigna a <code>unit</code>. La funci√≥n convierte <code>amount</code> a un n√∫mero, lo cual siempre funciona ya que coincide con <code>\d+</code>, y realiza algunos ajustes en caso de que solo quede uno o ninguno.</p>

<h2><a class="h_ident" id="h-cI0ExIcqOA" href="#h-cI0ExIcqOA" tabindex="-1" role="presentation"></a>Avaricia</h2>

<p><a class="p_ident" id="p-xH5+BJjvA9" href="#p-xH5+BJjvA9" tabindex="-1" role="presentation"></a>Es posible usar <code>replace</code> para escribir una funci√≥n que elimine todos los comentarios de un fragmento de c√≥digo JavaScript. Aqu√≠ tienes un primer intento:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-hqiQQzO7k6" href="#c-hqiQQzO7k6" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">stripComments</span>(<span class="tok-definition">code</span>) {
  <span class="tok-keyword">return</span> code.replace(<span class="tok-string2">/\/\/.*|\/\*[^]*\*\//g</span>, <span class="tok-string">&quot;&quot;</span>);
}
console.log(stripComments(<span class="tok-string">&quot;1 + /* 2 */3&quot;</span>));
<span class="tok-comment">// ‚Üí 1 + 3</span>
console.log(stripComments(<span class="tok-string">&quot;x = 10;// ¬°diez!&quot;</span>));
<span class="tok-comment">// ‚Üí x = 10;</span>
console.log(stripComments(<span class="tok-string">&quot;1 /* a */+/* b */ 1&quot;</span>));
<span class="tok-comment">// ‚Üí 1  1</span></pre>

<p><a class="p_ident" id="p-lareD54U0I" href="#p-lareD54U0I" tabindex="-1" role="presentation"></a>La parte antes del operador <em>or</em> coincide con dos caracteres de barra seguidos por cualquier cantidad de caracteres que no sean de nueva l√≠nea. La parte de comentarios de varias l√≠neas es m√°s compleja. Utilizamos <code>[^]</code> (cualquier car√°cter que no est√© en el conjunto vac√≠o de caracteres) como una forma de coincidir con cualquier car√°cter. No podemos usar simplemente un punto aqu√≠ porque los comentarios de bloque pueden continuar en una nueva l√≠nea, y el car√°cter de punto no coincide con caracteres de nueva l√≠nea.</p>

<p><a class="p_ident" id="p-mxzz/dlHK7" href="#p-mxzz/dlHK7" tabindex="-1" role="presentation"></a>Pero la salida para la √∫ltima l√≠nea parece haber salido mal. ¬øPor qu√©?</p>

<p><a class="p_ident" id="p-KYpv5oZkiP" href="#p-KYpv5oZkiP" tabindex="-1" role="presentation"></a>La parte <code>[^]*</code> de la expresi√≥n, como describ√≠ en la secci√≥n sobre retroceso, primero intentar√° coincidir con todo lo que pueda. Si esto hace que la siguiente parte del patr√≥n falle, el coincidente retrocede un car√°cter y vuelve a intentar desde ah√≠. En el ejemplo, el coincidente intenta primero coincidir con el resto completo de la cadena y luego retrocede desde all√≠. Encontrar√° una ocurrencia de <code>*/</code> despu√©s de retroceder cuatro caracteres y coincidir√° con eso. Esto no es lo que quer√≠amos, la intenci√≥n era coincidir con un √∫nico comentario, no llegar hasta el final del c√≥digo y encontrar el final del √∫ltimo comentario de bloque.</p>

<p><a class="p_ident" id="p-fC+SPfUUr7" href="#p-fC+SPfUUr7" tabindex="-1" role="presentation"></a>Debido a este comportamiento, decimos que los operadores de repetici√≥n (<code>+</code>, <code>*</code>, <code>?</code>, y <code>{}</code>) son <em>avariciosos</em>, lo que significa que coinciden con todo lo que pueden y retroceden desde all√≠. Si colocas un signo de interrogaci√≥n despu√©s de ellos (<code>+?</code>, <code>*?</code>, <code>??</code>, <code>{}?</code>), se vuelven no avariciosos y comienzan coincidiendo con la menor cantidad posible, coincidiendo m√°s solo cuando el patr√≥n restante no encaja con la coincidencia m√°s peque√±a.</p>

<p><a class="p_ident" id="p-MUXpQzArez" href="#p-MUXpQzArez" tabindex="-1" role="presentation"></a>Y eso es exactamente lo que queremos en este caso. Al hacer que el asterisco coincida con la menor cantidad de caracteres que nos lleva a <code>*/</code>, consumimos un comentario de bloque y nada m√°s.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-MCNF7GxfR1" href="#c-MCNF7GxfR1" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">stripComments</span>(<span class="tok-definition">code</span>) {
  <span class="tok-keyword">return</span> code.replace(<span class="tok-string2">/\/\/.*|\/\*[^]*?\*\//g</span>, <span class="tok-string">&quot;&quot;</span>);
}
console.log(stripComments(<span class="tok-string">&quot;1 /* a */+/* b */ 1&quot;</span>));
<span class="tok-comment">// ‚Üí 1 + 1</span></pre>

<p><a class="p_ident" id="p-ALsLlfRqmw" href="#p-ALsLlfRqmw" tabindex="-1" role="presentation"></a>Muchos errors en programas de expresi√≥n regular pueden rastrearse hasta el uso no intencionado de un operador avaricioso donde uno no avaricioso funcionar√≠a mejor. Cuando uses un operador de repetici√≥n, prefiere la variante no avariciosa.</p>

<h2><a class="h_ident" id="h-iuSjEFI6BB" href="#h-iuSjEFI6BB" tabindex="-1" role="presentation"></a>Creaci√≥n din√°mica de objetos RegExp</h2>

<p><a class="p_ident" id="p-VeBLJxBP+2" href="#p-VeBLJxBP+2" tabindex="-1" role="presentation"></a>Hay casos en los que es posible que no sepas el patr√≥n exacto que necesitas para hacer coincidir cuando est√°s escribiendo tu c√≥digo. Digamos que quieres probar el nombre de usuario en un fragmento de texto. Puedes construir una cadena y usar el <code>constructor</code> <code>RegExp</code> en ello. Aqu√≠ tienes un ejemplo:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-WfHBCcn+gy" href="#c-WfHBCcn+gy" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">name</span> = <span class="tok-string">&quot;harry&quot;</span>;
<span class="tok-keyword">let</span> <span class="tok-definition">regexp</span> = <span class="tok-keyword">new</span> RegExp(<span class="tok-string">&quot;(^|</span><span class="tok-string2">\\</span><span class="tok-string">s)&quot;</span> + name + <span class="tok-string">&quot;($|</span><span class="tok-string2">\\</span><span class="tok-string">s)&quot;</span>, <span class="tok-string">&quot;gi&quot;</span>);
console.log(regexp.test(<span class="tok-string">&quot;Harry es un personaje dudoso.&quot;</span>));
<span class="tok-comment">// ‚Üí true</span></pre>

<p><a class="p_ident" id="p-t/sBXmwE44" href="#p-t/sBXmwE44" tabindex="-1" role="presentation"></a>Al crear la parte <code>\s</code> de la cadena, tenemos que usar dos barras invertidas porque las estamos escribiendo en una cadena normal, no en una expresi√≥n regular entre barras. El segundo argumento del constructor <code>RegExp</code> contiene las opciones para la expresi√≥n regular, en este caso, <code>&quot;gi&quot;</code> para global e insensible a may√∫sculas y min√∫sculas.</p>

<p><a class="p_ident" id="p-kTObyW6aHr" href="#p-kTObyW6aHr" tabindex="-1" role="presentation"></a>Pero ¬øqu√© pasa si el nombre es <code>&quot;dea+hl[]rd&quot;</code> porque nuestro usuario es un adolescente nerd? Eso resultar√≠a en una expresi√≥n regular absurda que en realidad no coincidir√≠a con el nombre del usuario.</p>

<p><a class="p_ident" id="p-PLgFCFdANG" href="#p-PLgFCFdANG" tabindex="-1" role="presentation"></a>Para solucionar esto, podemos agregar barras invertidas antes de cualquier car√°cter que tenga un significado especial.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-E6w+CZN7CT" href="#c-E6w+CZN7CT" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">name</span> = <span class="tok-string">&quot;dea+hl[]rd&quot;</span>;
<span class="tok-keyword">let</span> <span class="tok-definition">escaped</span> = name.replace(<span class="tok-string2">/[\\[.+*?(){|^$]/g</span>, <span class="tok-string">&quot;</span><span class="tok-string2">\\</span><span class="tok-string">$&amp;&quot;</span>);
<span class="tok-keyword">let</span> <span class="tok-definition">regexp</span> = <span class="tok-keyword">new</span> RegExp(<span class="tok-string">&quot;(^|</span><span class="tok-string2">\\</span><span class="tok-string">s)&quot;</span> + escaped + <span class="tok-string">&quot;($|</span><span class="tok-string2">\\</span><span class="tok-string">s)&quot;</span>,
                        <span class="tok-string">&quot;gi&quot;</span>);
<span class="tok-keyword">let</span> <span class="tok-definition">text</span> = <span class="tok-string">&quot;Este chico dea+hl[]rd es s√∫per molesto.&quot;</span>;
console.log(regexp.test(text));
<span class="tok-comment">// ‚Üí true</span></pre>

<h2><a class="h_ident" id="h-uCPhVoLsMf" href="#h-uCPhVoLsMf" tabindex="-1" role="presentation"></a>El m√©todo search</h2>

<p><a class="p_ident" id="p-3qxpU8WQEB" href="#p-3qxpU8WQEB" tabindex="-1" role="presentation"></a>El m√©todo <code>indexOf</code> en las cadenas no puede ser llamado con una expresi√≥n regular. Pero hay otro m√©todo, <code>search</code>, que espera una expresi√≥n regular. Al igual que <code>indexOf</code>, devuelve el primer √≠ndice en el que se encontr√≥ la expresi√≥n, o -1 cuando no se encontr√≥.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-hINt/qpuxG" href="#c-hINt/qpuxG" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">&quot;  palabra&quot;</span>.search(<span class="tok-string2">/\S/</span>));
<span class="tok-comment">// ‚Üí 2</span>
console.log(<span class="tok-string">&quot;    &quot;</span>.search(<span class="tok-string2">/\S/</span>));
<span class="tok-comment">// ‚Üí -1</span></pre>

<p><a class="p_ident" id="p-bCpmiIwqTW" href="#p-bCpmiIwqTW" tabindex="-1" role="presentation"></a>Desafortunadamente, no hay una forma de indicar que la coincidencia deber√≠a comenzar en un offset dado (como se puede hacer con el segundo argumento de <code>indexOf</code>), lo cual a menudo ser√≠a √∫til.</p>

<h2><a class="h_ident" id="h-61OHLlWPwV" href="#h-61OHLlWPwV" tabindex="-1" role="presentation"></a>La propiedad lastIndex</h2>

<p><a class="p_ident" id="p-OpmhI72Qfi" href="#p-OpmhI72Qfi" tabindex="-1" role="presentation"></a>El m√©todo <code>exec</code> de manera similar no proporciona una forma conveniente de comenzar a buscar desde una posici√≥n dada en la cadena. Pero s√≠ proporciona una forma <em>in</em>conveniente.</p>

<p><a class="p_ident" id="p-JYAjlYrL9h" href="#p-JYAjlYrL9h" tabindex="-1" role="presentation"></a>Los objetos de expresi√≥n regular tienen propiedades. Una de esas propiedades es <code>source</code>, que contiene la cadena de la que se cre√≥ la expresi√≥n. Otra propiedad es <code>lastIndex</code>, que controla, en algunas circunstancias limitadas, desde d√≥nde comenzar√° la siguiente coincidencia.</p>

<p><a class="p_ident" id="p-59IpNLm2WF" href="#p-59IpNLm2WF" tabindex="-1" role="presentation"></a>Estas circunstancias implican que la expresi√≥n regular debe tener la opci√≥n global (<code>g</code>) o pegajosa (<code>y</code>) activada, y la coincidencia debe ocurrir a trav√©s del m√©todo <code>exec</code>. Nuevamente, una soluci√≥n menos confusa habr√≠a sido simplemente permitir que se pase un argumento adicional a <code>exec</code>, pero la confusi√≥n es una caracter√≠stica esencial de la interfaz de expresiones regulares de JavaScript.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-nXsHtqIJdF" href="#c-nXsHtqIJdF" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">pattern</span> = <span class="tok-string2">/y/g</span>;
pattern.lastIndex = <span class="tok-number">3</span>;
<span class="tok-keyword">let</span> <span class="tok-definition">match</span> = pattern.exec(<span class="tok-string">&quot;xyzzy&quot;</span>);
console.log(match.index);
<span class="tok-comment">// ‚Üí 4</span>
console.log(pattern.lastIndex);
<span class="tok-comment">// ‚Üí 5</span></pre>

<p><a class="p_ident" id="p-0DBtft8C4S" href="#p-0DBtft8C4S" tabindex="-1" role="presentation"></a>Si la coincidencia tuvo √©xito, la llamada a <code>exec</code> actualiza autom√°ticamente la propiedad <code>lastIndex</code> para que apunte despu√©s de la coincidencia. Si no se encontr√≥ ninguna coincidencia, <code>lastIndex</code> se restablece a cero, que es tambi√©n el valor que tiene en un objeto de expresi√≥n regular reci√©n construido.</p>

<p><a class="p_ident" id="p-1u3O8Smqjw" href="#p-1u3O8Smqjw" tabindex="-1" role="presentation"></a>La diferencia entre las opciones global y sticky es que, cuando se habilita sticky, la coincidencia solo se producir√° si comienza directamente en <code>lastIndex</code>, mientras que con global se buscar√° una posici√≥n donde pueda comenzar una coincidencia.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-98GwGRIMj8" href="#c-98GwGRIMj8" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">global</span> = <span class="tok-string2">/abc/g</span>;
console.log(global.exec(<span class="tok-string">&quot;xyz abc&quot;</span>));
<span class="tok-comment">// ‚Üí [&quot;abc&quot;]</span>
<span class="tok-keyword">let</span> <span class="tok-definition">sticky</span> = <span class="tok-string2">/abc/y</span>;
console.log(sticky.exec(<span class="tok-string">&quot;xyz abc&quot;</span>));
<span class="tok-comment">// ‚Üí null</span></pre>

<p><a class="p_ident" id="p-SPnGt76q5R" href="#p-SPnGt76q5R" tabindex="-1" role="presentation"></a>Al usar un valor de expresi√≥n regular compartido para m√∫ltiples llamadas a <code>exec</code>, estas actualizaciones autom√°ticas a la propiedad <code>lastIndex</code> pueden causar problemas. Es posible que tu expresi√≥n regular comience accidentalmente en un √≠ndice que qued√≥ de una llamada previa.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-kE2WKkyjwG" href="#c-kE2WKkyjwG" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">digit</span> = <span class="tok-string2">/\d/g</span>;
console.log(digit.exec(<span class="tok-string">&quot;aqu√≠ est√°: 1&quot;</span>));
<span class="tok-comment">// ‚Üí [&quot;1&quot;]</span>
console.log(digit.exec(<span class="tok-string">&quot;ahora: 1&quot;</span>));
<span class="tok-comment">// ‚Üí null</span></pre>

<p><a class="p_ident" id="p-M58YL9ghmR" href="#p-M58YL9ghmR" tabindex="-1" role="presentation"></a>Otro efecto interesante de la opci√≥n global es que cambia la forma en que funciona el m√©todo <code>match</code> en las cadenas. Cuando se llama con una expresi√≥n global, en lugar de devolver una matriz similar a la devuelta por <code>exec</code>, <code>match</code> encontrar√° <em>todas</em> las coincidencias del patr√≥n en la cadena y devolver√° una matriz que contiene las cadenas coincidentes.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-weT/d5+8vE" href="#c-weT/d5+8vE" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">&quot;Banana&quot;</span>.match(<span class="tok-string2">/an/g</span>));
<span class="tok-comment">// ‚Üí [&quot;an&quot;, &quot;an&quot;]</span></pre>

<p><a class="p_ident" id="p-P0n0q5qqiM" href="#p-P0n0q5qqiM" tabindex="-1" role="presentation"></a>As√≠ que ten cuidado con las expresiones regulares globales. Los casos en los que son necesarias, como las llamadas a <code>replace</code> y los lugares donde quieres usar expl√≠citamente <code>lastIndex</code>, son t√≠picamente los √∫nicos lugares donde las deseas utilizar.</p>

<h3><a class="i_ident" id="i-vqvHDgpGfT" href="#i-vqvHDgpGfT" tabindex="-1" role="presentation"></a>Obteniendo todas las coincidencias</h3>

<p><a class="p_ident" id="p-2/FZJ5j0h9" href="#p-2/FZJ5j0h9" tabindex="-1" role="presentation"></a>Algo com√∫n que se hace es encontrar todas las coincidencias de una expresi√≥n regular en una cadena. Podemos hacer esto usando el m√©todo <code>matchAll</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-otfl+S6eNg" href="#c-otfl+S6eNg" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">input</span> = <span class="tok-string">&quot;Una cadena con 3 n√∫meros... 42 y 88.&quot;</span>;
<span class="tok-keyword">let</span> <span class="tok-definition">matches</span> = input.matchAll(<span class="tok-string2">/\d+/g</span>);
<span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">match</span> <span class="tok-keyword">of</span> matches) {
  console.log(<span class="tok-string">&quot;Encontrado&quot;</span>, match[<span class="tok-number">0</span>], <span class="tok-string">&quot;en&quot;</span>, match.index);
}
<span class="tok-comment">// ‚Üí Encontrado 3 en 14</span>
<span class="tok-comment">//   Encontrado 42 en 33</span>
<span class="tok-comment">//   Encontrado 88 en 40</span></pre>

<p><a class="p_ident" id="p-+4Amv+gHld" href="#p-+4Amv+gHld" tabindex="-1" role="presentation"></a>Este m√©todo devuelve una matriz de matrices de coincidencias. La expresi√≥n regular que se le proporciona <em>debe</em> tener <code>g</code> habilitado.</p>

<h2 id="ini"><a class="h_ident" id="h-aqUstUx5TS" href="#h-aqUstUx5TS" tabindex="-1" role="presentation"></a>Analizando un archivo INI</h2>

<p><a class="p_ident" id="p-sGp7Jxx2uG" href="#p-sGp7Jxx2uG" tabindex="-1" role="presentation"></a>Para concluir el cap√≠tulo, analizaremos un problema que requiere expresiones regulares. Imagina que estamos escribiendo un programa para recopilar autom√°ticamente informaci√≥n sobre nuestros enemigos desde Internet. (En realidad, no escribiremos ese programa aqu√≠, solo la parte que lee el archivo de configuraci√≥n. Lo siento.) El archivo de configuraci√≥n se ve as√≠:</p>

<pre class="snippet" data-language="null" ><a class="c_ident" id="c-sNjz/ec/W5" href="#c-sNjz/ec/W5" tabindex="-1" role="presentation"></a>motorbusqueda=https://duckduckgo.com/?q=$1
rencor=9.7

; comentarios precedidos por un punto y coma...
; cada secci√≥n se refiere a un enemigo individual
[larry]
fullname=Larry Doe
type=mat√≥n de jard√≠n de infantes
website=http://www.geocities.com/CapeCanaveral/11451

[davaeorn]
fullname=Davaeorn
type=mago malvado
outputdir=/home/marijn/enemies/davaeorn</pre>

<p><a class="p_ident" id="p-2XRX7atQld" href="#p-2XRX7atQld" tabindex="-1" role="presentation"></a>Las reglas exactas para este formato (que es un formato ampliamente utilizado, generalmente llamado un archivo <em>INI</em>) son las siguientes:</p>

<ul>

<li>

<p><a class="p_ident" id="p-Of3fAfBjo/" href="#p-Of3fAfBjo/" tabindex="-1" role="presentation"></a>Las l√≠neas en blanco y las l√≠neas que comienzan con punto y coma son ignoradas.</p></li>

<li>

<p><a class="p_ident" id="p-aZL0fMSaMp" href="#p-aZL0fMSaMp" tabindex="-1" role="presentation"></a>Las l√≠neas envueltas en <code>[</code> y <code>]</code> inician una nueva secci√≥n.</p></li>

<li>

<p><a class="p_ident" id="p-A63YtLp+/Z" href="#p-A63YtLp+/Z" tabindex="-1" role="presentation"></a>Las l√≠neas que contienen un identificador alfanum√©rico seguido de un caracter <code>=</code> agregan una configuraci√≥n a la secci√≥n actual.</p></li>

<li>

<p><a class="p_ident" id="p-2qriKCQvre" href="#p-2qriKCQvre" tabindex="-1" role="presentation"></a>Cualquier otra cosa es inv√°lida.</p></li></ul>

<p><a class="p_ident" id="p-g7nzf3T0qT" href="#p-g7nzf3T0qT" tabindex="-1" role="presentation"></a>Nuestra tarea es convertir una cadena como esta en un objeto cuyas propiedades contienen cadenas para las configuraciones escritas antes del primer encabezado de secci√≥n y subobjetos para las secciones, con esos subobjetos conteniendo las configuraciones de la secci√≥n.</p>

<p><a class="p_ident" id="p-7z9fdAqy4R" href="#p-7z9fdAqy4R" tabindex="-1" role="presentation"></a>Dado que el formato debe procesarse l√≠nea por l√≠nea, dividir el archivo en l√≠neas separadas es un buen comienzo. Vimos el m√©todo <code>split</code> en el <a href="04_data.html#split">Cap√≠tulo 4</a>. Sin embargo, algunos sistemas operativos utilizan no solo un car√°cter de nueva l√≠nea para separar l√≠neas sino un car√°cter de retorno de carro seguido de una nueva l√≠nea (<code>&quot;\r\n&quot;</code>). Dado que el m√©todo <code>split</code> tambi√©n permite una expresi√≥n regular como argumento, podemos usar una expresi√≥n regular como <code>/\r?\n/</code> para dividir de una manera que permita tanto <code>&quot;\n&quot;</code> como <code>&quot;\r\n&quot;</code> entre l√≠neas.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-WalMuQxa8W" href="#c-WalMuQxa8W" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">parseINI</span>(<span class="tok-definition">string</span>) {
  <span class="tok-comment">// Comenzar con un objeto para contener los campos de nivel superior</span>
  <span class="tok-keyword">let</span> <span class="tok-definition">result</span> = {};
  <span class="tok-keyword">let</span> <span class="tok-definition">section</span> = result;
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">line</span> <span class="tok-keyword">of</span> string.split(<span class="tok-string2">/\r?\n/</span>)) {
    <span class="tok-keyword">let</span> <span class="tok-definition">match</span>;
    <span class="tok-keyword">if</span> (match = line.match(<span class="tok-string2">/^(\w+)=(.*)$/</span>)) {
      section[match[<span class="tok-number">1</span>]] = match[<span class="tok-number">2</span>];
    } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (match = line.match(<span class="tok-string2">/^\[(.*)\]$/</span>)) {
      section = result[match[<span class="tok-number">1</span>]] = {};
    } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (!<span class="tok-string2">/^\s*(;|$)/</span>.test(line)) {
      <span class="tok-keyword">throw</span> <span class="tok-keyword">new</span> Error(<span class="tok-string">&quot;La l√≠nea '&quot;</span> + line + <span class="tok-string">&quot;' no es v√°lida.&quot;</span>);
    }
  };
  <span class="tok-keyword">return</span> result;
}

console.log(parseINI(<span class="tok-string2">`</span>
<span class="tok-string2">name=Vasilis</span>
<span class="tok-string2">[address]</span>
<span class="tok-string2">city=Tessaloniki`</span>));
<span class="tok-comment">// ‚Üí {name: &quot;Vasilis&quot;, address: {city: &quot;Tessaloniki&quot;}}</span></pre>

<p><a class="p_ident" id="p-LsLS8mCe4B" href="#p-LsLS8mCe4B" tabindex="-1" role="presentation"></a>El c√≥digo recorre las l√≠neas del archivo y construye un objeto. Las propiedades en la parte superior se almacenan directamente en ese objeto, mientras que las propiedades encontradas en secciones se almacenan en un objeto de secci√≥n separado. El enlace <code>section</code> apunta al objeto para la secci√≥n actual.</p>

<p><a class="p_ident" id="p-W38Z15dwza" href="#p-W38Z15dwza" tabindex="-1" role="presentation"></a>Hay dos tipos de l√≠neas significativas: encabezados de secci√≥n o l√≠neas de propiedades. Cuando una l√≠nea es una propiedad regular, se almacena en la secci√≥n actual. Cuando es un encabezado de secci√≥n, se crea un nuevo objeto de secci√≥n y <code>section</code> se establece para apuntar a √©l.</p>

<p><a class="p_ident" id="p-WRi9IuRJQq" href="#p-WRi9IuRJQq" tabindex="-1" role="presentation"></a>Observa el uso recurrente de <code>^</code> y <code>$</code> para asegurarse de que la expresi√≥n coincida con toda la l√≠nea, no solo parte de ella. Dejarlos fuera resulta en un c√≥digo que funciona en su mayor parte pero se comporta de manera extra√±a para algunas entradas, lo que puede ser un error dif√≠cil de rastrear.</p>

<p><a class="p_ident" id="p-w+p65GaQlw" href="#p-w+p65GaQlw" tabindex="-1" role="presentation"></a>```El patr√≥n <code>if (match = string.<wbr>match(.<wbr>.<wbr>.<wbr>))</code> hace uso del hecho de que el valor de una expresi√≥n de asignaci√≥n (<code>=</code>) es el valor asignado. A menudo no est√°s seguro de que tu llamada a <code>match</code> tendr√° √©xito, por lo que solo puedes acceder al objeto resultante dentro de una declaraci√≥n <code>if</code> que comprueba esto. Para no romper la agradable cadena de formas de <code>else if</code>, asignamos el resultado de la coincidencia a un enlace y usamos inmediatamente esa asignaci√≥n como la prueba para la declaraci√≥n <code>if</code>.</p>

<p><a class="p_ident" id="p-zg+5BDK7MN" href="#p-zg+5BDK7MN" tabindex="-1" role="presentation"></a>Si una l√≠nea no es un encabezado de secci√≥n o una propiedad, la funci√≥n verifica si es un comentario o una l√≠nea vac√≠a usando la expresi√≥n <code>/^\s*(;|$)/</code> para hacer coincidir l√≠neas que solo contienen espacio o espacio seguido de un punto y coma (haciendo que el resto de la l√≠nea sea un comentario). Cuando una l√≠nea no coincide con ninguna de las formas esperadas, la funci√≥n lanza una excepci√≥n.</p>

<h2><a class="h_ident" id="h-boAsI3PiWP" href="#h-boAsI3PiWP" tabindex="-1" role="presentation"></a>Unidades de c√≥digo y caracteres</h2>

<p><a class="p_ident" id="p-CzHGvvAVs9" href="#p-CzHGvvAVs9" tabindex="-1" role="presentation"></a>Otro error de dise√±o que se ha estandarizado en las expresiones regulares de JavaScript es que, por defecto, operadores como <code>.</code> o <code>?</code> trabajan en unidades de c√≥digo, como se discute en el <a href="05_higher_order.html#code_units">Cap√≠tulo 5</a>, no en caracteres reales. Esto significa que los caracteres que est√°n compuestos por dos unidades de c√≥digo se comportan de manera extra√±a.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-CfMTYxun8D" href="#c-CfMTYxun8D" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string2">/üçé{3}/</span>.test(<span class="tok-string">&quot;üçéüçéüçé&quot;</span>));
<span class="tok-comment">// ‚Üí false</span>
console.log(<span class="tok-string2">/&lt;.&gt;/</span>.test(<span class="tok-string">&quot;&lt;üåπ&gt;&quot;</span>));
<span class="tok-comment">// ‚Üí false</span>
console.log(<span class="tok-string2">/&lt;.&gt;/u</span>.test(<span class="tok-string">&quot;&lt;üåπ&gt;&quot;</span>));
<span class="tok-comment">// ‚Üí true</span></pre>

<p><a class="p_ident" id="p-tkZzF4g00f" href="#p-tkZzF4g00f" tabindex="-1" role="presentation"></a>El problema es que el üçé en la primera l√≠nea se trata como dos unidades de c√≥digo, y la parte <code>{3}</code> se aplica solo al segundo. Del mismo modo, el punto coincidir√° con una sola unidad de c√≥digo, no con las dos que componen la rosa emoji.</p>

<p><a class="p_ident" id="p-u0Yir1kR27" href="#p-u0Yir1kR27" tabindex="-1" role="presentation"></a>Debes agregar la opci√≥n <code>u</code> (Unicode) a tu expresi√≥n regular para que trate correctamente este tipo de caracteres.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-3HTiC3yQKP" href="#c-3HTiC3yQKP" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string2">/üçé{3}/u</span>.test(<span class="tok-string">&quot;üçéüçéüçé&quot;</span>));
<span class="tok-comment">// ‚Üí true</span></pre>

<h2 id="summary_regexp"><a class="h_ident" id="h-NUFOUyK+lw" href="#h-NUFOUyK+lw" tabindex="-1" role="presentation"></a>Resumen</h2>

<p><a class="p_ident" id="p-Odk02sNpX4" href="#p-Odk02sNpX4" tabindex="-1" role="presentation"></a>Las expresiones regulares son objetos que representan patrones en cadenas. Utilizan su propio lenguaje para expresar estos patrones.</p>

<table>

<tr><td><code>/abc/</code></td><td>Una secuencia de caracteres</td>

</tr>

<tr><td><code>/[abc]/</code></td><td>Cualquier car√°cter de un conjunto de caracteres</td>

</tr>

<tr><td><code>/[^abc]/</code></td><td>Cualquier car√°cter <em>que no est√©</em> en un conjunto de caracteres</td>

</tr>

<tr><td><code>/[0-9]/</code></td><td>Cualquier car√°cter en un rango de caracteres</td>

</tr>

<tr><td><code>/x+/</code></td><td>Una o m√°s ocurrencias del patr√≥n <code>x</code></td>

</tr>

<tr><td><code>/x+?/</code></td><td>Una o m√°s ocurrencias, perezoso</td>

</tr>

<tr><td><code>/x*/</code></td><td>Cero o m√°s ocurrencias</td>

</tr>

<tr><td><code>/x?/</code></td><td>Cero o una ocurrencia</td>

</tr>

<tr><td><code>/x{2,4}/</code></td><td>Dos a cuatro ocurrencias</td>

</tr>

<tr><td><code>/(abc)/</code></td><td>Un grupo</td>

</tr>

<tr><td><code>/a|b|c/</code></td><td>Cualquiera de varias combinaciones de patrones</td>

</tr>

<tr><td><code>/\d/</code></td><td>Cualquier car√°cter de d√≠gito</td>

</tr>

<tr><td><code>/\w/</code></td><td>Un car√°cter alfanum√©rico (‚Äúcar√°cter de palabra‚Äù)</td>

</tr>

<tr><td><code>/\s/</code></td><td>Cualquier car√°cter de espacio en blanco</td>

</tr>

<tr><td><code>/./</code></td><td>Cualquier car√°cter excepto saltos de l√≠nea</td>

</tr>

<tr><td><code>/\p{L}/u</code></td><td>Cualquier car√°cter de letra</td>

</tr>

<tr><td><code>/^/</code></td><td>Inicio de entrada</td>

</tr>

<tr><td><code>/$/</code></td><td>Fin de entrada</td>

</tr>

<tr><td><code>/(?=a)/</code></td><td>Una prueba de vistazo hacia adelante</td>

</tr>

</table>

<p><a class="p_ident" id="p-CFboyM9HDn" href="#p-CFboyM9HDn" tabindex="-1" role="presentation"></a>Una expresi√≥n regular tiene un m√©todo <code>test</code> para comprobar si una cadena dada coincide con ella. Tambi√©n tiene un m√©todo <code>exec</code> que, cuando se encuentra una coincidencia, devuelve un array que contiene todos los grupos coincidentes. Dicho array tiene una propiedad <code>index</code> que indica d√≥nde empez√≥ la coincidencia.Las cadenas tienen un m√©todo <code>match</code> para compararlas con una expresi√≥n regular y un m√©todo <code>search</code> para buscar una, devolviendo solo la posici√≥n de inicio de la coincidencia. Su m√©todo <code>replace</code> puede reemplazar coincidencias de un patr√≥n con una cadena o funci√≥n de reemplazo.</p>

<p><a class="p_ident" id="p-5tlP70sWEp" href="#p-5tlP70sWEp" tabindex="-1" role="presentation"></a>Las expresiones regulares pueden tener opciones, que se escriben despu√©s de la barra de cierre. La opci√≥n <code>i</code> hace que la coincidencia no distinga entre may√∫sculas y min√∫sculas. La opci√≥n <code>g</code> hace que la expresi√≥n sea <em>global</em>, lo que, entre otras cosas, hace que el m√©todo <code>replace</code> reemplace todas las instancias en lugar de solo la primera. La opci√≥n <code>y</code> la hace persistente, lo que significa que no buscar√° por delante ni omitir√° parte de la cadena al buscar una coincidencia. La opci√≥n <code>u</code> activa el modo Unicode, que habilita la sintaxis <code>\p</code> y soluciona varios problemas en torno al manejo de caracteres que ocupan dos unidades de c√≥digo.</p>

<p><a class="p_ident" id="p-Hw5k4JvKlE" href="#p-Hw5k4JvKlE" tabindex="-1" role="presentation"></a>Las expresiones regulares son una herramienta afilada con un mango inc√≥modo. Simplifican enormemente algunas tareas, pero pueden volverse r√°pidamente ingobernables cuando se aplican a problemas complejos. Parte de saber c√≥mo usarlas es resistir la tentaci√≥n de intentar forzar cosas que no pueden expresarse de forma clara en ellas.</p>

<h2><a class="h_ident" id="h-tkm7ntLto1" href="#h-tkm7ntLto1" tabindex="-1" role="presentation"></a>Ejercicios</h2>

<p><a class="p_ident" id="p-7luPllNrX9" href="#p-7luPllNrX9" tabindex="-1" role="presentation"></a>Es casi inevitable que, al trabajar en estos ejercicios, te sientas confundido y frustrado por el comportamiento inexplicable de algunas expresiones regulares. A veces ayuda introducir tu expresi√≥n en una herramienta en l√≠nea como <a href="https://www.debuggex.com/"><em>debuggex.com</em></a> para ver si su visualizaci√≥n corresponde a lo que pretend√≠as y para experimentar con la forma en que responde a diferentes cadenas de entrada.</p>

<h3><a class="i_ident" id="i-vDM8PzwQWU" href="#i-vDM8PzwQWU" tabindex="-1" role="presentation"></a>Regexp golf</h3>

<p><a class="p_ident" id="p-f3iYNNsbiL" href="#p-f3iYNNsbiL" tabindex="-1" role="presentation"></a><em>Code golf</em> es un t√©rmino utilizado para el juego de intentar expresar un programa en particular con la menor cantidad de caracteres posible. De manera similar, <em>regexp golf</em> es la pr√°ctica de escribir una expresi√≥n regular lo m√°s peque√±a posible para que coincida con un patr√≥n dado, y <em>solo</em> ese patr√≥n.</p>

<p><a class="p_ident" id="p-74bE61d3fk" href="#p-74bE61d3fk" tabindex="-1" role="presentation"></a>Para cada uno de los siguientes elementos, escribe una expresi√≥n regular para comprobar si el patr√≥n dado ocurre en una cadena. La expresi√≥n regular debe coincidir solo con cadenas que contengan el patr√≥n. Cuando tu expresi√≥n funcione, verifica si puedes hacerla m√°s peque√±a.</p>

<ol>

<li>

<p><a class="p_ident" id="p-G1x4eWBRd+" href="#p-G1x4eWBRd+" tabindex="-1" role="presentation"></a><em>car</em> y <em>cat</em></p></li>

<li>

<p><a class="p_ident" id="p-LUL5rXROVp" href="#p-LUL5rXROVp" tabindex="-1" role="presentation"></a><em>pop</em> y <em>prop</em></p></li>

<li>

<p><a class="p_ident" id="p-4grj7sKuEe" href="#p-4grj7sKuEe" tabindex="-1" role="presentation"></a><em>ferret</em>, <em>ferry</em> y <em>ferrari</em></p></li>

<li>

<p><a class="p_ident" id="p-QQ5/lZXIIE" href="#p-QQ5/lZXIIE" tabindex="-1" role="presentation"></a>Cualquier palabra que termine en <em>ious</em></p></li>

<li>

<p><a class="p_ident" id="p-3zcZI8F3XE" href="#p-3zcZI8F3XE" tabindex="-1" role="presentation"></a>Un car√°cter de espacio en blanco seguido de un punto, coma, dos puntos o punto y coma</p></li>

<li>

<p><a class="p_ident" id="p-ElfdU/EyTI" href="#p-ElfdU/EyTI" tabindex="-1" role="presentation"></a>Una palabra con m√°s de seis letras</p></li>

<li>

<p><a class="p_ident" id="p-ex6we1EAMv" href="#p-ex6we1EAMv" tabindex="-1" role="presentation"></a>Una palabra sin la letra <em>e</em> (o <em>E</em>)</p></li>

</ol>

<p><a class="p_ident" id="p-sw+R4CLmjK" href="#p-sw+R4CLmjK" tabindex="-1" role="presentation"></a>Consulta la tabla en el <a href="09_regexp.html#summary_regexp">resumen del cap√≠tulo</a> para obtener ayuda. Prueba cada soluci√≥n con algunas cadenas de prueba.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-V69VVjpD/G" href="#c-V69VVjpD/G" tabindex="-1" role="presentation"></a><span class="tok-comment">// Fill in the regular expressions</span>

verify(<span class="tok-string2">/.../</span>,
       [<span class="tok-string">&quot;my car&quot;</span>, <span class="tok-string">&quot;bad cats&quot;</span>],
       [<span class="tok-string">&quot;camper&quot;</span>, <span class="tok-string">&quot;high art&quot;</span>]);

verify(<span class="tok-string2">/.../</span>,
       [<span class="tok-string">&quot;pop culture&quot;</span>, <span class="tok-string">&quot;mad props&quot;</span>],
       [<span class="tok-string">&quot;plop&quot;</span>, <span class="tok-string">&quot;prrrop&quot;</span>]);

verify(<span class="tok-string2">/.../</span>,
       [<span class="tok-string">&quot;ferret&quot;</span>, <span class="tok-string">&quot;ferry&quot;</span>, <span class="tok-string">&quot;ferrari&quot;</span>],
       [<span class="tok-string">&quot;ferrum&quot;</span>, <span class="tok-string">&quot;transfer A&quot;</span>]);

verify(<span class="tok-string2">/.../</span>,
       [<span class="tok-string">&quot;how delicious&quot;</span>, <span class="tok-string">&quot;spacious room&quot;</span>],
       [<span class="tok-string">&quot;ruinous&quot;</span>, <span class="tok-string">&quot;consciousness&quot;</span>]);

verify(<span class="tok-string2">/.../</span>,
       [<span class="tok-string">&quot;bad punctuation .&quot;</span>],
       [<span class="tok-string">&quot;escape the period&quot;</span>]);

verify(<span class="tok-string2">/.../</span>,
       [<span class="tok-string">&quot;Siebentausenddreihundertzweiundzwanzig&quot;</span>],
       [<span class="tok-string">&quot;no&quot;</span>, <span class="tok-string">&quot;three small words&quot;</span>]);

verify(<span class="tok-string2">/.../</span>,
       [<span class="tok-string">&quot;red platypus&quot;</span>, <span class="tok-string">&quot;wobbling nest&quot;</span>],
       [<span class="tok-string">&quot;earth bed&quot;</span>, <span class="tok-string">&quot;bedr√∏vet abe&quot;</span>, <span class="tok-string">&quot;BEET&quot;</span>]);


<span class="tok-keyword">function</span> <span class="tok-definition">verify</span>(<span class="tok-definition">regexp</span>, <span class="tok-definition">yes</span>, <span class="tok-definition">no</span>) {
  <span class="tok-comment">// Ignore unfinished exercises</span>
  <span class="tok-keyword">if</span> (regexp.source == <span class="tok-string">&quot;...&quot;</span>) <span class="tok-keyword">return</span>;
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">str</span> <span class="tok-keyword">of</span> yes) <span class="tok-keyword">if</span> (!regexp.test(str)) {
    console.log(<span class="tok-string2">`Failure to match '</span>${str}<span class="tok-string2">'`</span>);
  }
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">str</span> <span class="tok-keyword">of</span> no) <span class="tok-keyword">if</span> (regexp.test(str)) {
    console.log(<span class="tok-string2">`Unexpected match for '</span>${str}<span class="tok-string2">'`</span>);
  }
}</pre>

<h3><a class="i_ident" id="i-efCNhNV5nJ" href="#i-efCNhNV5nJ" tabindex="-1" role="presentation"></a>Estilo de comillas</h3>

<p><a class="p_ident" id="p-Vlm4WMQc9O" href="#p-Vlm4WMQc9O" tabindex="-1" role="presentation"></a>Imagina que has escrito una historia y usaste comillas simples single-quote character para marcar piezas de di√°logo. Ahora quieres reemplazar todas las comillas de di√°logo con comillas dobles, manteniendo las comillas simples utilizadas en contracciones como <em>aren‚Äôt</em>.</p>

<p><a class="p_ident" id="p-6mNToRPnum" href="#p-6mNToRPnum" tabindex="-1" role="presentation"></a>Piensa en un patr√≥n que distinga estos dos tipos de uso de comillas y crea una llamada al m√©todo <code>replace</code> que realice el reemplazo adecuado.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-2AAfiUdDr8" href="#c-2AAfiUdDr8" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">text</span> = <span class="tok-string">&quot;'I'm the cook,' he said, 'it's my job.'&quot;</span>;
<span class="tok-comment">// Cambia esta llamada.</span>
console.log(text.replace(<span class="tok-string2">/A/g</span>, <span class="tok-string">&quot;B&quot;</span>));
<span class="tok-comment">// ‚Üí &quot;I'm the cook,&quot; he said, &quot;it's my job.&quot;</span></pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-F9p3rrsc74" href="#p-F9p3rrsc74" tabindex="-1" role="presentation"></a>La soluci√≥n m√°s obvia es reemplazar solo las comillas que tienen un car√°cter que no sea una letra en al menos un lado, algo como <code>/\P{L}'|'\P{L}/</code>. Pero tambi√©n debes tener en cuenta el inicio y el final de la l√≠nea.</p>

<p><a class="p_ident" id="p-qbGJneI2P1" href="#p-qbGJneI2P1" tabindex="-1" role="presentation"></a>Adem√°s, debes asegurarte de que la sustituci√≥n tambi√©n incluya los caracteres que coincidieron con el patr√≥n <code>\P{L}</code> para que no se eliminen. Esto se puede hacer envolvi√©ndolos entre par√©ntesis e incluyendo sus grupos en la cadena de reemplazo (<code>$1</code>, <code>$2</code>). Los grupos que no se emparejen se reemplazar√°n por nada.</p>

</div></details>

<h3><a class="i_ident" id="i-YSgOufjbNE" href="#i-YSgOufjbNE" tabindex="-1" role="presentation"></a>N√∫meros nuevamente</h3>

<p><a class="p_ident" id="p-oeGH9sXraQ" href="#p-oeGH9sXraQ" tabindex="-1" role="presentation"></a>Escribe una expresi√≥n que coincida solo con los n√∫meros al estilo de JavaScript. Debe admitir un signo menos <em>o</em> m√°s opcional delante del n√∫mero, el punto decimal y la notaci√≥n de exponente‚Äî<code>5e-3</code> o <code>1E10</code>‚Äîde nuevo con un signo opcional delante del exponente. Tambi√©n ten en cuenta que no es necesario que haya d√≠gitos delante o despu√©s del punto, pero el n√∫mero no puede ser solo un punto. Es decir, <code>.5</code> y <code>5.</code> son n√∫meros de JavaScript v√°lidos, pero un punto solitario <em>no</em> lo es.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-gXUEPT1mXR" href="#c-gXUEPT1mXR" tabindex="-1" role="presentation"></a><span class="tok-comment">// Completa esta expresi√≥n regular.</span>
<span class="tok-keyword">let</span> <span class="tok-definition">number</span> = <span class="tok-string2">/^...$/</span>;

<span class="tok-comment">// Pruebas:</span>
<span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">str</span> <span class="tok-keyword">of</span> [<span class="tok-string">&quot;1&quot;</span>, <span class="tok-string">&quot;-1&quot;</span>, <span class="tok-string">&quot;+15&quot;</span>, <span class="tok-string">&quot;1.55&quot;</span>, <span class="tok-string">&quot;.5&quot;</span>, <span class="tok-string">&quot;5.&quot;</span>,
                 <span class="tok-string">&quot;1.3e2&quot;</span>, <span class="tok-string">&quot;1E-4&quot;</span>, <span class="tok-string">&quot;1e+12&quot;</span>]) {
  <span class="tok-keyword">if</span> (!number.test(str)) {
    console.log(<span class="tok-string2">`Failed to match '</span>${str}<span class="tok-string2">'`</span>);
  }
}
<span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">str</span> <span class="tok-keyword">of</span> [<span class="tok-string">&quot;1a&quot;</span>, <span class="tok-string">&quot;+-1&quot;</span>, <span class="tok-string">&quot;1.2.3&quot;</span>, <span class="tok-string">&quot;1+1&quot;</span>, <span class="tok-string">&quot;1e4.5&quot;</span>,
                 <span class="tok-string">&quot;.5.&quot;</span>, <span class="tok-string">&quot;1f5&quot;</span>, <span class="tok-string">&quot;.&quot;</span>]) {
  <span class="tok-keyword">if</span> (number.test(str)) {
    console.log(<span class="tok-string2">`Incorrectly accepted '</span>${str}<span class="tok-string2">'`</span>);
  }
}</pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-4VDCgxohNU" href="#p-4VDCgxohNU" tabindex="-1" role="presentation"></a>Primero, no olvides la barra invertida delante del punto.</p>

<p><a class="p_ident" id="p-aGz24Obe10" href="#p-aGz24Obe10" tabindex="-1" role="presentation"></a>Para hacer coincidir el signo opcional delante del n√∫mero, as√≠ como delante del exponente, se puede hacer con <code>[+\-]?</code> o <code>(\+|-|)</code> (m√°s, menos, o nada).</p>

<p><a class="p_ident" id="p-+Tjzh9qDET" href="#p-+Tjzh9qDET" tabindex="-1" role="presentation"></a>La parte m√°s complicada del ejercicio es el problema de hacer coincidir tanto <code>&quot;5.&quot;</code> como <code>&quot;.5&quot;</code> sin hacer coincidir tambi√©n <code>&quot;.&quot;</code>. Para esto, una buena soluci√≥n es usar el operador <code>|</code> para separar los dos casos: uno o m√°s d√≠gitos seguidos opcionalmente por un punto y cero o m√°s d√≠gitos <em>o</em> un punto seguido por uno o m√°s d√≠gitos.</p>

<p><a class="p_ident" id="p-6x0vWl69bT" href="#p-6x0vWl69bT" tabindex="-1" role="presentation"></a>Finalmente, para hacer que el caso de la <em>e</em> sea insensible a may√∫sculas y min√∫sculas, a√±ade una opci√≥n <code>i</code> a la expresi√≥n regular o usa <code>[eE]</code>.</p>

</div></details><nav><a href="08_error.html" title="previous chapter" aria-label="previous chapter">‚óÇ</a>¬†<a href="index.html" title="cover" aria-label="cover">‚óè</a>¬†<a href="10_modules.html" title="next chapter" aria-label="next chapter">‚ñ∏</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>&nbsp;<button class="dark-mode-toggle">üåô</button>
</nav>
</article>

<script src="ejs.js"></script>
